import {
  getRpcClient
} from "./chunk-AQTV3AJL.js";
import {
  LruMap
} from "./chunk-7C2JITWE.js";
import {
  stringify
} from "./chunk-XMVENQD3.js";
import {
  concat,
  decodeAbiParameters,
  defineFormatter,
  hexToNumber,
  parseAbiItem,
  slice,
  toFunctionSelector
} from "./chunk-HMZMTDNX.js";
import {
  SHA2
} from "./chunk-EQTMJVFD.js";
import {
  wrapConstructor as wrapConstructor2
} from "./chunk-QBEUODG3.js";
import {
  assertSize,
  boolToHex,
  byteSize,
  cachedTextEncoder,
  hexToUint8Array,
  isHex,
  numberToHex,
  padHex,
  stringToHex,
  uint8ArrayToHex
} from "./chunk-DOKT7LHU.js";
import {
  Hash,
  byteSwap32,
  bytes,
  exists,
  isLE,
  number,
  output,
  toBytes,
  u32,
  wrapConstructor,
  wrapXOFConstructorWithOpts
} from "./chunk-S7TFJEVG.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/read-contract.js
init_shim();

// node_modules/viem/_esm/index.js
init_shim();

// node_modules/viem/_esm/actions/getContract.js
init_shim();

// node_modules/viem/_esm/utils/getAction.js
init_shim();

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
init_shim();

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_shim();

// node_modules/viem/_esm/errors/log.js
init_shim();

// node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
init_shim();

// node_modules/viem/_esm/actions/public/estimateContractGas.js
init_shim();

// node_modules/viem/_esm/utils/errors/getContractError.js
init_shim();

// node_modules/viem/_esm/actions/public/estimateGas.js
init_shim();

// node_modules/viem/_esm/utils/errors/getEstimateGasError.js
init_shim();

// node_modules/viem/_esm/errors/estimateGas.js
init_shim();

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_shim();

// node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
init_shim();

// node_modules/viem/_esm/errors/fee.js
init_shim();

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
init_shim();

// node_modules/viem/_esm/actions/public/getBlock.js
init_shim();

// node_modules/viem/_esm/errors/block.js
init_shim();

// node_modules/viem/_esm/utils/formatters/block.js
init_shim();

// node_modules/viem/_esm/utils/formatters/transaction.js
init_shim();
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);

// node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = block.transactions?.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/viem/_esm/actions/public/getGasPrice.js
init_shim();

// node_modules/viem/_esm/actions/public/getTransactionCount.js
init_shim();

// node_modules/viem/_esm/utils/blob/blobsToCommitments.js
init_shim();

// node_modules/viem/_esm/utils/blob/blobsToProofs.js
init_shim();

// node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
init_shim();

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
init_shim();

// node_modules/viem/_esm/utils/hash/sha256.js
init_shim();

// node_modules/viem/_esm/utils/blob/toBlobSidecars.js
init_shim();

// node_modules/viem/_esm/utils/blob/toBlobs.js
init_shim();

// node_modules/viem/_esm/constants/blob.js
init_shim();
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - 1 - 1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/viem/_esm/errors/blob.js
init_shim();

// node_modules/viem/_esm/constants/kzg.js
init_shim();

// node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_shim();

// node_modules/viem/_esm/actions/public/getChainId.js
init_shim();

// node_modules/viem/_esm/actions/public/getContractEvents.js
init_shim();

// node_modules/viem/_esm/actions/public/getLogs.js
init_shim();

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
init_shim();

// node_modules/viem/_esm/utils/abi/decodeEventLog.js
init_shim();

// node_modules/viem/_esm/utils/formatters/log.js
init_shim();
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/viem/_esm/actions/public/readContract.js
init_shim();

// node_modules/viem/_esm/actions/public/simulateContract.js
init_shim();

// node_modules/viem/_esm/actions/public/watchContractEvent.js
init_shim();

// node_modules/viem/_esm/utils/observe.js
init_shim();

// node_modules/viem/_esm/utils/poll.js
init_shim();

// node_modules/viem/_esm/utils/wait.js
init_shim();

// node_modules/viem/_esm/actions/public/getBlockNumber.js
init_shim();

// node_modules/viem/_esm/utils/promise/withCache.js
init_shim();

// node_modules/viem/_esm/actions/public/getFilterChanges.js
init_shim();

// node_modules/viem/_esm/actions/public/uninstallFilter.js
init_shim();

// node_modules/viem/_esm/actions/wallet/writeContract.js
init_shim();

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_shim();

// node_modules/viem/_esm/errors/account.js
init_shim();

// node_modules/viem/_esm/utils/chain/assertCurrentChain.js
init_shim();

// node_modules/viem/_esm/utils/errors/getTransactionError.js
init_shim();

// node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
init_shim();

// node_modules/viem/_esm/actions/wallet/addChain.js
init_shim();

// node_modules/viem/_esm/clients/createClient.js
init_shim();

// node_modules/viem/_esm/utils/accounts.js
init_shim();

// node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
init_shim();

// node_modules/viem/_esm/utils/uid.js
init_shim();

// node_modules/viem/_esm/clients/transports/custom.js
init_shim();

// node_modules/viem/_esm/clients/transports/createTransport.js
init_shim();

// node_modules/viem/_esm/utils/buildRequest.js
init_shim();

// node_modules/viem/_esm/utils/promise/withRetry.js
init_shim();

// node_modules/viem/_esm/clients/transports/fallback.js
init_shim();

// node_modules/viem/_esm/clients/transports/http.js
init_shim();

// node_modules/viem/_esm/errors/transport.js
init_shim();

// node_modules/viem/_esm/utils/rpc/http.js
init_shim();

// node_modules/viem/_esm/utils/promise/withTimeout.js
init_shim();

// node_modules/viem/_esm/utils/rpc/id.js
init_shim();
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/viem/_esm/clients/createPublicClient.js
init_shim();

// node_modules/viem/_esm/clients/decorators/public.js
init_shim();

// node_modules/viem/_esm/actions/ens/getEnsAddress.js
init_shim();

// node_modules/viem/_esm/utils/ens/errors.js
init_shim();

// node_modules/viem/_esm/utils/ens/namehash.js
init_shim();

// node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
init_shim();

// node_modules/viem/_esm/utils/ens/packetToBytes.js
init_shim();

// node_modules/viem/_esm/utils/ens/encodeLabelhash.js
init_shim();

// node_modules/viem/_esm/utils/ens/labelhash.js
init_shim();

// node_modules/viem/_esm/actions/ens/getEnsAvatar.js
init_shim();

// node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
init_shim();

// node_modules/viem/_esm/utils/ens/avatar/utils.js
init_shim();

// node_modules/viem/_esm/errors/ens.js
init_shim();

// node_modules/viem/_esm/actions/ens/getEnsText.js
init_shim();

// node_modules/viem/_esm/actions/ens/getEnsName.js
init_shim();

// node_modules/viem/_esm/actions/ens/getEnsResolver.js
init_shim();

// node_modules/viem/_esm/actions/public/createBlockFilter.js
init_shim();

// node_modules/viem/_esm/actions/public/createEventFilter.js
init_shim();

// node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
init_shim();

// node_modules/viem/_esm/actions/public/getBalance.js
init_shim();

// node_modules/viem/_esm/actions/public/getBlobBaseFee.js
init_shim();

// node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
init_shim();

// node_modules/viem/_esm/actions/public/getBytecode.js
init_shim();

// node_modules/viem/_esm/actions/public/getFeeHistory.js
init_shim();

// node_modules/viem/_esm/utils/formatters/feeHistory.js
init_shim();

// node_modules/viem/_esm/actions/public/getFilterLogs.js
init_shim();

// node_modules/viem/_esm/actions/public/getProof.js
init_shim();

// node_modules/viem/_esm/utils/formatters/proof.js
init_shim();

// node_modules/viem/_esm/utils/index.js
init_shim();

// node_modules/viem/_esm/utils/chain/defineChain.js
init_shim();

// node_modules/viem/_esm/utils/chain/extractChain.js
init_shim();

// node_modules/viem/_esm/utils/regex.js
init_shim();

// node_modules/viem/_esm/utils/rpc/compat.js
init_shim();

// node_modules/viem/_esm/utils/rpc/webSocket.js
init_shim();

// node_modules/viem/_esm/utils/rpc/socket.js
init_shim();

// node_modules/viem/_esm/utils/typedData.js
init_shim();

// node_modules/viem/_esm/utils/signature/hashTypedData.js
init_shim();

// node_modules/viem/_esm/utils/abi/decodeFunctionData.js
init_shim();

// node_modules/viem/_esm/utils/abi/encodeDeployData.js
init_shim();

// node_modules/viem/_esm/utils/abi/encodeErrorResult.js
init_shim();

// node_modules/viem/_esm/utils/abi/encodeFunctionResult.js
init_shim();

// node_modules/viem/_esm/utils/abi/encodePacked.js
init_shim();

// node_modules/viem/_esm/utils/address/getContractAddress.js
init_shim();

// node_modules/viem/_esm/utils/data/isBytes.js
init_shim();

// node_modules/viem/_esm/utils/encoding/toRlp.js
init_shim();

// node_modules/viem/_esm/utils/formatters/transactionReceipt.js
init_shim();
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/viem/_esm/utils/encoding/fromRlp.js
init_shim();

// node_modules/viem/_esm/utils/hash/toEventSignature.js
init_shim();

// node_modules/viem/_esm/utils/hash/toFunctionSignature.js
init_shim();

// node_modules/viem/_esm/utils/hash/toEventHash.js
init_shim();

// node_modules/viem/_esm/utils/hash/toFunctionHash.js
init_shim();

// node_modules/viem/_esm/utils/hash/isHash.js
init_shim();

// node_modules/viem/_esm/utils/hash/ripemd160.js
init_shim();

// node_modules/viem/node_modules/@noble/hashes/esm/ripemd160.js
init_shim();
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
var Pi = Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0; i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
var BUF = new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor2(() => new RIPEMD160());

// node_modules/viem/_esm/utils/signature/recoverAddress.js
init_shim();

// node_modules/viem/_esm/utils/signature/recoverPublicKey.js
init_shim();

// node_modules/viem/_esm/utils/signature/recoverMessageAddress.js
init_shim();

// node_modules/viem/_esm/utils/signature/hashMessage.js
init_shim();

// node_modules/viem/_esm/constants/strings.js
init_shim();

// node_modules/viem/_esm/utils/signature/recoverTypedDataAddress.js
init_shim();

// node_modules/viem/_esm/utils/signature/verifyMessage.js
init_shim();

// node_modules/viem/_esm/utils/signature/verifyTypedData.js
init_shim();

// node_modules/viem/_esm/utils/transaction/getSerializedTransactionType.js
init_shim();

// node_modules/viem/_esm/utils/transaction/assertTransaction.js
init_shim();

// node_modules/viem/_esm/utils/transaction/parseTransaction.js
init_shim();

// node_modules/viem/_esm/utils/transaction/serializeTransaction.js
init_shim();

// node_modules/viem/_esm/utils/transaction/serializeAccessList.js
init_shim();

// node_modules/viem/_esm/utils/unit/parseUnits.js
init_shim();

// node_modules/viem/_esm/utils/unit/parseEther.js
init_shim();

// node_modules/viem/_esm/utils/unit/parseGwei.js
init_shim();

// node_modules/viem/_esm/actions/public/getStorageAt.js
init_shim();

// node_modules/viem/_esm/actions/public/getTransaction.js
init_shim();

// node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
init_shim();

// node_modules/viem/_esm/actions/public/getTransactionReceipt.js
init_shim();

// node_modules/viem/_esm/actions/public/multicall.js
init_shim();

// node_modules/viem/_esm/actions/public/verifyMessage.js
init_shim();

// node_modules/viem/_esm/actions/public/verifyHash.js
init_shim();

// node_modules/viem/_esm/constants/contracts.js
init_shim();

// node_modules/viem/_esm/utils/data/isBytesEqual.js
init_shim();

// node_modules/viem/_esm/utils/signature/serializeSignature.js
init_shim();

// node_modules/viem/_esm/actions/public/verifyTypedData.js
init_shim();

// node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
init_shim();

// node_modules/viem/_esm/actions/public/watchBlockNumber.js
init_shim();

// node_modules/viem/_esm/actions/public/watchBlocks.js
init_shim();

// node_modules/viem/_esm/actions/public/watchEvent.js
init_shim();

// node_modules/viem/_esm/actions/public/watchPendingTransactions.js
init_shim();

// node_modules/viem/_esm/clients/createTestClient.js
init_shim();

// node_modules/viem/_esm/clients/decorators/test.js
init_shim();

// node_modules/viem/_esm/actions/test/dropTransaction.js
init_shim();

// node_modules/viem/_esm/actions/test/dumpState.js
init_shim();

// node_modules/viem/_esm/actions/test/getAutomine.js
init_shim();

// node_modules/viem/_esm/actions/test/getTxpoolContent.js
init_shim();

// node_modules/viem/_esm/actions/test/getTxpoolStatus.js
init_shim();

// node_modules/viem/_esm/actions/test/impersonateAccount.js
init_shim();

// node_modules/viem/_esm/actions/test/increaseTime.js
init_shim();

// node_modules/viem/_esm/actions/test/inspectTxpool.js
init_shim();

// node_modules/viem/_esm/actions/test/loadState.js
init_shim();

// node_modules/viem/_esm/actions/test/mine.js
init_shim();

// node_modules/viem/_esm/actions/test/removeBlockTimestampInterval.js
init_shim();

// node_modules/viem/_esm/actions/test/reset.js
init_shim();

// node_modules/viem/_esm/actions/test/revert.js
init_shim();

// node_modules/viem/_esm/actions/test/sendUnsignedTransaction.js
init_shim();

// node_modules/viem/_esm/actions/test/setAutomine.js
init_shim();

// node_modules/viem/_esm/actions/test/setBalance.js
init_shim();

// node_modules/viem/_esm/actions/test/setBlockGasLimit.js
init_shim();

// node_modules/viem/_esm/actions/test/setBlockTimestampInterval.js
init_shim();

// node_modules/viem/_esm/actions/test/setCode.js
init_shim();

// node_modules/viem/_esm/actions/test/setCoinbase.js
init_shim();

// node_modules/viem/_esm/actions/test/setIntervalMining.js
init_shim();

// node_modules/viem/_esm/actions/test/setLoggingEnabled.js
init_shim();

// node_modules/viem/_esm/actions/test/setMinGasPrice.js
init_shim();

// node_modules/viem/_esm/actions/test/setNextBlockBaseFeePerGas.js
init_shim();

// node_modules/viem/_esm/actions/test/setNextBlockTimestamp.js
init_shim();

// node_modules/viem/_esm/actions/test/setNonce.js
init_shim();

// node_modules/viem/_esm/actions/test/setRpcUrl.js
init_shim();

// node_modules/viem/_esm/actions/test/setStorageAt.js
init_shim();

// node_modules/viem/_esm/actions/test/snapshot.js
init_shim();

// node_modules/viem/_esm/actions/test/stopImpersonatingAccount.js
init_shim();

// node_modules/viem/_esm/clients/decorators/wallet.js
init_shim();

// node_modules/viem/_esm/actions/wallet/deployContract.js
init_shim();

// node_modules/viem/_esm/actions/wallet/getAddresses.js
init_shim();

// node_modules/viem/_esm/actions/wallet/getPermissions.js
init_shim();

// node_modules/viem/_esm/actions/wallet/requestAddresses.js
init_shim();

// node_modules/viem/_esm/actions/wallet/requestPermissions.js
init_shim();

// node_modules/viem/_esm/actions/wallet/signMessage.js
init_shim();

// node_modules/viem/_esm/actions/wallet/signTransaction.js
init_shim();

// node_modules/viem/_esm/actions/wallet/signTypedData.js
init_shim();

// node_modules/viem/_esm/actions/wallet/switchChain.js
init_shim();

// node_modules/viem/_esm/actions/wallet/watchAsset.js
init_shim();

// node_modules/viem/_esm/clients/createWalletClient.js
init_shim();

// node_modules/viem/_esm/clients/transports/webSocket.js
init_shim();

// node_modules/viem/_esm/constants/address.js
init_shim();

// node_modules/viem/_esm/constants/number.js
init_shim();
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint256 = 2n ** 256n - 1n;

// node_modules/viem/_esm/constants/bytes.js
init_shim();

// node_modules/viem/_esm/utils/abi/decodeDeployData.js
init_shim();

// node_modules/viem/_esm/utils/signature/compactSignatureToSignature.js
init_shim();

// node_modules/viem/_esm/utils/signature/parseCompactSignature.js
init_shim();

// node_modules/viem/_esm/utils/signature/parseSignature.js
init_shim();

// node_modules/viem/_esm/utils/signature/recoverTransactionAddress.js
init_shim();

// node_modules/viem/_esm/utils/signature/signatureToCompactSignature.js
init_shim();

// node_modules/viem/_esm/utils/signature/serializeCompactSignature.js
init_shim();

// node_modules/viem/_esm/utils/blob/sidecarsToVersionedHashes.js
init_shim();

// node_modules/viem/_esm/utils/blob/fromBlobs.js
init_shim();

// node_modules/viem/_esm/utils/kzg/defineKzg.js
init_shim();

// node_modules/viem/_esm/utils/kzg/setupKzg.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/utils.js
init_shim();
function isAbiFunction(item) {
  return !!(item && typeof item === "object" && "type" in item && item.type === "function");
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_call.js
init_shim();
function encodeStateOverrides(overrides) {
  return Object.fromEntries(Object.entries(overrides).map(([address, override]) => {
    return [
      address,
      {
        balance: override.balance ? numberToHex(override.balance) : void 0,
        nonce: override.nonce ? numberToHex(override.nonce) : void 0,
        code: override.code,
        state: override.state,
        stateDiff: override.stateDiff
      }
    ];
  }));
}
async function eth_call(request, params) {
  const { blockNumber, blockTag, ...txRequest } = params;
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const block = blockNumberHex || blockTag || "latest";
  return await request({
    method: "eth_call",
    params: params.stateOverrides ? [
      txRequest,
      block,
      encodeStateOverrides(params.stateOverrides)
    ] : [txRequest, block]
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/address.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/to-bytes.js
init_shim();
function padBytes2(bytes2, { dir, size: size2 = 32 } = {}) {
  if (size2 === null) {
    return bytes2;
  }
  if (bytes2.length > size2) {
    throw new Error(`Size overflow: ${bytes2.length} > ${size2}`);
  }
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0; i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes2[padEnd ? i : bytes2.length - i - 1];
  }
  return paddedBytes;
}
function stringToBytes2(value, opts = {}) {
  const bytes2 = cachedTextEncoder().encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes2, { size: opts.size });
    return padBytes2(bytes2, { dir: "right", size: opts.size });
  }
  return bytes2;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/hashing/keccak256.js
init_shim();

// node_modules/@noble/hashes/esm/sha3.js
init_shim();

// node_modules/@noble/hashes/esm/_u64.js
init_shim();
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

// node_modules/@noble/hashes/esm/sha3.js
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class extends Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    if (!isLE)
      byteSwap32(this.state32);
    keccakP(this.state32, this.rounds);
    if (!isLE)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/hashing/keccak256.js
function keccak2562(value, to) {
  const bytes2 = keccak_256(isHex(value, { strict: false }) ? hexToUint8Array(value) : value);
  if (to === "bytes") {
    return bytes2;
  }
  return uint8ArrayToHex(bytes2);
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/address.js
var ADRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
var IS_ADDRESS_CACHE = new LruMap(4096);
function isAddress2(address) {
  if (IS_ADDRESS_CACHE.has(address)) {
    return IS_ADDRESS_CACHE.get(address);
  }
  const result = (() => {
    if (!ADRESS_REGEX.test(address)) {
      return false;
    }
    if (address.toLowerCase() === address) {
      return true;
    }
    return checksumAddress2(address) === address;
  })();
  IS_ADDRESS_CACHE.set(address, result);
  return result;
}
function checksumAddress2(address) {
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(stringToBytes2(hexAddress), "bytes");
  const address_ = hexAddress.split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash[i >> 1] >> 4 >= 8 && address[i]) {
      address_[i] = address_[i].toUpperCase();
    }
    if ((hash[i >> 1] & 15) >= 8 && address[i + 1]) {
      address_[i + 1] = address_[i + 1].toUpperCase();
    }
  }
  return `0x${address_.join("")}`;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters2(params, values) {
  if (params.length !== values.length) {
    throw new Error("The number of parameters and values must match.");
  }
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0) {
    return "0x";
  }
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber(value, { signed });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new Error(`Unsupported parameter type: ${param.type}`);
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticSize += 32;
    } else {
      staticSize += byteSize(encoded);
    }
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += byteSize(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress2(value)) {
    throw new Error("Invalid address.");
  }
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value)) {
    throw new Error("Invalid array value.");
  }
  if (!dynamic && value.length !== length) {
    throw new Error("Invalid array length.");
  }
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic) {
      dynamicChild = true;
    }
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length_ = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat([length_, data]) : length_
      };
    }
    if (dynamicChild) {
      return { dynamic: true, encoded: data };
    }
  }
  return {
    dynamic: false,
    encoded: concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = byteSize(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0) {
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    }
    return {
      dynamic: true,
      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== Number.parseInt(paramSize)) {
    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);
  }
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue = stringToHex(value);
  const partsLength = Math.ceil(byteSize(hexValue) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat([
      padHex(numberToHex(byteSize(hexValue), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic) {
      dynamic = true;
    }
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/abi/prepare-method.js
init_shim();
var prepareMethodCache = new LruMap(4096);
function prepareMethod(method) {
  const key = typeof method === "string" ? method : stringify(method);
  if (prepareMethodCache.has(key)) {
    return prepareMethodCache.get(key);
  }
  const abiFn = typeof method === "string" ? parseAbiItem(method) : method;
  const sig = toFunctionSelector(abiFn);
  const ret = [sig, abiFn.inputs, abiFn.outputs];
  prepareMethodCache.set(key, ret);
  return ret;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/read-contract.js
async function readContract2(options) {
  const { contract, method, params } = options;
  const resolvePreparedMethod = async () => {
    if (Array.isArray(method)) {
      return method;
    }
    if (isAbiFunction(method)) {
      return prepareMethod(method);
    }
    if (typeof method === "function") {
      return prepareMethod(
        await method(contract)
      );
    }
    if (typeof method === "string" && method.startsWith("function ")) {
      const abiItem = parseAbiItem(method);
      if (abiItem.type === "function") {
        return prepareMethod(abiItem);
      }
      throw new Error(`"method" passed is not of type "function"`);
    }
    if (contract.abi && contract.abi?.length > 0) {
      const abiFunction = contract.abi?.find((item) => item.type === "function" && item.name === method);
      if (abiFunction) {
        return prepareMethod(abiFunction);
      }
    }
    throw new Error(`Could not resolve method "${method}".`);
  };
  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([
    resolvePreparedMethod(),
    typeof params === "function" ? params() : params
  ]);
  let encodedData;
  if (resolvedPreparedMethod[1].length === 0) {
    encodedData = resolvedPreparedMethod[0];
  } else {
    encodedData = resolvedPreparedMethod[0] + encodeAbiParameters2(
      resolvedPreparedMethod[1],
      resolvedParams
    ).slice(2);
  }
  const rpcRequest = getRpcClient({
    chain: contract.chain,
    client: contract.client
  });
  const result = await eth_call(rpcRequest, {
    data: encodedData,
    to: contract.address
  });
  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);
  if (Array.isArray(decoded) && decoded.length === 1) {
    return decoded[0];
  }
  return decoded;
}

export {
  stringToBytes2 as stringToBytes,
  formatTransactionReceipt,
  keccak2562 as keccak256,
  encodeAbiParameters2 as encodeAbiParameters,
  prepareMethod,
  isAbiFunction,
  readContract2 as readContract
};
//# sourceMappingURL=chunk-WG3IFTZB.js.map

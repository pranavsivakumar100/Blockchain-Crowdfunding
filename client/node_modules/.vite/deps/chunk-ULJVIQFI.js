import {
  approveErc20Allowance
} from "./chunk-INCOK333.js";
import {
  fetchTokenMetadataForContract,
  getBaseUriFromBatch
} from "./chunk-POEPSFOQ.js";
import {
  CommonNFTInput,
  normalizePriceValue
} from "./chunk-SRYWWROE.js";
import {
  ContractEncoder,
  hasFunction
} from "./chunk-LXY7U6R5.js";
import {
  CommonRoyaltySchema,
  FEATURE_OWNER,
  FEATURE_ROYALTY,
  NATIVE_TOKEN_ADDRESS,
  Transaction,
  buildTransactionFunction,
  resolveAddress
} from "./chunk-CFECTRPO.js";
import {
  Contract,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/contract-owner-bfdb8e71.browser.esm.js
init_shim();
init_lib();
var ContractRoyalty = class {
  constructor(contractWrapper, metadata) {
    __publicField(this, "featureName", FEATURE_ROYALTY.name);
    __publicField(this, "setDefaultRoyaltyInfo", buildTransactionFunction(async (royaltyData) => {
      const oldMetadata = await this.metadata.get();
      const mergedMetadata = await this.metadata.parseInputMetadata({
        ...oldMetadata,
        ...royaltyData
      });
      const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
      if (hasFunction("setContractURI", this.contractWrapper)) {
        const contractEncoder = new ContractEncoder(this.contractWrapper);
        const encoded = [contractEncoder.encode("setDefaultRoyaltyInfo", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode("setContractURI", [contractURI])];
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => ({
            receipt,
            data: () => this.getDefaultRoyaltyInfo()
          })
        });
      } else {
        throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.");
      }
    }));
    __publicField(this, "setTokenRoyaltyInfo", buildTransactionFunction(async (tokenId, royaltyData) => {
      const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setRoyaltyInfoForToken",
        args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],
        parse: (receipt) => ({
          receipt,
          data: () => this.getDefaultRoyaltyInfo()
        })
      });
    }));
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getDefaultRoyaltyInfo() {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read("getDefaultRoyaltyInfo", []);
    return CommonRoyaltySchema.parseAsync({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
  async getTokenRoyaltyInfo(tokenId) {
    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read("getRoyaltyInfoForToken", [tokenId]);
    return CommonRoyaltySchema.parseAsync({
      fee_recipient: royaltyRecipient,
      seller_fee_basis_points: royaltyBps
    });
  }
};
var DelayedReveal = class {
  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {
    __publicField(this, "createDelayedRevealBatch", buildTransactionFunction(async (placeholder, metadatas, password, options) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
        rewriteFileNames: {
          fileStartNumber: 0
        }
      });
      const placeholderUri = getBaseUriFromBatch(placeholderUris);
      const startFileNumber = await this.nextTokenIdToMintFn();
      const uris = await this.storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
        onProgress: options?.onProgress,
        rewriteFileNames: {
          fileStartNumber: startFileNumber.toNumber()
        }
      });
      const baseUri = getBaseUriFromBatch(uris);
      const baseUriId = await this.contractWrapper.read("getBaseURICount", []);
      const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);
      const encryptedBaseUri = await this.contractWrapper.read("encryptDecrypt", [utils_exports.toUtf8Bytes(baseUri), hashedPassword]);
      let data;
      const legacyContract = await this.isLegacyContract();
      if (legacyContract) {
        data = encryptedBaseUri;
      } else {
        const chainId = await this.contractWrapper.getChainID();
        const provenanceHash = utils_exports.solidityKeccak256(["bytes", "bytes", "uint256"], [utils_exports.toUtf8Bytes(baseUri), hashedPassword, chainId]);
        data = utils_exports.defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = events[0].args.startTokenId;
          const endingIndex = events[0].args.endTokenId;
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt
            });
          }
          return results;
        }
      });
    }));
    __publicField(this, "reveal", buildTransactionFunction(async (batchId, password) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const key = await this.hashDelayRevealPassword(batchId, password);
      try {
        const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
        if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
          throw new Error("invalid password");
        }
      } catch (e) {
        throw new Error("invalid password");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "reveal",
        args: [batchId, key]
      });
    }));
    this.featureName = featureName;
    this.nextTokenIdToMintFn = nextTokenIdToMintFn;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async getBatchesToReveal() {
    const count = await this.contractWrapper.read("getBaseURICount", []);
    if (count.isZero()) {
      return [];
    }
    const countRangeArray = Array.from(Array(count.toNumber()).keys());
    const uriIndices = await Promise.all(countRangeArray.map((i) => {
      if (hasFunction("getBatchIdAtIndex", this.contractWrapper)) {
        return this.contractWrapper.read("getBatchIdAtIndex", [i]);
      }
      if (hasFunction("baseURIIndices", this.contractWrapper)) {
        return this.contractWrapper.read("baseURIIndices", [i]);
      }
      throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.");
    }));
    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map((i) => this.getNftMetadata(i.toString())));
    const legacyContract = await this.isLegacyContract();
    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map((i) => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read("encryptedData", [i])));
    const encryptedBaseUris = encryptedUriData.map((data) => {
      if (utils_exports.hexDataLength(data) > 0) {
        if (legacyContract) {
          return data;
        }
        const result = utils_exports.defaultAbiCoder.decode(["bytes", "bytes32"], data);
        return result[0];
      } else {
        return data;
      }
    });
    return tokenMetadatas.map((meta, index) => ({
      batchId: BigNumber.from(index),
      batchUri: meta.uri,
      placeholderMetadata: meta
    })).filter((_, index) => utils_exports.hexDataLength(encryptedBaseUris[index]) > 0);
  }
  async hashDelayRevealPassword(batchTokenIndex, password) {
    const chainId = await this.contractWrapper.getChainID();
    const contractAddress = this.contractWrapper.address;
    return utils_exports.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchTokenIndex, contractAddress]);
  }
  async getNftMetadata(tokenId) {
    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);
  }
  async isLegacyContract() {
    if (hasFunction("contractVersion", this.contractWrapper)) {
      try {
        const version = await this.contractWrapper.read("contractVersion", []);
        return version <= 2;
      } catch (e) {
        return false;
      }
    }
    return false;
  }
  async getLegacyEncryptedData(index) {
    const DeprecatedAbi = (await import("./IDelayedRevealDeprecated-6RQBW2TS.js")).default;
    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());
    const result = await legacy.functions["encryptedBaseURI"](index);
    if (result.length > 0) {
      return result[0];
    } else {
      return "0x";
    }
  }
};
async function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {
  let overrides = {};
  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;
  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);
  const totalCost = normalizedPrice.mul(quantity);
  if (totalCost.gt(0)) {
    if (currency === NATIVE_TOKEN_ADDRESS) {
      overrides = {
        value: totalCost
      };
    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {
      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);
    }
  }
  return overrides;
}
var ContractOwner = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_OWNER.name);
    __publicField(this, "set", buildTransactionFunction(async (address) => {
      const resolvedAddress = await resolveAddress(address);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setOwner",
        args: [resolvedAddress]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
  async get() {
    return this.contractWrapper.read("owner", []);
  }
};

export {
  ContractRoyalty,
  DelayedReveal,
  calculateClaimCost,
  ContractOwner
};
//# sourceMappingURL=chunk-ULJVIQFI.js.map

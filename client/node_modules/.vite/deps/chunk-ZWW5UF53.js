import {
  DropClaimConditions
} from "./chunk-7Y72NYVJ.js";
import {
  DelayedReveal,
  calculateClaimCost
} from "./chunk-ULJVIQFI.js";
import {
  BaseSignaturePayloadInput,
  MintRequest721,
  MintRequest721withQuantity,
  Signature721WithQuantityInput,
  Signature721WithQuantityOutput
} from "./chunk-INCOK333.js";
import {
  assertEnabled
} from "./chunk-5TGBXTHW.js";
import {
  DEFAULT_QUERY_ALL_COUNT,
  FALLBACK_METADATA,
  fetchTokenMetadata,
  getBaseUriFromBatch,
  uploadOrExtractURI,
  uploadOrExtractURIs
} from "./chunk-POEPSFOQ.js";
import {
  BasicNFTInput,
  CommonNFTInput,
  normalizePriceValue,
  setErc20Allowance
} from "./chunk-SRYWWROE.js";
import {
  ContractEncoder,
  ContractMetadata,
  detectContractFeature,
  hasFunction
} from "./chunk-LXY7U6R5.js";
import {
  AddressOrEnsSchema,
  AmountSchema,
  BasisPointsSchema,
  BigNumberSchema,
  CustomContractSchema,
  ExtensionNotImplementedError,
  FEATURE_NFT,
  FEATURE_NFT_BATCH_MINTABLE,
  FEATURE_NFT_BURNABLE,
  FEATURE_NFT_CLAIM_CONDITIONS_V2,
  FEATURE_NFT_CLAIM_CUSTOM,
  FEATURE_NFT_CLAIM_ZORA,
  FEATURE_NFT_ENUMERABLE,
  FEATURE_NFT_LAZY_MINTABLE,
  FEATURE_NFT_LOYALTY_CARD,
  FEATURE_NFT_MINTABLE,
  FEATURE_NFT_QUERYABLE,
  FEATURE_NFT_REVEALABLE,
  FEATURE_NFT_SHARED_METADATA,
  FEATURE_NFT_SIGNATURE_MINTABLE_V2,
  FEATURE_NFT_SUPPLY,
  FEATURE_NFT_TIERED_DROP,
  FEATURE_NFT_UPDATABLE_METADATA,
  NotFoundError,
  Transaction,
  buildTransactionFunction,
  invariant,
  isFileOrBuffer,
  resolveAddress,
  z
} from "./chunk-CFECTRPO.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/erc-721-43dfcb0d.browser.esm.js
init_shim();
init_lib();
var Erc721Burnable = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_BURNABLE.name);
    __publicField(this, "token", buildTransactionFunction(async (tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [tokenId]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
};
var Erc721ClaimableWithConditions = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_CLAIM_CONDITIONS_V2.name);
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      const tx = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results = [];
        for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc721.get(id)
          });
        }
        return results;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
};
function toWei(amount) {
  return utils_exports.parseEther(AmountSchema.parse(amount));
}
var Erc721ClaimableZora = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_CLAIM_ZORA.name);
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      const signerAddress = await this.contractWrapper.getSigner()?.getAddress();
      if (destinationAddress !== signerAddress) {
        throw new Error("Zora Drop: Destination address must match connected wallet address");
      }
      if (options?.pricePerToken) {
        throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");
      }
      const saleDetails = await this.getSaleDetails();
      const price = saleDetails.publicSalePrice;
      const zoraFee = toWei("0.000777");
      const totalPrice = BigNumber.from(price).add(zoraFee).mul(quantity);
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "purchase",
        args: [quantity],
        overrides: {
          value: totalPrice
        }
      });
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("Sale", receipt?.logs);
        const startingIndex = event[0].args.firstPurchasedTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results = [];
        for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc721.get(id)
          });
        }
        return results;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async getSaleDetails() {
    return this.contractWrapper.read("saleDetails", []);
  }
};
var Erc721Claimable = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_CLAIM_CUSTOM.name);
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      const tx = await this.getClaimTransaction(destinationAddress, quantity, options);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = startingIndex.add(quantity);
        const results = [];
        for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc721.get(id)
          });
        }
        return results;
      });
      return tx;
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async getClaimTransaction(destinationAddress, quantity, options) {
    let overrides = {};
    if (options && options.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
    }
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: [destinationAddress, quantity],
      overrides
    });
  }
};
var Erc721LazyMintable = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_LAZY_MINTABLE.name);
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
      const baseUri = getBaseUriFromBatch(batch);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [batch.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, utils_exports.toUtf8Bytes("")],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = event[0].args.startTokenId;
          const endingIndex = event[0].args.endTokenId;
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt,
              data: () => this.erc721.getTokenMetadata(id)
            });
          }
          return results;
        }
      });
    }));
    __publicField(this, "updateMetadata", buildTransactionFunction(async (tokenId, metadata, options) => {
      const batchCount = await this.contractWrapper.read("getBaseURICount", []);
      if (batchCount.eq(0)) {
        throw new Error("No base URI set. Please set a base URI before updating metadata");
      }
      const targetTokenId = BigNumber.from(tokenId);
      let startTokenId = BigNumber.from(0);
      let endTokenId = BigNumber.from(0);
      let batchIndex = 0;
      for (let i = 0; i < batchCount.toNumber(); i++) {
        batchIndex = i;
        endTokenId = await this.contractWrapper.read("getBatchIdAtIndex", [batchIndex]);
        if (endTokenId.gt(targetTokenId)) {
          break;
        }
        startTokenId = endTokenId;
      }
      const range = Array.from({
        length: endTokenId.sub(startTokenId).toNumber()
      }, (v, k) => k + startTokenId.toNumber());
      const metadatas = await Promise.all(range.map((id) => this.erc721.getTokenMetadata(id)));
      const newMetadatas = [];
      for (let i = 0; i < metadatas.length; i++) {
        const {
          id,
          uri,
          ...rest
        } = metadatas[i];
        if (BigNumber.from(targetTokenId).eq(BigNumber.from(id))) {
          newMetadatas.push(metadata);
        } else {
          newMetadatas.push(rest);
        }
      }
      const batch = await uploadOrExtractURIs(newMetadatas, this.storage, startTokenId.toNumber(), options);
      const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "updateBatchBaseURI",
        args: [batchIndex, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`]
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc721Revealable();
  }
  detectErc721Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());
    }
    return void 0;
  }
};
var Erc721LoyaltyCard = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_LOYALTY_CARD.name);
    __publicField(this, "cancel", buildTransactionFunction(async (tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancel",
        args: [tokenId]
      });
    }));
    __publicField(this, "revoke", buildTransactionFunction(async (tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "revoke",
        args: [tokenId]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
};
var Erc721UpdatableMetadata = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_UPDATABLE_METADATA.name);
    __publicField(this, "update", buildTransactionFunction(async (tokenId, metadata) => {
      const uri = await uploadOrExtractURI(metadata, this.storage);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setTokenURI",
        args: [tokenId, uri]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
};
var Erc721BatchMintable = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_BATCH_MINTABLE.name);
    __publicField(this, "to", buildTransactionFunction(async (to, metadatas) => {
      const [uris, resolvedAddress] = await Promise.all([uploadOrExtractURIs(metadatas, this.storage), resolveAddress(to)]);
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = uris.map((uri) => contractEncoder.encode("mintTo", [resolvedAddress, uri]));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
          if (events.length === 0 || events.length < metadatas.length) {
            throw new Error("TokenMinted event not found, minting failed");
          }
          return events.map((e) => {
            const id = e.args.tokenIdMinted;
            return {
              id,
              receipt,
              data: () => this.erc721.get(id)
            };
          });
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
};
var Erc721Mintable = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_MINTABLE.name);
    __publicField(this, "to", buildTransactionFunction(async (to, metadata) => {
      const [uri, toAddress] = await Promise.all([uploadOrExtractURI(metadata, this.storage), resolveAddress(to)]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintTo",
        args: [toAddress, uri],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("Transfer", receipt?.logs);
          if (event.length === 0) {
            throw new Error("TransferEvent event not found");
          }
          const id = event[0].args.tokenId;
          return {
            id,
            receipt,
            data: () => this.erc721.get(id)
          };
        }
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc721BatchMintable();
  }
  async getMintTransaction(to, metadata) {
    return this.to.prepare(await resolveAddress(to), metadata);
  }
  detectErc721BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721BatchMintable")) {
      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);
    }
    return void 0;
  }
};
var Erc721SharedMetadata = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_SHARED_METADATA.name);
    __publicField(this, "set", buildTransactionFunction(async (metadata) => {
      const parsedMetadata = BasicNFTInput.parse(metadata);
      parsedMetadata.description = this.sanitizeJSONString(parsedMetadata.description);
      const batch = [];
      if (isFileOrBuffer(parsedMetadata.image)) {
        batch.push(this.storage.upload(parsedMetadata.image));
      } else if (typeof parsedMetadata.image === "string") {
        batch.push(Promise.resolve(parsedMetadata.image));
      } else {
        batch.push(Promise.resolve(void 0));
      }
      if (isFileOrBuffer(parsedMetadata.animation_url)) {
        batch.push(this.storage.upload(parsedMetadata.animation_url));
      } else if (typeof parsedMetadata.animation_url === "string") {
        batch.push(Promise.resolve(parsedMetadata.animation_url));
      } else {
        batch.push(Promise.resolve(void 0));
      }
      const [imageUri, animationUri] = await Promise.all(batch);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setSharedMetadata",
        args: [{
          name: `${parsedMetadata.name || ""}`,
          description: parsedMetadata.description || "",
          imageURI: imageUri || "",
          animationURI: animationUri || ""
        }]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async get() {
    const metadata = await this.contractWrapper.read("sharedMetadata", []);
    if (metadata.every((value) => value === "")) {
      return void 0;
    }
    return {
      name: metadata.name,
      description: metadata.description,
      image: metadata.imageURI,
      animation_url: metadata.animationURI
    };
  }
  sanitizeJSONString(val) {
    if (!val) {
      return val;
    }
    const sanitized = JSON.stringify(val);
    return sanitized.slice(1, sanitized.length - 1);
  }
};
var Erc721Enumerable = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_ENUMERABLE.name);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async all(walletAddress, queryParams) {
    let tokenIds = await this.tokenIds(walletAddress);
    if (queryParams) {
      const start = queryParams?.start || 0;
      const count = queryParams?.count || DEFAULT_QUERY_ALL_COUNT;
      tokenIds = tokenIds.slice(start, start + count);
    }
    return await Promise.all(tokenIds.map((tokenId) => this.erc721.get(tokenId.toString())));
  }
  async tokenIds(walletAddress) {
    const address = await resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress());
    const balance = await this.contractWrapper.read("balanceOf", [address]);
    const indices = Array.from(Array(balance.toNumber()).keys());
    return await Promise.all(indices.map((i) => this.contractWrapper.read("tokenOfOwnerByIndex", [address, i])));
  }
};
var Erc721AQueryable = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_QUERYABLE.name);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
  }
  async all(walletAddress, queryParams) {
    let tokenIds = await this.tokenIds(walletAddress);
    if (queryParams) {
      const start = queryParams?.start || 0;
      const count = queryParams?.count || DEFAULT_QUERY_ALL_COUNT;
      tokenIds = tokenIds.slice(start, start + count);
    }
    return await Promise.all(tokenIds.map((tokenId) => this.erc721.get(tokenId.toString())));
  }
  async tokenIds(walletAddress) {
    const address = await resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress());
    return await this.contractWrapper.read("tokensOfOwner", [address]);
  }
};
var Erc721Supply = class {
  constructor(erc721, contractWrapper) {
    __publicField(this, "featureName", FEATURE_NFT_SUPPLY.name);
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.owned = this.detectErc721Owned();
  }
  async all(queryParams) {
    let startTokenId = BigNumber.from(0);
    if (hasFunction("startTokenId", this.contractWrapper)) {
      startTokenId = await this.contractWrapper.read("startTokenId", []);
    }
    const start = BigNumber.from(queryParams?.start || 0).add(startTokenId).toNumber();
    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxSupply = await this.erc721.nextTokenIdToMint();
    const maxId = Math.min(maxSupply.add(startTokenId).toNumber(), start + count);
    return await Promise.all([...Array(maxId - start).keys()].map((i) => this.erc721.get((start + i).toString())));
  }
  async allOwners(queryParams) {
    let totalCount;
    let startTokenId = BigNumber.from(0);
    if (hasFunction("startTokenId", this.contractWrapper)) {
      startTokenId = await this.contractWrapper.read("startTokenId", []);
    }
    try {
      totalCount = await this.erc721.totalClaimedSupply();
    } catch (e) {
      totalCount = await this.totalCount();
    }
    totalCount = totalCount.add(startTokenId);
    let arr = [...new Array(totalCount.toNumber()).keys()];
    if (queryParams) {
      const start = queryParams?.start || 0;
      const count = queryParams?.count || DEFAULT_QUERY_ALL_COUNT;
      arr = arr.slice(start, start + count);
    }
    const owners = await Promise.all(arr.map((i) => this.erc721.ownerOf(i).catch(() => lib_exports.AddressZero)));
    return arr.map((i) => ({
      tokenId: i,
      owner: owners[i]
    })).filter((o) => o.owner !== lib_exports.AddressZero);
  }
  async totalCount() {
    return await this.erc721.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return await this.contractWrapper.read("totalSupply", []);
  }
  detectErc721Owned() {
    if (detectContractFeature(this.contractWrapper, "ERC721Enumerable")) {
      return new Erc721Enumerable(this.erc721, this.contractWrapper);
    } else if (detectContractFeature(this.contractWrapper, "ERC721AQueryable")) {
      return new Erc721AQueryable(this.erc721, this.contractWrapper);
    }
    return void 0;
  }
};
var TieredDropPayloadSchema = (() => BaseSignaturePayloadInput.extend({
  tierPriority: z.array(z.string()),
  royaltyRecipient: AddressOrEnsSchema.default(lib_exports.AddressZero),
  royaltyBps: BasisPointsSchema.default(0),
  quantity: BigNumberSchema.default(1)
}))();
var GenericRequest = [{
  name: "validityStartTimestamp",
  type: "uint128"
}, {
  name: "validityEndTimestamp",
  type: "uint128"
}, {
  name: "uid",
  type: "bytes32"
}, {
  name: "data",
  type: "bytes"
}];
var Erc721TieredDrop = class {
  constructor(erc721, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_TIERED_DROP.name);
    __publicField(this, "createBatchWithTier", buildTransactionFunction(async (metadatas, tier, options) => {
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
      const baseUri = getBaseUriFromBatch(batch);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [batch.length, baseUri.endsWith("/") ? baseUri : `${baseUri}/`, tier, utils_exports.toUtf8Bytes("")],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = event[0].args[1];
          const endingIndex = event[0].args[2];
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt,
              data: () => this.erc721.getTokenMetadata(id)
            });
          }
          return results;
        }
      });
    }));
    __publicField(this, "createDelayedRevealBatchWithTier", buildTransactionFunction(async (placeholder, metadatas, password, tier, options) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {
        rewriteFileNames: {
          fileStartNumber: 0
        }
      });
      const placeholderUri = getBaseUriFromBatch(placeholderUris);
      const startFileNumber = await this.erc721.nextTokenIdToMint();
      const uris = await this.storage.uploadBatch(metadatas.map((m) => CommonNFTInput.parse(m)), {
        onProgress: options?.onProgress,
        rewriteFileNames: {
          fileStartNumber: startFileNumber.toNumber()
        }
      });
      const baseUri = getBaseUriFromBatch(uris);
      const baseUriId = await this.contractWrapper.read("getBaseURICount", []);
      const chainId = await this.contractWrapper.getChainID();
      const hashedPassword = utils_exports.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, baseUriId, this.contractWrapper.address]);
      const encryptedBaseUri = await this.contractWrapper.read("encryptDecrypt", [utils_exports.toUtf8Bytes(baseUri), hashedPassword]);
      const provenanceHash = utils_exports.solidityKeccak256(["bytes", "bytes", "uint256"], [utils_exports.toUtf8Bytes(baseUri), hashedPassword, chainId]);
      const data = utils_exports.defaultAbiCoder.encode(["bytes", "bytes32"], [encryptedBaseUri, provenanceHash]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "lazyMint",
        args: [uris.length, placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`, tier, data],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
          const startingIndex = event[0].args[1];
          const endingIndex = event[0].args[2];
          const results = [];
          for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
            results.push({
              id,
              receipt,
              data: () => this.erc721.getTokenMetadata(id)
            });
          }
          return results;
        }
      });
    }));
    __publicField(this, "reveal", buildTransactionFunction(async (batchId, password) => {
      if (!password) {
        throw new Error("Password is required");
      }
      const chainId = await this.contractWrapper.getChainID();
      const key = utils_exports.solidityKeccak256(["string", "uint256", "uint256", "address"], [password, chainId, batchId, this.contractWrapper.address]);
      try {
        const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
        if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
          throw new Error("invalid password");
        }
      } catch (e) {
        throw new Error("invalid password");
      }
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "reveal",
        args: [batchId, key]
      });
    }));
    this.erc721 = erc721;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async getMetadataInTier(tier) {
    const tiers = await this.contractWrapper.read("getMetadataForAllTiers", []);
    const batches = tiers.find((t) => t.tier === tier);
    if (!batches) {
      throw new Error("Tier not found in contract.");
    }
    const nfts = await Promise.all(batches.ranges.map((range, i) => {
      const nftsInRange = [];
      const baseUri = batches.baseURIs[i];
      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {
        const uri = baseUri.endsWith("/") ? `${baseUri}${j}` : `${baseUri}/${j}`;
        const metadata = this.storage.downloadJSON(uri);
        nftsInRange.push(metadata);
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async getTokensInTier(tier) {
    const endIndex = await this.contractWrapper.read("getTokensInTierLen", []);
    if (endIndex.eq(0)) {
      return [];
    }
    const ranges = await this.contractWrapper.read("getTokensInTier", [tier, 0, endIndex]);
    const nfts = await Promise.all(ranges.map((range) => {
      const nftsInRange = [];
      for (let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++) {
        nftsInRange.push(this.erc721.get(i));
      }
      return nftsInRange;
    }).flat());
    return nfts;
  }
  async generate(payloadToSign) {
    const [payload] = await this.generateBatch([payloadToSign]);
    return payload;
  }
  async generateBatch(payloadsToSign) {
    const parsedPayloads = await Promise.all(payloadsToSign.map((payload) => TieredDropPayloadSchema.parseAsync(payload)));
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    return await Promise.all(parsedPayloads.map(async (payload) => {
      const signature = await this.contractWrapper.signTypedData(signer, {
        name: "SignatureAction",
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.address
      }, {
        GenericRequest
      }, await this.mapPayloadToContractStruct(payload));
      return {
        payload,
        signature: signature.toString()
      };
    }));
  }
  async verify(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const verification = await this.contractWrapper.read("verify", [message, signedPayload.signature]);
    return verification[0];
  }
  async claimWithSignature(signedPayload) {
    const message = await this.mapPayloadToContractStruct(signedPayload.payload);
    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);
    const overrides = await this.contractWrapper.getCallOverrides();
    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, signedPayload.payload.currencyAddress, overrides);
    const receipt = await this.contractWrapper.sendTransaction("claimWithSignature", [message, signedPayload.signature], overrides);
    const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
    const startingIndex = event[0].args.startTokenId;
    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);
    const results = [];
    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {
      results.push({
        id,
        receipt,
        data: () => this.erc721.get(id)
      });
    }
    return results;
  }
  async mapPayloadToContractStruct(payload) {
    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);
    const data = utils_exports.defaultAbiCoder.encode(["string[]", "address", "address", "uint256", "address", "uint256", "uint256", "address"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedTotalPrice, payload.currencyAddress]);
    return {
      uid: payload.uid,
      validityStartTimestamp: payload.mintStartTime,
      validityEndTimestamp: payload.mintEndTime,
      data
    };
  }
};
var Erc721WithQuantitySignatureMintable = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_NFT_SIGNATURE_MINTABLE_V2.name);
    __publicField(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature = signedPayload.signature;
      const overrides = await this.contractWrapper.getCallOverrides();
      const parse = (receipt) => {
        const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
        if (t.length === 0) {
          throw new Error("No MintWithSignature event found");
        }
        const id = t[0].args.tokenIdMinted;
        return {
          id,
          receipt
        };
      };
      if (await this.isLegacyNFTContract()) {
        const message = await this.mapLegacyPayloadToContractStruct(mintRequest);
        const price = message.price;
        await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintWithSignature",
          args: [message, signature],
          overrides,
          parse
        });
      } else {
        const message = await this.mapPayloadToContractStruct(mintRequest);
        const price = message.pricePerToken.mul(message.quantity);
        await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "mintWithSignature",
          args: [message, signature],
          overrides,
          parse
        });
      }
    }));
    __publicField(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const isLegacyNFTContract = await this.isLegacyNFTContract();
      const contractPayloads = (await Promise.all(signedPayloads.map((s) => isLegacyNFTContract ? this.mapLegacyPayloadToContractStruct(s.payload) : this.mapPayloadToContractStruct(s.payload)))).map((message, index) => {
        const s = signedPayloads[index];
        const signature = s.signature;
        const price = s.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature
        };
      });
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = contractPayloads.map((p) => {
        if (isLegacyNFTContract) {
          return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
        } else {
          return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
        }
      });
      if (hasFunction("multicall", this.contractWrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => {
            const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
            if (events.length === 0) {
              throw new Error("No MintWithSignature event found");
            }
            return events.map((log) => ({
              id: log.args.tokenIdMinted,
              receipt
            }));
          }
        });
      } else {
        throw new Error("Multicall not available on this contract!");
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
  async verify(signedPayload) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    let message;
    let verification;
    if (isLegacyNFTContract) {
      message = await this.mapLegacyPayloadToContractStruct(mintRequest);
      verification = await this.contractWrapper.read("verify", [message, signature]);
    } else {
      message = await this.mapPayloadToContractStruct(mintRequest);
      verification = await this.contractWrapper.read("verify", [message, signature]);
    }
    return verification[0];
  }
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  async generateBatch(payloadsToSign) {
    const isLegacyNFTContract = await this.isLegacyNFTContract();
    const parsedRequests = await Promise.all(payloadsToSign.map((m) => Signature721WithQuantityInput.parseAsync(m)));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const uris = await uploadOrExtractURIs(metadatas, this.storage);
    const chainId = await this.contractWrapper.getChainID();
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    return await Promise.all(parsedRequests.map(async (m, i) => {
      const uri = uris[i];
      const finalPayload = await Signature721WithQuantityOutput.parseAsync({
        ...m,
        uri
      });
      let signature;
      if (isLegacyNFTContract) {
        signature = await this.contractWrapper.signTypedData(signer, {
          name: "TokenERC721",
          version: "1",
          chainId,
          verifyingContract: this.contractWrapper.address
        }, {
          MintRequest: MintRequest721
        }, await this.mapLegacyPayloadToContractStruct(finalPayload));
      } else {
        signature = await this.contractWrapper.signTypedData(
          signer,
          {
            name: "SignatureMintERC721",
            version: "1",
            chainId,
            verifyingContract: await this.contractWrapper.address
          },
          {
            MintRequest: MintRequest721withQuantity
          },
          await this.mapPayloadToContractStruct(finalPayload)
        );
      }
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid
    };
  }
  async mapLegacyPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      price: normalizedPricePerToken,
      uri: mintRequest.uri,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
  async isLegacyNFTContract() {
    return detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1");
  }
};
var Erc721 = class {
  constructor(contractWrapper, storage, chainId) {
    __publicField(this, "featureName", FEATURE_NFT.name);
    __publicField(this, "transfer", buildTransactionFunction(async (to, tokenId) => {
      const [from, _to] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(to)]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom(address,address,uint256)",
        args: [from, _to, tokenId]
      });
    }));
    __publicField(this, "transferFrom", buildTransactionFunction(async (from, to, tokenId) => {
      const [fromAddress, toAddress] = await Promise.all([resolveAddress(from), resolveAddress(to)]);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom(address,address,uint256)",
        args: [fromAddress, toAddress, tokenId]
      });
    }));
    __publicField(this, "setApprovalForAll", buildTransactionFunction(async (operator, approved) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setApprovalForAll",
        args: [await resolveAddress(operator), approved]
      });
    }));
    __publicField(this, "setApprovalForToken", buildTransactionFunction(async (operator, tokenId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approve",
        args: [await resolveAddress(operator), tokenId]
      });
    }));
    __publicField(this, "mint", buildTransactionFunction(async (metadata) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadata);
    }));
    __publicField(this, "mintTo", buildTransactionFunction(async (receiver, metadata) => {
      return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to.prepare(receiver, metadata);
    }));
    __publicField(this, "mintBatch", buildTransactionFunction(async (metadatas) => {
      return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadatas);
    }));
    __publicField(this, "mintBatchTo", buildTransactionFunction(async (receiver, metadatas) => {
      return assertEnabled(this.mintable?.batch, FEATURE_NFT_BATCH_MINTABLE).to.prepare(receiver, metadatas);
    }));
    __publicField(this, "burn", buildTransactionFunction(async (tokenId) => {
      return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token.prepare(tokenId);
    }));
    __publicField(this, "cancel", buildTransactionFunction(async (tokenId) => {
      return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).cancel.prepare(tokenId);
    }));
    __publicField(this, "revoke", buildTransactionFunction(async (tokenId) => {
      return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).revoke.prepare(tokenId);
    }));
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint.prepare(metadatas, options);
    }));
    __publicField(this, "updateMetadata", buildTransactionFunction(async (tokenId, metadata) => {
      if (this.lazyMintable) {
        return this.lazyMintable.updateMetadata.prepare(tokenId, metadata);
      }
      return assertEnabled(this.updatableMetadata, FEATURE_NFT_UPDATABLE_METADATA).update.prepare(tokenId, metadata);
    }));
    __publicField(this, "claim", buildTransactionFunction(async (quantity, options) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), quantity, options);
    }));
    __publicField(this, "claimTo", buildTransactionFunction(async (destinationAddress, quantity, options) => {
      const claimWithConditions = this.claimWithConditions;
      const claim = this.claimCustom;
      const claimZora = this.claimZora;
      if (claimWithConditions) {
        return claimWithConditions.to.prepare(destinationAddress, quantity, options);
      }
      if (claim) {
        return claim.to.prepare(destinationAddress, quantity, options);
      }
      if (claimZora) {
        return claimZora.to.prepare(destinationAddress, quantity, options);
      }
      throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc721Enumerable();
    this.mintable = this.detectErc721Mintable();
    this.burnable = this.detectErc721Burnable();
    this.lazyMintable = this.detectErc721LazyMintable();
    this.tieredDropable = this.detectErc721TieredDrop();
    this.signatureMintable = this.detectErc721SignatureMintable();
    this.claimWithConditions = this.detectErc721ClaimableWithConditions();
    this.claimCustom = this.detectErc721Claimable();
    this.claimZora = this.detectErc721ClaimableZora();
    this.erc721SharedMetadata = this.detectErc721SharedMetadata();
    this.loyaltyCard = this.detectErc721LoyaltyCard();
    this.updatableMetadata = this.detectErc721UpdatableMetadata();
    this._chainId = chainId;
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async get(tokenId) {
    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => lib_exports.AddressZero), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner,
      metadata,
      type: "ERC721",
      supply: "1"
    };
  }
  async ownerOf(tokenId) {
    return await this.contractWrapper.read("ownerOf", [tokenId]);
  }
  async balanceOf(address) {
    return await this.contractWrapper.read("balanceOf", [await resolveAddress(address)]);
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async isApproved(address, operator) {
    const [_address, _operator] = await Promise.all([resolveAddress(address), resolveAddress(operator)]);
    return await this.contractWrapper.read("isApprovedForAll", [_address, _operator]);
  }
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);
  }
  async getAllOwners(queryParams) {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners(queryParams);
  }
  async totalCount() {
    return this.nextTokenIdToMint();
  }
  async totalCirculatingSupply() {
    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();
  }
  async getOwned(walletAddress, queryParams) {
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    if (this.query?.owned) {
      return this.query.owned.all(walletAddress, queryParams);
    } else {
      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners(queryParams)]);
      const ownedTokens = (allOwners || []).filter((i) => address?.toLowerCase() === i.owner?.toLowerCase());
      return await Promise.all(ownedTokens.map(async (i) => this.get(i.tokenId)));
    }
  }
  async getOwnedTokenIds(walletAddress) {
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    if (this.query?.owned) {
      return this.query.owned.tokenIds(walletAddress);
    } else {
      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);
      return (allOwners || []).filter((i) => address?.toLowerCase() === i.owner?.toLowerCase()).map((i) => BigNumber.from(i.tokenId));
    }
  }
  async getMintTransaction(receiver, metadata) {
    return this.mintTo.prepare(receiver, metadata);
  }
  async update(tokenId, metadata) {
    return this.updateMetadata(tokenId, metadata);
  }
  async getClaimTransaction(destinationAddress, quantity, options) {
    const claimWithConditions = this.claimWithConditions;
    const claim = this.claimCustom;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);
  }
  async totalClaimedSupply() {
    const contract = this.contractWrapper;
    if (hasFunction("totalMinted", contract)) {
      return this.contractWrapper.read("totalMinted", []);
    }
    if (hasFunction("nextTokenIdToClaim", contract)) {
      return this.contractWrapper.read("nextTokenIdToClaim", []);
    }
    throw new Error("No function found on contract to get total claimed supply");
  }
  async totalUnclaimedSupply() {
    const [nextTokenIdToMint, totalClaimedSupply] = await Promise.all([this.nextTokenIdToMint(), this.totalClaimedSupply()]);
    return nextTokenIdToMint.sub(totalClaimedSupply);
  }
  get claimConditions() {
    return assertEnabled(this.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;
  }
  get tieredDrop() {
    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);
  }
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);
  }
  get revealer() {
    return assertEnabled(this.lazyMintable?.revealer, FEATURE_NFT_REVEALABLE);
  }
  get sharedMetadata() {
    return assertEnabled(this.erc721SharedMetadata, FEATURE_NFT_SHARED_METADATA);
  }
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.read("tokenURI", [tokenId]);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      let nextTokenIdToMint = await this.contractWrapper.read("nextTokenIdToMint", []);
      if (hasFunction("startTokenId", this.contractWrapper)) {
        nextTokenIdToMint = nextTokenIdToMint.sub(await this.contractWrapper.read("startTokenId", []));
      }
      return nextTokenIdToMint;
    } else if (hasFunction("totalSupply", this.contractWrapper)) {
      return await this.contractWrapper.read("totalSupply", []);
    } else {
      throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
    }
  }
  detectErc721Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Supply") || hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return new Erc721Supply(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Mintable")) {
      return new Erc721Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC721Burnable")) {
      return new Erc721Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc721LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721LazyMintable")) {
      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721TieredDrop() {
    if (detectContractFeature(this.contractWrapper, "ERC721TieredDrop")) {
      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC721SignatureMintV1") || detectContractFeature(this.contractWrapper, "ERC721SignatureMintV2")) {
      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC721ClaimPhasesV2")) {
      return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimCustom")) {
      return new Erc721Claimable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721ClaimableZora() {
    if (detectContractFeature(this.contractWrapper, "ERC721ClaimZora")) {
      return new Erc721ClaimableZora(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc721SharedMetadata() {
    if (detectContractFeature(this.contractWrapper, "ERC721SharedMetadata")) {
      return new Erc721SharedMetadata(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc721LoyaltyCard() {
    if (detectContractFeature(this.contractWrapper, "ERC721LoyaltyCard")) {
      return new Erc721LoyaltyCard(this.contractWrapper);
    }
    return void 0;
  }
  detectErc721UpdatableMetadata() {
    if (detectContractFeature(this.contractWrapper, "ERC721UpdatableMetadata")) {
      return new Erc721UpdatableMetadata(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};

export {
  toWei,
  Erc721WithQuantitySignatureMintable,
  Erc721
};
//# sourceMappingURL=chunk-ZWW5UF53.js.map

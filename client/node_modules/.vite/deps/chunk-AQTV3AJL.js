import {
  DEFAULT_RPC_URL,
  getClientFetch,
  getThirdwebDomains,
  isThirdwebUrl
} from "./chunk-7C2JITWE.js";
import {
  stringify
} from "./chunk-XMVENQD3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/rpc.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/utils.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/promise/withCache.js
init_shim();
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey) {
  const buildCache = (cacheKey_, cache) => ({
    clear: () => cache.delete(cacheKey_),
    get: () => cache.get(cacheKey_),
    set: (data) => cache.set(cacheKey_, data)
  });
  const promise = buildCache(cacheKey, promiseCache);
  const response = buildCache(cacheKey, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime) {
      return response.data;
    }
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/chains/utils.js
var CUSTOM_CHAIN_MAP = /* @__PURE__ */ new Map();
function getCachedChain(id) {
  if (CUSTOM_CHAIN_MAP.has(id)) {
    return CUSTOM_CHAIN_MAP.get(id);
  }
  const chain = {
    id,
    rpc: `https://${id}.rpc.thirdweb.com`
  };
  return chain;
}
function getRpcUrlForChain(options) {
  const baseRpcUrl = getThirdwebDomains().rpc;
  if (typeof options.chain === "number") {
    return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;
  }
  const { rpc } = options.chain;
  if (isThirdwebUrl(rpc)) {
    const rpcUrl = new URL(options.chain.rpc.replace(DEFAULT_RPC_URL, baseRpcUrl));
    rpcUrl.pathname = `/${options.client.clientId}`;
    return rpcUrl.toString();
  }
  return rpc;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/fetch-rpc.js
init_shim();
async function fetchRpc(rpcUrl, client, options) {
  const response = await getClientFetch(client)(rpcUrl, {
    headers: {
      ...client.config?.rpc?.fetch?.headers,
      "Content-Type": "application/json"
    },
    body: stringify(options.requests),
    method: "POST",
    requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
    keepalive: client.config?.rpc?.fetch?.keepalive
  });
  if (!response.ok) {
    response.body?.cancel();
    throw new Error(`RPC request failed with status ${response.status} - ${response.statusText}`);
  }
  if (response.headers.get("Content-Type")?.startsWith("application/json")) {
    return await response.json();
  }
  const text = await response.text();
  try {
    return JSON.parse(text);
  } catch (err) {
    console.error("Error parsing response", err, text);
    throw err;
  }
}
async function fetchSingleRpc(rpcUrl, client, options) {
  const response = await getClientFetch(client)(rpcUrl, {
    headers: {
      ...client.config?.rpc?.fetch?.headers || {},
      "Content-Type": "application/json"
    },
    body: stringify(options.request),
    method: "POST",
    requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
    keepalive: client.config?.rpc?.fetch?.keepalive
  });
  if (!response.ok) {
    response.body?.cancel();
    throw new Error(`RPC request failed with status ${response.status}`);
  }
  if (response.headers.get("Content-Type")?.startsWith("application/json")) {
    return await response.json();
  }
  const text = await response.text();
  try {
    return JSON.parse(text);
  } catch (err) {
    console.error("Error parsing response", err, text);
    throw err;
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/rpc.js
var RPC_CLIENT_MAP = /* @__PURE__ */ new WeakMap();
function getRpcClientMap(client) {
  if (RPC_CLIENT_MAP.has(client)) {
    return RPC_CLIENT_MAP.get(client);
  }
  const rpcClientMap = /* @__PURE__ */ new Map();
  RPC_CLIENT_MAP.set(client, rpcClientMap);
  return rpcClientMap;
}
function rpcRequestKey(request) {
  return `${request.method}:${JSON.stringify(request.params)}`;
}
var DEFAULT_MAX_BATCH_SIZE = 100;
var DEFAULT_BATCH_TIMEOUT_MS = 0;
function getRpcClient(options) {
  const rpcClientMap = getRpcClientMap(options.client);
  const chainId = options.chain.id;
  if (rpcClientMap.has(options.chain.rpc)) {
    return rpcClientMap.get(options.chain.rpc);
  }
  const rpcClient = (() => {
    const rpcUrl = getRpcUrlForChain({
      client: options.client,
      chain: options.chain
    });
    const batchSize = options.config?.maxBatchSize ?? options.client.config?.rpc?.maxBatchSize ?? DEFAULT_MAX_BATCH_SIZE;
    const batchTimeoutMs = options.config?.batchTimeoutMs ?? options.client.config?.rpc?.batchTimeoutMs ?? DEFAULT_BATCH_TIMEOUT_MS;
    const inflightRequests = /* @__PURE__ */ new Map();
    let pendingBatch = [];
    let pendingBatchTimeout = null;
    function sendPendingBatch() {
      if (pendingBatchTimeout) {
        clearTimeout(pendingBatchTimeout);
        pendingBatchTimeout = null;
      }
      const requests = new Array(pendingBatch.length);
      const activeBatch = pendingBatch.slice().map((inflight, index) => {
        inflight.request.id = index;
        inflight.request.jsonrpc = "2.0";
        requests[index] = inflight.request;
        return inflight;
      });
      pendingBatch = [];
      fetchRpc(rpcUrl, options.client, {
        requests,
        requestTimeoutMs: options.config?.requestTimeoutMs
      }).then((responses) => {
        activeBatch.forEach((inflight, index) => {
          const response = responses[index];
          if (!response) {
            inflight.reject(new Error("No response"));
            return;
          }
          if (response instanceof Error) {
            inflight.reject(response);
            return;
          }
          if (typeof response === "string") {
            inflight.reject(new Error(response));
            return;
          }
          if ("error" in response) {
            inflight.reject(response.error);
          } else if (response.method === "eth_subscription") {
            throw new Error("Subscriptions not supported yet");
          } else {
            inflight.resolve(response.result);
          }
          inflightRequests.delete(inflight.requestKey);
        });
      }).catch((err) => {
        for (const inflight of activeBatch) {
          inflight.reject(err);
          inflightRequests.delete(inflight.requestKey);
        }
      });
    }
    if (batchSize === 1) {
      return async (request) => {
        request.id = 1;
        request.jsonrpc = "2.0";
        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {
          request,
          requestTimeoutMs: options.config?.requestTimeoutMs
        });
        if (!rpcResponse) {
          throw new Error("No response");
        }
        if ("error" in rpcResponse) {
          throw rpcResponse.error;
        }
        return rpcResponse.result;
      };
    }
    return async (request) => {
      const requestKey = rpcRequestKey(request);
      if (inflightRequests.has(requestKey)) {
        return inflightRequests.get(requestKey);
      }
      let resolve;
      let reject;
      const promise = new Promise((resolve_, reject_) => {
        resolve = resolve_;
        reject = reject_;
      });
      inflightRequests.set(requestKey, promise);
      pendingBatch.push({ request, resolve, reject, requestKey });
      if (batchSize > 1) {
        if (!pendingBatchTimeout) {
          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);
        }
        if (pendingBatch.length >= batchSize) {
          sendPendingBatch();
        }
      } else {
        sendPendingBatch();
      }
      return promise;
    };
  })();
  rpcClientMap.set(chainId, rpcClient);
  return rpcClient;
}

export {
  withCache,
  getCachedChain,
  getRpcClient
};
//# sourceMappingURL=chunk-AQTV3AJL.js.map

import {
  DropClaimConditions
} from "./chunk-7Y72NYVJ.js";
import {
  MintRequest20,
  Signature20PayloadInput,
  Signature20PayloadOutput
} from "./chunk-INCOK333.js";
import {
  assertEnabled
} from "./chunk-5TGBXTHW.js";
import {
  normalizePriceValue,
  setErc20Allowance
} from "./chunk-SRYWWROE.js";
import {
  ContractEncoder,
  ContractMetadata,
  detectContractFeature,
  fetchCurrencyMetadata,
  fetchCurrencyValue
} from "./chunk-LXY7U6R5.js";
import {
  AmountSchema,
  CustomContractSchema,
  FEATURE_TOKEN,
  FEATURE_TOKEN_BATCH_MINTABLE,
  FEATURE_TOKEN_BURNABLE,
  FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
  FEATURE_TOKEN_MINTABLE,
  FEATURE_TOKEN_SIGNATURE_MINTABLE,
  Transaction,
  buildTransactionFunction,
  invariant,
  resolveAddress
} from "./chunk-CFECTRPO.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/erc-20-2d8b7df7.browser.esm.js
init_shim();
init_lib();
async function normalizeAmount(contractWrapper, amount) {
  const decimals = await contractWrapper.read("decimals", []);
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
var Erc20Burnable = class {
  constructor(erc20, contractWrapper) {
    __publicField(this, "featureName", FEATURE_TOKEN_BURNABLE.name);
    __publicField(this, "tokens", buildTransactionFunction(async (amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [await this.erc20.normalizeAmount(amount)]
      });
    }));
    __publicField(this, "from", buildTransactionFunction(async (holder, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burnFrom",
        args: await Promise.all([resolveAddress(holder), this.erc20.normalizeAmount(amount)])
      });
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
};
var Erc20ClaimableWithConditions = class {
  constructor(erc20, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name);
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, amount, options) => {
      const quantity = await this.erc20.normalizeAmount(amount);
      return await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);
  }
};
var Erc20Droppable = class {
  constructor(erc20, contractWrapper, storage) {
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);
  }
};
var Erc20BatchMintable = class {
  constructor(erc20, contractWrapper) {
    __publicField(this, "featureName", FEATURE_TOKEN_BATCH_MINTABLE.name);
    __publicField(this, "to", buildTransactionFunction(async (args) => {
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const _items = await Promise.all(args.map((item) => Promise.all([resolveAddress(item.toAddress), this.erc20.normalizeAmount(item.amount)])));
      const encoded = _items.map((_ref) => {
        let [address, amount] = _ref;
        return contractEncoder.encode("mintTo", [address, amount]);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
  }
};
var Erc20Mintable = class {
  constructor(erc20, contractWrapper) {
    __publicField(this, "featureName", FEATURE_TOKEN_MINTABLE.name);
    __publicField(this, "to", buildTransactionFunction(async (to, amount) => {
      return await this.getMintTransaction(to, amount);
    }));
    this.erc20 = erc20;
    this.contractWrapper = contractWrapper;
    this.batch = this.detectErc20BatchMintable();
  }
  async getMintTransaction(to, amount) {
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: await Promise.all([resolveAddress(to), this.erc20.normalizeAmount(amount)])
    });
  }
  detectErc20BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20BatchMintable")) {
      return new Erc20BatchMintable(this.erc20, this.contractWrapper);
    }
    return void 0;
  }
};
var Erc20SignatureMintable = class {
  constructor(contractWrapper, roles) {
    __publicField(this, "featureName", FEATURE_TOKEN_SIGNATURE_MINTABLE.name);
    __publicField(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature = signedPayload.signature;
      const [message, overrides] = await Promise.all([this.mapPayloadToContractStruct(mintRequest), this.contractWrapper.getCallOverrides()]);
      await setErc20Allowance(this.contractWrapper, BigNumber.from(message.price), mintRequest.currencyAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintWithSignature",
        args: [message, signature],
        overrides
      });
    }));
    __publicField(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const messages = await Promise.all(signedPayloads.map((s) => this.mapPayloadToContractStruct(s.payload)));
      const contractPayloads = signedPayloads.map((s, index) => {
        const message = messages[index];
        const signature = s.signature;
        const price = s.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature
        };
      });
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = contractPayloads.map((p) => {
        return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    this.contractWrapper = contractWrapper;
    this.roles = roles;
  }
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.read("verify", [message, signature]);
    return verification[0];
  }
  async generate(mintRequest) {
    return (await this.generateBatch([mintRequest]))[0];
  }
  async generateBatch(payloadsToSign) {
    await this.roles?.verify(["minter"], await this.contractWrapper.getSignerAddress());
    const [chainId, name, parsedRequests] = await Promise.all([
      this.contractWrapper.getChainID(),
      this.contractWrapper.read("name", []),
      Promise.all(payloadsToSign.map((m) => Signature20PayloadInput.parseAsync(m)))
    ]);
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    const finalPayloads = await Promise.all(parsedRequests.map((m) => Signature20PayloadOutput.parseAsync(m)));
    const contractStructs = await Promise.all(finalPayloads.map((payload) => this.mapPayloadToContractStruct(payload)));
    const signatures = await Promise.all(contractStructs.map((struct) => this.contractWrapper.signTypedData(signer, {
      name,
      version: "1",
      chainId,
      verifyingContract: this.contractWrapper.address
    }, {
      MintRequest: MintRequest20
    }, struct)));
    return parsedRequests.map((m, index) => {
      const finalPayload = finalPayloads[index];
      const signature = signatures[index];
      return {
        payload: finalPayload,
        signature: signature.toString()
      };
    });
  }
  async mapPayloadToContractStruct(mintRequest) {
    const [normalizedPrice, decimals] = await Promise.all([normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress), this.contractWrapper.read("decimals", [])]);
    const amountWithDecimals = utils_exports.parseUnits(mintRequest.quantity, decimals);
    return {
      to: mintRequest.to,
      primarySaleRecipient: mintRequest.primarySaleRecipient,
      quantity: amountWithDecimals,
      price: normalizedPrice,
      currency: mintRequest.currencyAddress,
      validityEndTimestamp: mintRequest.mintEndTime,
      validityStartTimestamp: mintRequest.mintStartTime,
      uid: mintRequest.uid
    };
  }
};
var Erc20 = class {
  constructor(contractWrapper, storage, chainId) {
    __publicField(this, "featureName", FEATURE_TOKEN.name);
    __publicField(this, "transfer", buildTransactionFunction(async (to, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transfer",
        args: await Promise.all([resolveAddress(to), this.normalizeAmount(amount)])
      });
    }));
    __publicField(this, "transferFrom", buildTransactionFunction(async (from, to, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "transferFrom",
        args: await Promise.all([resolveAddress(from), resolveAddress(to), this.normalizeAmount(amount)])
      });
    }));
    __publicField(this, "setAllowance", buildTransactionFunction(async (spender, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approve",
        args: await Promise.all([resolveAddress(spender), this.normalizeAmount(amount)])
      });
    }));
    __publicField(this, "transferBatch", buildTransactionFunction(async (args) => {
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = (await Promise.all(args.map((arg) => Promise.all([this.normalizeAmount(arg.amount), resolveAddress(arg.toAddress)])))).map((_ref) => {
        let [amountWithDecimals, address] = _ref;
        return contractEncoder.encode("transfer", [address, amountWithDecimals]);
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "mint", buildTransactionFunction(async (amount) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), amount);
    }));
    __publicField(this, "mintTo", buildTransactionFunction(async (receiver, amount) => {
      return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).to.prepare(receiver, amount);
    }));
    __publicField(this, "mintBatchTo", buildTransactionFunction(async (args) => {
      return assertEnabled(this.mintable?.batch, FEATURE_TOKEN_BATCH_MINTABLE).to.prepare(args);
    }));
    __publicField(this, "burn", buildTransactionFunction(async (amount) => {
      return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).tokens.prepare(amount);
    }));
    __publicField(this, "burnFrom", buildTransactionFunction(async (holder, amount) => {
      return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).from.prepare(holder, amount);
    }));
    __publicField(this, "claim", buildTransactionFunction(async (amount, options) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), amount, options);
    }));
    __publicField(this, "claimTo", buildTransactionFunction(async (destinationAddress, amount, options) => {
      return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).to.prepare(destinationAddress, amount, options);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.mintable = this.detectErc20Mintable();
    this.burnable = this.detectErc20Burnable();
    this.droppable = this.detectErc20Droppable();
    this.signatureMintable = this.detectErc20SignatureMintable();
    this._chainId = chainId;
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async get() {
    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());
  }
  async balance() {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress());
  }
  async balanceOf(address) {
    return this.getValue(await this.contractWrapper.read("balanceOf", [await resolveAddress(address)]));
  }
  async totalSupply() {
    return await this.getValue(await this.contractWrapper.read("totalSupply", []));
  }
  async allowance(spender) {
    const [owner, spenderAddress] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(spender)]);
    return await this.allowanceOf(owner, spenderAddress);
  }
  async allowanceOf(owner, spender) {
    const args = await Promise.all([resolveAddress(owner), resolveAddress(spender)]);
    return await this.getValue(await this.contractWrapper.read("allowance", args));
  }
  async getMintTransaction(receiver, amount) {
    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).getMintTransaction(receiver, amount);
  }
  get claimConditions() {
    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).conditions;
  }
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_TOKEN_SIGNATURE_MINTABLE);
  }
  async normalizeAmount(amount) {
    return normalizeAmount(this.contractWrapper, amount);
  }
  async getValue(value) {
    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(value));
  }
  detectErc20Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return new Erc20Mintable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC20Burnable")) {
      return new Erc20Burnable(this, this.contractWrapper);
    }
    return void 0;
  }
  detectErc20Droppable() {
    if (detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC20ClaimPhasesV2")) {
      return new Erc20Droppable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc20SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC20SignatureMintable")) {
      return new Erc20SignatureMintable(this.contractWrapper);
    }
    return void 0;
  }
};

export {
  normalizeAmount,
  Erc20SignatureMintable,
  Erc20
};
//# sourceMappingURL=chunk-MRCQTN4N.js.map

import{I,x as h,J as y,k as p,K as m,U as g,Q as C,o as _,O as P,_ as E}from"./index.b8b39119.js";const N=new Set([1,137,10,42161,56]),v="eip155",w="wagmi.requestedChains",u="wallet_addEthereumChain",l="last-used-chain-id";class M extends I{constructor(e){super({...e,options:{isNewChainsStale:!0,...e.options}}),h(this,"id",y.walletConnect),h(this,"name","WalletConnect"),h(this,"ready",!0),h(this,"onAccountsChanged",s=>{s.length===0?this.emit("disconnect"):s[0]&&this.emit("change",{account:p(s[0])})}),h(this,"onChainChanged",async s=>{const t=Number(s),i=this.isChainUnsupported(t);await this._storage.setItem(l,String(s)),this.emit("change",{chain:{id:t,unsupported:i}})}),h(this,"onDisconnect",async()=>{await this._setRequestedChainsIds([]),await this._storage.removeItem(l),this.emit("disconnect")}),h(this,"onDisplayUri",s=>{this.emit("message",{type:"display_uri",data:s})}),h(this,"onConnect",()=>{this.emit("connect",{provider:this._provider})}),this._storage=e.options.storage,this._createProvider(),this.filteredChains=this.chains.length>50?this.chains.filter(s=>N.has(s.chainId)):this.chains,this.showWalletConnectModal=this.options.qrcode!==!1}async connect(){let{chainId:e,pairingTopic:s}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};try{let t=e;if(!t){const o=await this._storage.getItem(l),a=o?parseInt(o):void 0;a&&!this.isChainUnsupported(a)?t=a:t=this.filteredChains[0]?.chainId}if(!t)throw new Error("No chains found on connector.");const i=await this.getProvider();if(this.setupListeners(),i.session){await i.disconnect();const o=this.filteredChains.filter(a=>a.chainId!==t).map(a=>a.chainId);this.emit("message",{type:"connecting"}),await i.connect({pairingTopic:s,chains:[t],optionalChains:o.length>0?o:[t]}),await this._setRequestedChainsIds(this.filteredChains.map(a=>{let{chainId:f}=a;return f}))}const n=await i.enable();if(!n[0])throw new Error("No accounts found on provider.");const r=p(n[0]),c=await this.getChainId(),d=this.isChainUnsupported(c);return{account:r,chain:{id:c,unsupported:d},provider:new m(i)}}catch(t){throw/user rejected/i.test(t?.message)?new g(t):t}}async disconnect(){const e=()=>{if(!(typeof localStorage>"u"))for(const i in localStorage)i.startsWith("wc@2")&&localStorage.removeItem(i)};e();const s=await this.getProvider();(async()=>{try{await s.disconnect()}catch(i){if(!/No matching key/i.test(i.message))throw i}finally{this._removeListeners(),await this._setRequestedChainsIds([]),e()}})()}async getAccount(){const{accounts:e}=await this.getProvider();if(!e[0])throw new Error("No accounts found on provider.");return p(e[0])}async getChainId(){const{chainId:e}=await this.getProvider();return e}async getProvider(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(this._provider||await this._createProvider(),e&&await this.switchChain(e),!this._provider)throw new Error("No provider found.");return this._provider}async getSigner(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const[s,t]=await Promise.all([this.getProvider({chainId:e}),this.getAccount()]);return new m(s,e).getSigner(t)}async isAuthorized(){try{const[e,s]=await Promise.all([this.getAccount(),this.getProvider()]),t=await this._isChainsStale();if(!e)return!1;if(t&&s.session){try{await s.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(e){const s=this.chains.find(t=>t.chainId===e);if(!s)throw new C(`Chain with ID: ${e}, not found on connector.`);try{const t=await this.getProvider(),i=this._getNamespaceChainsIds(),n=this._getNamespaceMethods();if(!i.includes(e)&&n.includes(u)){const c=s.explorers&&s.explorers[0],d=c?{blockExplorerUrls:[c.url]}:{};await t.request({method:u,params:[{chainId:_(s.chainId),chainName:s.name,nativeCurrency:s.nativeCurrency,rpcUrls:P(s),...d}]});const o=await this._getRequestedChainsIds();o.push(e),await this._setRequestedChainsIds(o)}return await t.request({method:"wallet_switchEthereumChain",params:[{chainId:_(e)}]}),s}catch(t){const i=typeof t=="string"?t:t?.message;throw/user rejected request/i.test(i)?new g(t):new C(t)}}async _createProvider(){return this._initProviderPromise||(this._initProviderPromise=this.initProvider()),this._initProviderPromise}async initProvider(){const{default:e,OPTIONAL_EVENTS:s,OPTIONAL_METHODS:t}=await E(()=>import("./index.es.106518be.js"),["assets/index.es.106518be.js","assets/index.b8b39119.js","assets/index.274eef26.css"]),[i,...n]=this.filteredChains.map(r=>{let{chainId:c}=r;return c});i&&(this._provider=await e.init({showQrModal:this.showWalletConnectModal,projectId:this.options.projectId,optionalMethods:t,optionalEvents:s,chains:[i],optionalChains:n,metadata:{name:this.options.dappMetadata.name,description:this.options.dappMetadata.description||"",url:this.options.dappMetadata.url,icons:[this.options.dappMetadata.logoUrl||""]},rpcMap:Object.fromEntries(this.filteredChains.map(r=>[r.chainId,r.rpc[0]||""])),qrModalOptions:this.options.qrModalOptions}))}async _isChainsStale(){if(this._getNamespaceMethods().includes(u)||!this.options.isNewChainsStale)return!1;const s=await this._getRequestedChainsIds(),t=this.filteredChains.map(n=>{let{chainId:r}=n;return r}),i=this._getNamespaceChainsIds();return i.length&&!i.some(n=>t.includes(n))?!1:!t.every(n=>s.includes(n))}async setupListeners(){!this._provider||(this._removeListeners(),this._provider.on("accountsChanged",this.onAccountsChanged),this._provider.on("chainChanged",this.onChainChanged),this._provider.on("disconnect",this.onDisconnect),this._provider.on("session_delete",this.onDisconnect),this._provider.on("display_uri",this.onDisplayUri),this._provider.on("connect",this.onConnect))}_removeListeners(){!this._provider||(this._provider.removeListener("accountsChanged",this.onAccountsChanged),this._provider.removeListener("chainChanged",this.onChainChanged),this._provider.removeListener("disconnect",this.onDisconnect),this._provider.removeListener("session_delete",this.onDisconnect),this._provider.removeListener("display_uri",this.onDisplayUri),this._provider.removeListener("connect",this.onConnect))}async _setRequestedChainsIds(e){await this._storage.setItem(w,JSON.stringify(e))}async _getRequestedChainsIds(){const e=await this._storage.getItem(w);return e?JSON.parse(e):[]}_getNamespaceChainsIds(){return this._provider?this._provider.session?.namespaces[v]?.chains?.map(s=>parseInt(s.split(":")[1]||""))??[]:[]}_getNamespaceMethods(){return this._provider?this._provider.session?.namespaces[v]?.methods??[]:[]}}export{M as WalletConnectConnector};

import {
  ContractPublisher_default
} from "./chunk-IJEJ7ZKK.js";
import {
  AbiSchema,
  ContractWrapper,
  FullPublishMetadataSchemaInput,
  ProfileSchemaOutput,
  PublishedContractSchema,
  RPCConnectionHandler,
  Transaction,
  buildTransactionFunction,
  detectFeatures,
  extractConstructorParamsFromAbi,
  extractFunctionsFromAbi,
  fetchAndCacheDeployMetadata,
  fetchContractMetadata,
  fetchContractMetadataFromAddress,
  fetchExtendedReleaseMetadata,
  fetchPreDeployMetadata,
  fetchPublishedContractFromPolygon,
  fetchRawPredeployMetadata,
  fetchSourceFilesFromMetadata,
  getContractPublisherAddress,
  invariant,
  isFeatureEnabled,
  isIncrementalVersion,
  joinABIs,
  resolveAddress,
  resolveContractUriFromAddress
} from "./chunk-CFECTRPO.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/contract-publisher-325971b7.browser.esm.js
init_shim();
init_lib();
async function extractConstructorParams(predeployMetadataUri, storage) {
  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractConstructorParamsFromAbi(meta.abi);
}
async function extractFunctions(predeployMetadataUri, storage) {
  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);
  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);
}
var ContractPublisher = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    __publicField(this, "updatePublisherProfile", buildTransactionFunction(async (profileMetadata) => {
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const publisher = await signer.getAddress();
      const profileUri = await this.storage.upload(profileMetadata);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "setPublisherProfileUri",
        args: [publisher, profileUri]
      });
    }));
    __publicField(this, "publish", buildTransactionFunction(async (predeployUri, extraMetadata) => {
      const extraMetadataCleaned = this.cleanupOldPublishFlowData(extraMetadata);
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const publisher = await signer.getAddress();
      const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);
      const compilerMetadata = await fetchContractMetadata(predeployMetadata.metadataUri, this.storage);
      const features = detectFeatures(compilerMetadata.abi);
      const isPlugin = isFeatureEnabled(compilerMetadata.abi, "PluginRouter", features);
      const isDynamic = isFeatureEnabled(compilerMetadata.abi, "DynamicContract", features);
      extraMetadataCleaned.routerType = isPlugin ? "plugin" : isDynamic ? "dynamic" : "none";
      if (isDynamic || isPlugin) {
        const defaultExtensions = extraMetadataCleaned.defaultExtensions;
        if (defaultExtensions && defaultExtensions.length > 0) {
          try {
            const publishedExtensions = await Promise.all(defaultExtensions.map((e) => {
              return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, this.storage, this.options.clientId, this.options.secretKey);
            }));
            const publishedExtensionUris = publishedExtensions.map((ext) => ext.metadataUri);
            const extensionABIs = (await Promise.all(publishedExtensionUris.map(async (uri) => {
              return fetchAndCacheDeployMetadata(uri, this.storage);
            }))).map((fetchedMetadata) => fetchedMetadata.compilerMetadata.abi);
            const composite = joinABIs([compilerMetadata.abi, ...extensionABIs]);
            extraMetadataCleaned.compositeAbi = AbiSchema.parse(composite);
          } catch {
          }
        }
      }
      const latestContract = await this.getLatest(publisher, predeployMetadata.name);
      if (latestContract && latestContract.metadataUri) {
        const latestMetadata = await this.fetchPublishedContractInfo(latestContract);
        const latestVersion = latestMetadata.publishedMetadata.version;
        if (!isIncrementalVersion(latestVersion, extraMetadataCleaned.version)) {
          throw Error(`Version ${extraMetadataCleaned.version} is not greater than ${latestVersion}`);
        }
      }
      const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();
      const bytecode = fetchedBytecode.startsWith("0x") ? fetchedBytecode : `0x${fetchedBytecode}`;
      const bytecodeHash = utils_exports.solidityKeccak256(["bytes"], [bytecode]);
      const contractId = predeployMetadata.name;
      const fullMetadata = await FullPublishMetadataSchemaInput.parseAsync({
        ...extraMetadataCleaned,
        metadataUri: predeployMetadata.metadataUri,
        bytecodeUri: predeployMetadata.bytecodeUri,
        name: predeployMetadata.name,
        analytics: predeployMetadata.analytics,
        compilers: predeployMetadata.compilers,
        publisher
      });
      const fullMetadataUri = await this.storage.upload(fullMetadata);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "publishContract",
        args: [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, lib_exports.AddressZero],
        parse: (receipt) => {
          const events = this.publisher.parseLogs("ContractPublished", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ContractPublished event found");
          }
          const contract = events[0].args.publishedContract;
          return {
            receipt,
            data: async () => this.toPublishedContract(contract)
          };
        }
      });
    }));
    __publicField(this, "unpublish", buildTransactionFunction(async (publisher, contractId) => {
      const resolvedPublisher = await resolveAddress(publisher);
      return Transaction.fromContractWrapper({
        contractWrapper: this.publisher,
        method: "unpublishContract",
        args: [resolvedPublisher, contractId]
      });
    }));
    this.storage = storage;
    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), ContractPublisher_default, options, storage);
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.publisher.updateSignerOrProvider(network);
  }
  async extractConstructorParams(metadataUri) {
    return extractConstructorParams(metadataUri, this.storage);
  }
  async extractFunctions(predeployMetadataUri) {
    return extractFunctions(predeployMetadataUri, this.storage);
  }
  async fetchCompilerMetadataFromPredeployURI(predeployUri) {
    return fetchPreDeployMetadata(predeployUri, this.storage);
  }
  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {
    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);
    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : void 0;
    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : void 0;
    return {
      preDeployMetadata: preDeployMetadataFetched,
      latestPublishedContractMetadata
    };
  }
  async fetchCompilerMetadataFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    return fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage, this.options);
  }
  async fetchPublishedContractInfo(contract) {
    return {
      name: contract.id,
      publishedTimestamp: contract.timestamp,
      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)
    };
  }
  async fetchFullPublishMetadata(publishedMetadataUri) {
    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);
  }
  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {
    const publishedMetadataUri = await this.publisher.read("getPublishedUriFromCompilerUri", [compilerMetadataUri]);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);
    }
    return await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => this.fetchFullPublishMetadata(uri)));
  }
  async resolveContractUriFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    const contractUri = await resolveContractUriFromAddress(resolvedAddress, this.getProvider());
    invariant(contractUri, "Could not resolve contract URI from address");
    return contractUri;
  }
  async fetchContractSourcesFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    const metadata = await this.fetchCompilerMetadataFromAddress(resolvedAddress);
    return await fetchSourceFilesFromMetadata(metadata, this.storage);
  }
  async fetchContractAbiFromAddress(address) {
    const resolvedAddress = await resolveAddress(address);
    const meta = await fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage);
    return meta.abi;
  }
  async getPublisherProfile(publisherAddress) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const profileUri = await this.publisher.read("getPublisherProfileUri", [resolvedPublisherAddress]);
    if (!profileUri || profileUri.length === 0) {
      return {};
    }
    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));
  }
  async getAll(publisherAddress) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const data = await this.publisher.read("getAllPublishedContracts", [resolvedPublisherAddress]);
    const map = data.reduce((acc, curr) => {
      acc[curr.contractId] = curr;
      return acc;
    }, {});
    return Object.entries(map).map((_ref) => {
      let [, struct] = _ref;
      return this.toPublishedContract(struct);
    });
  }
  async getAllVersions(publisherAddress, contractId) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const contractStructs = await this.publisher.read("getPublishedContractVersions", [resolvedPublisherAddress, contractId]);
    if (contractStructs.length === 0) {
      throw Error("Not found");
    }
    return contractStructs.map((d) => this.toPublishedContract(d));
  }
  async getVersion(publisherAddress, contractId) {
    let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    if (version === "latest") {
      return this.getLatest(resolvedPublisherAddress, contractId);
    }
    const allVersions = await this.getAllVersions(resolvedPublisherAddress, contractId);
    const versionMetadata = await Promise.all(allVersions.map((contract) => this.fetchPublishedContractInfo(contract)));
    const versionMatch = versionMetadata.find((metadata) => metadata.publishedMetadata.version === version);
    invariant(versionMatch, "Contract version not found");
    return allVersions.find((contract) => contract.timestamp === versionMatch.publishedTimestamp);
  }
  async getLatest(publisherAddress, contractId) {
    const resolvedPublisherAddress = await resolveAddress(publisherAddress);
    const model = await this.publisher.read("getPublishedContract", [resolvedPublisherAddress, contractId]);
    if (model && model.publishMetadataUri) {
      return this.toPublishedContract(model);
    }
    return void 0;
  }
  toPublishedContract(contractModel) {
    return PublishedContractSchema.parse({
      id: contractModel.contractId,
      timestamp: contractModel.publishTimestamp,
      metadataUri: contractModel.publishMetadataUri
    });
  }
  cleanupOldPublishFlowData(extraMetadata) {
    if (extraMetadata.compositeAbi) {
      delete extraMetadata.compositeAbi;
    }
    return {
      ...extraMetadata,
      isDeployableViaFactory: false,
      isDeployableViaProxy: false,
      factoryDeploymentData: {
        ...extraMetadata.factoryDeploymentData,
        implementationAddresses: {},
        factoryAddresses: {}
      }
    };
  }
};
var contractPublisher = Object.freeze({
  __proto__: null,
  ContractPublisher
});

export {
  extractConstructorParams,
  extractFunctions,
  ContractPublisher,
  contractPublisher
};
//# sourceMappingURL=chunk-RT5IK3ZX.js.map

var it=Object.defineProperty;var ct=(h,t,r)=>t in h?it(h,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):h[t]=r;var c=(h,t,r)=>(ct(h,typeof t!="symbol"?t+"":t,r),r);import{br as ot,A as v,ak as w,a6 as d,a7 as g,bs as A,B as T,bt as Q,bu as J,bv as Y,bw as L,bx as H,by as G,ab as D,bz as U,bA as j,bB as K,bC as X,bD as q,bE as tt,aH as pt,aJ as dt,bF as lt,t as k,bG as z,al as F,e as Z,as as rt,an as R,a4 as at,bH as ht,aS as ut,bI as mt,bJ as gt,aI as V,aR as yt,b4 as Wt,a_ as ft}from"./index.b8b39119.js";import{a as f}from"./assertEnabled-993354c0.browser.esm.18458c2f.js";import{h as E,d as m,C as wt}from"./contract-appuri-c5be7b04.browser.esm.a5500bdc.js";import{F as Tt,a as Ct,u as M,g as N,b as et,D as P}from"./QueryParams-3376d6a8.browser.esm.b01ff5ba.js";import{D as Et}from"./drop-claim-conditions-8a3ca2fb.browser.esm.6ff0b9c1.js";import{c as bt,D as It}from"./contract-owner-bfdb8e71.browser.esm.5ea689bb.js";import{B as St,C as $,s as _}from"./setErc20Allowance-db4e8402.browser.esm.6b5789eb.js";import{j as Mt,k as At,m as kt,o as Nt,B as vt}from"./index.532955a9.js";class Rt{constructor(t){c(this,"featureName",Y.name);c(this,"token",d(async t=>g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]})));this.contractWrapper=t}}class Pt{constructor(t,r,a){c(this,"featureName",j.name);c(this,"to",d(async(t,r,a)=>{const e=await this.conditions.getClaimTransaction(t,r,a);return e.setParse(s=>{const i=this.contractWrapper.parseLogs("TokensClaimed",s?.logs)[0].args.startTokenId,p=i.add(r),l=[];for(let o=i;o.lt(p);o=o.add(1))l.push({id:o,receipt:s,data:()=>this.erc721.get(o)});return l}),e}));this.erc721=t,this.contractWrapper=r,this.storage=a;const e=new wt(this.contractWrapper,dt,this.storage);this.conditions=new Et(this.contractWrapper,e,this.storage)}}function Ft(h){return ht(ut.parse(h))}class Lt{constructor(t,r){c(this,"featureName",lt.name);c(this,"to",d(async(t,r,a)=>{const e=await this.contractWrapper.getSigner()?.getAddress();if(t!==e)throw new Error("Zora Drop: Destination address must match connected wallet address");if(a?.pricePerToken)throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");const n=(await this.getSaleDetails()).publicSalePrice,i=Ft("0.000777"),p=T.from(n).add(i).mul(r),l=g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"purchase",args:[r],overrides:{value:p}});return l.setParse(o=>{const y=this.contractWrapper.parseLogs("Sale",o?.logs)[0].args.firstPurchasedTokenId,b=y.add(r),W=[];for(let C=y;C.lt(b);C=C.add(1))W.push({id:C,receipt:o,data:()=>this.erc721.get(C)});return W}),l}));this.erc721=t,this.contractWrapper=r}async getSaleDetails(){return this.contractWrapper.read("saleDetails",[])}}class Ut{constructor(t,r){c(this,"featureName",U.name);c(this,"to",d(async(t,r,a)=>{const e=await this.getClaimTransaction(t,r,a);return e.setParse(s=>{const i=this.contractWrapper.parseLogs("TokensClaimed",s?.logs)[0].args.startTokenId,p=i.add(r),l=[];for(let o=i;o.lt(p);o=o.add(1))l.push({id:o,receipt:s,data:()=>this.erc721.get(o)});return l}),e}));this.erc721=t,this.contractWrapper=r}async getClaimTransaction(t,r,a){let e={};return a&&a.pricePerToken&&(e=await bt(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,r],overrides:e})}}class _t{constructor(t,r,a){c(this,"featureName",H.name);c(this,"lazyMint",d(async(t,r)=>{const a=await this.erc721.nextTokenIdToMint(),e=await M(t,this.storage,a.toNumber(),r),s=N(e);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,s.endsWith("/")?s:`${s}/`,k("")],parse:n=>{const i=this.contractWrapper.parseLogs("TokensLazyMinted",n?.logs),p=i[0].args.startTokenId,l=i[0].args.endTokenId,o=[];for(let u=p;u.lte(l);u=u.add(1))o.push({id:u,receipt:n,data:()=>this.erc721.getTokenMetadata(u)});return o}})}));c(this,"updateMetadata",d(async(t,r,a)=>{const e=await this.contractWrapper.read("getBaseURICount",[]);if(e.eq(0))throw new Error("No base URI set. Please set a base URI before updating metadata");const s=T.from(t);let n=T.from(0),i=T.from(0),p=0;for(let W=0;W<e.toNumber()&&(p=W,i=await this.contractWrapper.read("getBatchIdAtIndex",[p]),!i.gt(s));W++)n=i;const l=Array.from({length:i.sub(n).toNumber()},(W,C)=>C+n.toNumber()),o=await Promise.all(l.map(W=>this.erc721.getTokenMetadata(W))),u=[];for(let W=0;W<o.length;W++){const{id:C,uri:B,...I}=o[W];T.from(s).eq(T.from(C))?u.push(r):u.push(I)}const y=await M(u,this.storage,n.toNumber(),a),b=y[0].substring(0,y[0].lastIndexOf("/"));return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateBatchBaseURI",args:[p,`${b.endsWith("/")?b:`${b}/`}`]})}));this.erc721=t,this.contractWrapper=r,this.storage=a,this.revealer=this.detectErc721Revealable()}detectErc721Revealable(){if(m(this.contractWrapper,"ERC721Revealable"))return new It(this.contractWrapper,this.storage,q.name,()=>this.erc721.nextTokenIdToMint())}}class Bt{constructor(t){c(this,"featureName",L.name);c(this,"cancel",d(async t=>g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancel",args:[t]})));c(this,"revoke",d(async t=>g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"revoke",args:[t]})));this.contractWrapper=t}}class xt{constructor(t,r){c(this,"featureName",G.name);c(this,"update",d(async(t,r)=>{const a=await et(r,this.storage);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,a]})}));this.contractWrapper=t,this.storage=r}}class Ot{constructor(t,r,a){c(this,"featureName",J.name);c(this,"to",d(async(t,r)=>{const[a,e]=await Promise.all([M(r,this.storage),w(t)]),s=new at(this.contractWrapper),n=a.map(i=>s.encode("mintTo",[e,i]));return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:i=>{const p=this.contractWrapper.parseLogs("TokensMinted",i.logs);if(p.length===0||p.length<r.length)throw new Error("TokenMinted event not found, minting failed");return p.map(l=>{const o=l.args.tokenIdMinted;return{id:o,receipt:i,data:()=>this.erc721.get(o)}})}})}));this.erc721=t,this.contractWrapper=r,this.storage=a}}class Dt{constructor(t,r,a){c(this,"featureName",Q.name);c(this,"to",d(async(t,r)=>{const[a,e]=await Promise.all([et(r,this.storage),w(t)]);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[e,a],parse:s=>{const n=this.contractWrapper.parseLogs("Transfer",s?.logs);if(n.length===0)throw new Error("TransferEvent event not found");const i=n[0].args.tokenId;return{id:i,receipt:s,data:()=>this.erc721.get(i)}}})}));this.erc721=t,this.contractWrapper=r,this.storage=a,this.batch=this.detectErc721BatchMintable()}async getMintTransaction(t,r){return this.to.prepare(await w(t),r)}detectErc721BatchMintable(){if(m(this.contractWrapper,"ERC721BatchMintable"))return new Ot(this.erc721,this.contractWrapper,this.storage)}}class zt{constructor(t,r){c(this,"featureName",tt.name);c(this,"set",d(async t=>{const r=St.parse(t);r.description=this.sanitizeJSONString(r.description);const a=[];z(r.image)?a.push(this.storage.upload(r.image)):typeof r.image=="string"?a.push(Promise.resolve(r.image)):a.push(Promise.resolve(void 0)),z(r.animation_url)?a.push(this.storage.upload(r.animation_url)):typeof r.animation_url=="string"?a.push(Promise.resolve(r.animation_url)):a.push(Promise.resolve(void 0));const[e,s]=await Promise.all(a);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setSharedMetadata",args:[{name:`${r.name||""}`,description:r.description||"",imageURI:e||"",animationURI:s||""}]})}));this.contractWrapper=t,this.storage=r}async get(){const t=await this.contractWrapper.read("sharedMetadata",[]);if(!t.every(r=>r===""))return{name:t.name,description:t.description,image:t.imageURI,animation_url:t.animationURI}}sanitizeJSONString(t){if(!t)return t;const r=JSON.stringify(t);return r.slice(1,r.length-1)}}class Zt{constructor(t,r){c(this,"featureName",mt.name);this.erc721=t,this.contractWrapper=r}async all(t,r){let a=await this.tokenIds(t);if(r){const e=r?.start||0,s=r?.count||P;a=a.slice(e,e+s)}return await Promise.all(a.map(e=>this.erc721.get(e.toString())))}async tokenIds(t){const r=await w(t||await this.contractWrapper.getSignerAddress()),a=await this.contractWrapper.read("balanceOf",[r]),e=Array.from(Array(a.toNumber()).keys());return await Promise.all(e.map(s=>this.contractWrapper.read("tokenOfOwnerByIndex",[r,s])))}}class Vt{constructor(t,r){c(this,"featureName",gt.name);this.erc721=t,this.contractWrapper=r}async all(t,r){let a=await this.tokenIds(t);if(r){const e=r?.start||0,s=r?.count||P;a=a.slice(e,e+s)}return await Promise.all(a.map(e=>this.erc721.get(e.toString())))}async tokenIds(t){const r=await w(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("tokensOfOwner",[r])}}class $t{constructor(t,r){c(this,"featureName",A.name);this.erc721=t,this.contractWrapper=r,this.owned=this.detectErc721Owned()}async all(t){let r=T.from(0);E("startTokenId",this.contractWrapper)&&(r=await this.contractWrapper.read("startTokenId",[]));const a=T.from(t?.start||0).add(r).toNumber(),e=T.from(t?.count||P).toNumber(),s=await this.erc721.nextTokenIdToMint(),n=Math.min(s.add(r).toNumber(),a+e);return await Promise.all([...Array(n-a).keys()].map(i=>this.erc721.get((a+i).toString())))}async allOwners(t){let r,a=T.from(0);E("startTokenId",this.contractWrapper)&&(a=await this.contractWrapper.read("startTokenId",[]));try{r=await this.erc721.totalClaimedSupply()}catch{r=await this.totalCount()}r=r.add(a);let e=[...new Array(r.toNumber()).keys()];if(t){const n=t?.start||0,i=t?.count||P;e=e.slice(n,n+i)}const s=await Promise.all(e.map(n=>this.erc721.ownerOf(n).catch(()=>v)));return e.map(n=>({tokenId:n,owner:s[n]})).filter(n=>n.owner!==v)}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.read("totalSupply",[])}detectErc721Owned(){if(m(this.contractWrapper,"ERC721Enumerable"))return new Zt(this.erc721,this.contractWrapper);if(m(this.contractWrapper,"ERC721AQueryable"))return new Vt(this.erc721,this.contractWrapper)}}const Qt=(()=>vt.extend({tierPriority:V.array(V.string()),royaltyRecipient:yt.default(v),royaltyBps:Wt.default(0),quantity:ft.default(1)}))(),Jt=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}];class Yt{constructor(t,r,a){c(this,"featureName",K.name);c(this,"createBatchWithTier",d(async(t,r,a)=>{const e=await this.erc721.nextTokenIdToMint(),s=await M(t,this.storage,e.toNumber(),a),n=N(s);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[s.length,n.endsWith("/")?n:`${n}/`,r,k("")],parse:i=>{const p=this.contractWrapper.parseLogs("TokensLazyMinted",i?.logs),l=p[0].args[1],o=p[0].args[2],u=[];for(let y=l;y.lte(o);y=y.add(1))u.push({id:y,receipt:i,data:()=>this.erc721.getTokenMetadata(y)});return u}})}));c(this,"createDelayedRevealBatchWithTier",d(async(t,r,a,e,s)=>{if(!a)throw new Error("Password is required");const n=await this.storage.uploadBatch([$.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),i=N(n),p=await this.erc721.nextTokenIdToMint(),l=await this.storage.uploadBatch(r.map(I=>$.parse(I)),{onProgress:s?.onProgress,rewriteFileNames:{fileStartNumber:p.toNumber()}}),o=N(l),u=await this.contractWrapper.read("getBaseURICount",[]),y=await this.contractWrapper.getChainID(),b=F(["string","uint256","uint256","address"],[a,y,u,this.contractWrapper.address]),W=await this.contractWrapper.read("encryptDecrypt",[k(o),b]),C=F(["bytes","bytes","uint256"],[k(o),b,y]),B=Z.encode(["bytes","bytes32"],[W,C]);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[l.length,i.endsWith("/")?i:`${i}/`,e,B],parse:I=>{const x=this.contractWrapper.parseLogs("TokensLazyMinted",I?.logs),nt=x[0].args[1],st=x[0].args[2],O=[];for(let S=nt;S.lte(st);S=S.add(1))O.push({id:S,receipt:I,data:()=>this.erc721.getTokenMetadata(S)});return O}})}));c(this,"reveal",d(async(t,r)=>{if(!r)throw new Error("Password is required");const a=await this.contractWrapper.getChainID(),e=F(["string","uint256","uint256","address"],[r,a,t,this.contractWrapper.address]);try{const s=await this.contractWrapper.callStatic().reveal(t,e);if(!s.includes("://")||!s.endsWith("/"))throw new Error("invalid password")}catch{throw new Error("invalid password")}return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})}));this.erc721=t,this.contractWrapper=r,this.storage=a}async getMetadataInTier(t){const a=(await this.contractWrapper.read("getMetadataForAllTiers",[])).find(s=>s.tier===t);if(!a)throw new Error("Tier not found in contract.");return await Promise.all(a.ranges.map((s,n)=>{const i=[],p=a.baseURIs[n];for(let l=s.startIdInclusive.toNumber();l<s.endIdNonInclusive.toNumber();l++){const o=p.endsWith("/")?`${p}${l}`:`${p}/${l}`,u=this.storage.downloadJSON(o);i.push(u)}return i}).flat())}async getTokensInTier(t){const r=await this.contractWrapper.read("getTokensInTierLen",[]);if(r.eq(0))return[];const a=await this.contractWrapper.read("getTokensInTier",[t,0,r]);return await Promise.all(a.map(s=>{const n=[];for(let i=s.startIdInclusive.toNumber();i<s.endIdNonInclusive.toNumber();i++)n.push(this.erc721.get(i));return n}).flat())}async generate(t){const[r]=await this.generateBatch([t]);return r}async generateBatch(t){const r=await Promise.all(t.map(s=>Qt.parseAsync(s))),a=await this.contractWrapper.getChainID(),e=this.contractWrapper.getSigner();return rt(e,"No signer available"),await Promise.all(r.map(async s=>{const n=await this.contractWrapper.signTypedData(e,{name:"SignatureAction",version:"1",chainId:a,verifyingContract:this.contractWrapper.address},{GenericRequest:Jt},await this.mapPayloadToContractStruct(s));return{payload:s,signature:n.toString()}}))}async verify(t){const r=await this.mapPayloadToContractStruct(t.payload);return(await this.contractWrapper.read("verify",[r,t.signature]))[0]}async claimWithSignature(t){const r=await this.mapPayloadToContractStruct(t.payload),a=await R(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),e=await this.contractWrapper.getCallOverrides();await _(this.contractWrapper,a,t.payload.currencyAddress,e);const s=await this.contractWrapper.sendTransaction("claimWithSignature",[r,t.signature],e),n=this.contractWrapper.parseLogs("TokensClaimed",s?.logs),i=n[0].args.startTokenId,p=i.add(n[0].args.quantityClaimed),l=[];for(let o=i;o.lt(p);o=o.add(1))l.push({id:o,receipt:s,data:()=>this.erc721.get(o)});return l}async mapPayloadToContractStruct(t){const r=await R(this.contractWrapper.getProvider(),t.price,t.currencyAddress),a=Z.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,r,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:a}}}class Ht{constructor(t,r){c(this,"featureName",X.name);c(this,"mint",d(async t=>{const r=t.payload,a=t.signature,e=await this.contractWrapper.getCallOverrides(),s=n=>{const i=this.contractWrapper.parseLogs("TokensMintedWithSignature",n.logs);if(i.length===0)throw new Error("No MintWithSignature event found");return{id:i[0].args.tokenIdMinted,receipt:n}};if(await this.isLegacyNFTContract()){const n=await this.mapLegacyPayloadToContractStruct(r),i=n.price;return await _(this.contractWrapper,i,r.currencyAddress,e),g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[n,a],overrides:e,parse:s})}else{const n=await this.mapPayloadToContractStruct(r),i=n.pricePerToken.mul(n.quantity);return await _(this.contractWrapper,i,r.currencyAddress,e),g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[n,a],overrides:e,parse:s})}}));c(this,"mintBatch",d(async t=>{const r=await this.isLegacyNFTContract(),a=(await Promise.all(t.map(n=>r?this.mapLegacyPayloadToContractStruct(n.payload):this.mapPayloadToContractStruct(n.payload)))).map((n,i)=>{const p=t[i],l=p.signature,o=p.payload.price;if(T.from(o).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:n,signature:l}}),e=new at(this.contractWrapper),s=a.map(n=>r?e.encode("mintWithSignature",[n.message,n.signature]):e.encode("mintWithSignature",[n.message,n.signature]));if(E("multicall",this.contractWrapper))return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:n=>{const i=this.contractWrapper.parseLogs("TokensMintedWithSignature",n.logs);if(i.length===0)throw new Error("No MintWithSignature event found");return i.map(p=>({id:p.args.tokenIdMinted,receipt:n}))}});throw new Error("Multicall not available on this contract!")}));this.contractWrapper=t,this.storage=r}async verify(t){const r=await this.isLegacyNFTContract(),a=t.payload,e=t.signature;let s,n;return r?(s=await this.mapLegacyPayloadToContractStruct(a),n=await this.contractWrapper.read("verify",[s,e])):(s=await this.mapPayloadToContractStruct(a),n=await this.contractWrapper.read("verify",[s,e])),n[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){const r=await this.isLegacyNFTContract(),a=await Promise.all(t.map(p=>Mt.parseAsync(p))),e=a.map(p=>p.metadata),s=await M(e,this.storage),n=await this.contractWrapper.getChainID(),i=this.contractWrapper.getSigner();return rt(i,"No signer available"),await Promise.all(a.map(async(p,l)=>{const o=s[l],u=await At.parseAsync({...p,uri:o});let y;return r?y=await this.contractWrapper.signTypedData(i,{name:"TokenERC721",version:"1",chainId:n,verifyingContract:this.contractWrapper.address},{MintRequest:kt},await this.mapLegacyPayloadToContractStruct(u)):y=await this.contractWrapper.signTypedData(i,{name:"SignatureMintERC721",version:"1",chainId:n,verifyingContract:await this.contractWrapper.address},{MintRequest:Nt},await this.mapPayloadToContractStruct(u)),{payload:u,signature:y.toString()}}))}async mapPayloadToContractStruct(t){const r=await R(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:r,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){const r=await R(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:r,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return m(this.contractWrapper,"ERC721SignatureMintV1")}}class nr{constructor(t,r,a){c(this,"featureName",ot.name);c(this,"transfer",d(async(t,r)=>{const[a,e]=await Promise.all([this.contractWrapper.getSignerAddress(),w(t)]);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[a,e,r]})}));c(this,"transferFrom",d(async(t,r,a)=>{const[e,s]=await Promise.all([w(t),w(r)]);return g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[e,s,a]})}));c(this,"setApprovalForAll",d(async(t,r)=>g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await w(t),r]})));c(this,"setApprovalForToken",d(async(t,r)=>g.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await w(t),r]})));c(this,"mint",d(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));c(this,"mintTo",d(async(t,r)=>f(this.mintable,Q).to.prepare(t,r)));c(this,"mintBatch",d(async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));c(this,"mintBatchTo",d(async(t,r)=>f(this.mintable?.batch,J).to.prepare(t,r)));c(this,"burn",d(async t=>f(this.burnable,Y).token.prepare(t)));c(this,"cancel",d(async t=>f(this.loyaltyCard,L).cancel.prepare(t)));c(this,"revoke",d(async t=>f(this.loyaltyCard,L).revoke.prepare(t)));c(this,"lazyMint",d(async(t,r)=>f(this.lazyMintable,H).lazyMint.prepare(t,r)));c(this,"updateMetadata",d(async(t,r)=>this.lazyMintable?this.lazyMintable.updateMetadata.prepare(t,r):f(this.updatableMetadata,G).update.prepare(t,r)));c(this,"claim",d(async(t,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r)));c(this,"claimTo",d(async(t,r,a)=>{const e=this.claimWithConditions,s=this.claimCustom,n=this.claimZora;if(e)return e.to.prepare(t,r,a);if(s)return s.to.prepare(t,r,a);if(n)return n.to.prepare(t,r,a);throw new D(U)}));this.contractWrapper=t,this.storage=r,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this.claimZora=this.detectErc721ClaimableZora(),this.erc721SharedMetadata=this.detectErc721SharedMetadata(),this.loyaltyCard=this.detectErc721LoyaltyCard(),this.updatableMetadata=this.detectErc721UpdatableMetadata(),this._chainId=a}get chainId(){return this._chainId}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[r,a]=await Promise.all([this.ownerOf(t).catch(()=>v),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...Tt}))]);return{owner:r,metadata:a,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.read("ownerOf",[t])}async balanceOf(t){return await this.contractWrapper.read("balanceOf",[await w(t)])}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,r){const[a,e]=await Promise.all([w(t),w(r)]);return await this.contractWrapper.read("isApprovedForAll",[a,e])}async getAll(t){return f(this.query,A).all(t)}async getAllOwners(t){return f(this.query,A).allOwners(t)}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return f(this.query,A).totalCirculatingSupply()}async getOwned(t,r){if(t&&(t=await w(t)),this.query?.owned)return this.query.owned.all(t,r);{const[a,e]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners(r)]),s=(e||[]).filter(n=>a?.toLowerCase()===n.owner?.toLowerCase());return await Promise.all(s.map(async n=>this.get(n.tokenId)))}}async getOwnedTokenIds(t){if(t&&(t=await w(t)),this.query?.owned)return this.query.owned.tokenIds(t);{const[r,a]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);return(a||[]).filter(e=>r?.toLowerCase()===e.owner?.toLowerCase()).map(e=>T.from(e.tokenId))}}async getMintTransaction(t,r){return this.mintTo.prepare(t,r)}async update(t,r){return this.updateMetadata(t,r)}async getClaimTransaction(t,r,a){const e=this.claimWithConditions,s=this.claimCustom;if(e)return e.conditions.getClaimTransaction(t,r,a);if(s)return s.getClaimTransaction(t,r,a);throw new D(U)}async totalClaimedSupply(){const t=this.contractWrapper;if(E("totalMinted",t))return this.contractWrapper.read("totalMinted",[]);if(E("nextTokenIdToClaim",t))return this.contractWrapper.read("nextTokenIdToClaim",[]);throw new Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){const[t,r]=await Promise.all([this.nextTokenIdToMint(),this.totalClaimedSupply()]);return t.sub(r)}get claimConditions(){return f(this.claimWithConditions,j).conditions}get tieredDrop(){return f(this.tieredDropable,K)}get signature(){return f(this.signatureMintable,X)}get revealer(){return f(this.lazyMintable?.revealer,q)}get sharedMetadata(){return f(this.erc721SharedMetadata,tt)}async getTokenMetadata(t){const r=await this.contractWrapper.read("tokenURI",[t]);if(!r)throw new pt;return Ct(t,r,this.storage)}async nextTokenIdToMint(){if(E("nextTokenIdToMint",this.contractWrapper)){let t=await this.contractWrapper.read("nextTokenIdToMint",[]);return E("startTokenId",this.contractWrapper)&&(t=t.sub(await this.contractWrapper.read("startTokenId",[]))),t}else{if(E("totalSupply",this.contractWrapper))return await this.contractWrapper.read("totalSupply",[]);throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}}detectErc721Enumerable(){if(m(this.contractWrapper,"ERC721Supply")||E("nextTokenIdToMint",this.contractWrapper))return new $t(this,this.contractWrapper)}detectErc721Mintable(){if(m(this.contractWrapper,"ERC721Mintable"))return new Dt(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if(m(this.contractWrapper,"ERC721Burnable"))return new Rt(this.contractWrapper)}detectErc721LazyMintable(){if(m(this.contractWrapper,"ERC721LazyMintable"))return new _t(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if(m(this.contractWrapper,"ERC721TieredDrop"))return new Yt(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if(m(this.contractWrapper,"ERC721SignatureMintV1")||m(this.contractWrapper,"ERC721SignatureMintV2"))return new Ht(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if(m(this.contractWrapper,"ERC721ClaimConditionsV1")||m(this.contractWrapper,"ERC721ClaimConditionsV2")||m(this.contractWrapper,"ERC721ClaimPhasesV1")||m(this.contractWrapper,"ERC721ClaimPhasesV2"))return new Pt(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if(m(this.contractWrapper,"ERC721ClaimCustom"))return new Ut(this,this.contractWrapper)}detectErc721ClaimableZora(){if(m(this.contractWrapper,"ERC721ClaimZora"))return new Lt(this,this.contractWrapper)}detectErc721SharedMetadata(){if(m(this.contractWrapper,"ERC721SharedMetadata"))return new zt(this.contractWrapper,this.storage)}detectErc721LoyaltyCard(){if(m(this.contractWrapper,"ERC721LoyaltyCard"))return new Bt(this.contractWrapper)}detectErc721UpdatableMetadata(){if(m(this.contractWrapper,"ERC721UpdatableMetadata"))return new xt(this.contractWrapper,this.storage)}}export{nr as E,Ht as a};

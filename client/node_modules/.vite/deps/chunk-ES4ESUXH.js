import {
  getContract
} from "./chunk-ZNDGUQSQ.js";
import {
  encodeAbiParameters,
  isAbiFunction,
  prepareMethod,
  stringToBytes
} from "./chunk-WG3IFTZB.js";
import {
  getCachedChain
} from "./chunk-AQTV3AJL.js";
import {
  LruMap,
  getClientFetch,
  getThirdwebDomains
} from "./chunk-7C2JITWE.js";
import {
  parseAbiItem
} from "./chunk-HMZMTDNX.js";
import {
  hexToUint8Array,
  isHex,
  uint8ArrayToHex
} from "./chunk-DOKT7LHU.js";
import {
  ContractPublisher
} from "./chunk-RT5IK3ZX.js";
import {
  createTransactionBatches,
  deployContractDeterministic,
  deployWithThrowawayDeployer,
  getDeploymentInfo
} from "./chunk-TWGI2UAL.js";
import {
  TWMultichainRegistryLogic_default
} from "./chunk-YZUC2CAF.js";
import {
  require_fast_deep_equal
} from "./chunk-INCOK333.js";
import {
  CommonNFTInput,
  CommonNFTOutput,
  NFTInputOrUriSchema,
  normalizePriceValue
} from "./chunk-SRYWWROE.js";
import {
  ContractEncoder,
  fetchCurrencyValue,
  isNativeToken
} from "./chunk-LXY7U6R5.js";
import {
  AbiSchema,
  AddressOrEnsSchema,
  AddressZero,
  AmountSchema,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  CONTRACT_ADDRESSES,
  ChainId,
  CommonContractSchema,
  CommonPlatformFeeSchema,
  CommonPrimarySaleSchema,
  CommonRoyaltySchema,
  CommonSymbolSchema,
  CommonTrustedForwarderSchema,
  ContractWrapper,
  DeployTransaction,
  DropErc721ContractSchema,
  EditionDropInitializer,
  EditionInitializer,
  EventType,
  MarketplaceInitializer,
  MarketplaceV3Initializer,
  MultiwrapInitializer,
  NATIVE_TOKEN_ADDRESS,
  NFTCollectionInitializer,
  NFTDropInitializer,
  PREBUILT_CONTRACTS_APPURI_MAP,
  PREBUILT_CONTRACTS_MAP,
  PackInitializer,
  RPCConnectionHandler,
  SignatureDropInitializer,
  SplitInitializer,
  THIRDWEB_DEPLOYER,
  ThirdwebStorage,
  TokenDropInitializer,
  TokenInitializer,
  Transaction,
  VoteInitializer,
  buildDeployTransactionFunction,
  buildTransactionFunction,
  computeCreate2FactoryTransaction,
  computeDeploymentAddress,
  computeDeploymentInfo,
  computeForwarderAddress,
  createLruCache,
  detectFeatures,
  encodeConstructorParamsForImplementation,
  extractConstructorParamsFromAbi,
  extractFeatures,
  fetchAndCacheDeployMetadata,
  fetchContractMetadataFromAddress,
  fetchExtendedReleaseMetadata,
  fetchPublishedContractFromPolygon,
  fetchSourceFilesFromMetadata,
  getChainProvider,
  getCompositeABI,
  getContractAddressByChainId,
  getContractName,
  getContractPublisherAddress,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getDefaultGasOverrides,
  getInitBytecodeWithSalt,
  getMultichainRegistryAddress,
  getProcessEnv,
  getSignerAndProvider,
  hasMatchingAbi,
  invariant,
  isBrowser,
  isChainConfig,
  isContractDeployed,
  require_bs58,
  resolveAddress,
  resolveContractUriFromAddress,
  resolveImplementation,
  setSupportedChains,
  sha256,
  signTypedDataInternal,
  z
} from "./chunk-CFECTRPO.js";
import {
  require_utils
} from "./chunk-LM37R6ZK.js";
import {
  defaultChains
} from "./chunk-I3A4RD7G.js";
import {
  eventemitter3_default
} from "./chunk-JP4SQOMD.js";
import {
  Hash,
  bytes,
  concatBytes,
  exists,
  hash,
  randomBytes,
  toBytes
} from "./chunk-S7TFJEVG.js";
import {
  Contract,
  ContractFactory,
  Wallet,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  require_bn
} from "./chunk-H3V7PHW7.js";
import {
  import_process,
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __export,
  __publicField,
  __toESM
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/sdk/dist/sdk-f6ebef2b.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryRouter.json
var TWMultichainRegistryRouter_default = [
  {
    type: "constructor",
    inputs: [
      {
        name: "_pluginMap",
        type: "address",
        internalType: "address"
      },
      {
        name: "_trustedForwarders",
        type: "address[]",
        internalType: "address[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "fallback",
    stateMutability: "payable"
  },
  {
    type: "receive",
    stateMutability: "payable"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "_getPluginForFunction",
    inputs: [
      {
        name: "_selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "addPlugin",
    inputs: [
      {
        name: "_plugin",
        type: "tuple",
        internalType: "struct IPluginMap.Plugin",
        components: [
          {
            name: "functionSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "functionSignature",
            type: "string",
            internalType: "string"
          },
          {
            name: "pluginAddress",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "getAllFunctionsOfPlugin",
    inputs: [
      {
        name: "_pluginAddress",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "registered",
        type: "bytes4[]",
        internalType: "bytes4[]"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getAllPlugins",
    inputs: [],
    outputs: [
      {
        name: "registered",
        type: "tuple[]",
        internalType: "struct IPluginMap.Plugin[]",
        components: [
          {
            name: "functionSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "functionSignature",
            type: "string",
            internalType: "string"
          },
          {
            name: "pluginAddress",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getPluginForFunction",
    inputs: [
      {
        name: "_selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMember",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "member",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMemberCount",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "count",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "hasRoleWithSwitch",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTrustedForwarder",
    inputs: [
      {
        name: "forwarder",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "multicall",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [
      {
        name: "results",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "pluginMap",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "removePlugin",
    inputs: [
      {
        name: "_selector",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "updatePlugin",
    inputs: [
      {
        name: "_plugin",
        type: "tuple",
        internalType: "struct IPluginMap.Plugin",
        components: [
          {
            name: "functionSelector",
            type: "bytes4",
            internalType: "bytes4"
          },
          {
            name: "functionSignature",
            type: "string",
            internalType: "string"
          },
          {
            name: "pluginAddress",
            type: "address",
            internalType: "address"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "event",
    name: "PluginAdded",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "pluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PluginRemoved",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "pluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PluginSet",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "functionSignature",
        type: "string",
        indexed: true,
        internalType: "string"
      },
      {
        name: "pluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "PluginUpdated",
    inputs: [
      {
        name: "functionSelector",
        type: "bytes4",
        indexed: true,
        internalType: "bytes4"
      },
      {
        name: "oldPluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "newPluginAddress",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-f6ebef2b.browser.esm.js
init_lib();

// node_modules/@thirdweb-dev/generated-abis/dist/thirdweb-dev-generated-abis.esm.js
init_shim();
var GENERATED_ABI = {};

// node_modules/@thirdweb-dev/contracts-js/dist/abis/TWFactory.json
var TWFactory_default = [
  {
    type: "constructor",
    inputs: [
      {
        name: "_trustedForwarder",
        type: "address",
        internalType: "address"
      },
      {
        name: "_registry",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "DEFAULT_ADMIN_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "FACTORY_ROLE",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "addImplementation",
    inputs: [
      {
        name: "_implementation",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "approval",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "approveImplementation",
    inputs: [
      {
        name: "_implementation",
        type: "address",
        internalType: "address"
      },
      {
        name: "_toApprove",
        type: "bool",
        internalType: "bool"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "currentVersion",
    inputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "deployProxy",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "_data",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "deployProxyByImplementation",
    inputs: [
      {
        name: "_implementation",
        type: "address",
        internalType: "address"
      },
      {
        name: "_data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "_salt",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "deployedProxy",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "deployProxyDeterministic",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "_data",
        type: "bytes",
        internalType: "bytes"
      },
      {
        name: "_salt",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "deployer",
    inputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getImplementation",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "_version",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getLatestImplementation",
    inputs: [
      {
        name: "_type",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleAdmin",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMember",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "index",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "getRoleMemberCount",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      }
    ],
    outputs: [
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "grantRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "hasRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "implementation",
    inputs: [
      {
        name: "",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "",
        type: "uint256",
        internalType: "uint256"
      }
    ],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "address"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "isTrustedForwarder",
    inputs: [
      {
        name: "forwarder",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "multicall",
    inputs: [
      {
        name: "data",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    outputs: [
      {
        name: "results",
        type: "bytes[]",
        internalType: "bytes[]"
      }
    ],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "registry",
    inputs: [],
    outputs: [
      {
        name: "",
        type: "address",
        internalType: "contract TWRegistry"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "function",
    name: "renounceRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "revokeRole",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        internalType: "address"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  },
  {
    type: "function",
    name: "supportsInterface",
    inputs: [
      {
        name: "interfaceId",
        type: "bytes4",
        internalType: "bytes4"
      }
    ],
    outputs: [
      {
        name: "",
        type: "bool",
        internalType: "bool"
      }
    ],
    stateMutability: "view"
  },
  {
    type: "event",
    name: "ImplementationAdded",
    inputs: [
      {
        name: "implementation",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "contractType",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "version",
        type: "uint256",
        indexed: false,
        internalType: "uint256"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ImplementationApproved",
    inputs: [
      {
        name: "implementation",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "isApproved",
        type: "bool",
        indexed: false,
        internalType: "bool"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "ProxyDeployed",
    inputs: [
      {
        name: "implementation",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "proxy",
        type: "address",
        indexed: false,
        internalType: "address"
      },
      {
        name: "deployer",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleAdminChanged",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "previousAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "newAdminRole",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleGranted",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  },
  {
    type: "event",
    name: "RoleRevoked",
    inputs: [
      {
        name: "role",
        type: "bytes32",
        indexed: true,
        internalType: "bytes32"
      },
      {
        name: "account",
        type: "address",
        indexed: true,
        internalType: "address"
      },
      {
        name: "sender",
        type: "address",
        indexed: true,
        internalType: "address"
      }
    ],
    anonymous: false
  }
];

// node_modules/@thirdweb-dev/sdk/dist/sdk-f6ebef2b.browser.esm.js
var alreadyChecked = false;
function checkClientIdOrSecretKey(message, clientId, secretKey) {
  if (alreadyChecked) {
    return;
  }
  alreadyChecked = true;
  if (clientId || secretKey) {
    return;
  }
  console.warn(message);
}
async function getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage) {
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  let constructorParamMap = arguments.length > 6 ? arguments[6] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, contractVersion, storage, clientId, secretKey);
  const publishUri = publishedContract.metadataUri;
  const metadata = await fetchAndCacheDeployMetadata(publishUri, storage);
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishUri, storage);
  let encodedArgs;
  if (extendedMetadata?.routerType === "plugin" || extendedMetadata?.routerType === "dynamic") {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);
    encodedArgs = deploymentInfo.find((contract) => contract.type === "implementation")?.encodedArgs;
  } else {
    encodedArgs = await encodeConstructorParamsForImplementation(metadata.compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey);
  }
  return encodedArgs;
}
async function predictThirdwebContractAddress(contractName, chainId, storage) {
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, contractName, contractVersion, storage, clientId, secretKey);
  const publishUri = publishedContract.metadataUri;
  const create2Factory = await getCreate2FactoryAddress(provider);
  invariant(create2Factory, "Thirdweb stack not found");
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishUri, storage);
  if (extendedMetadata?.routerType === "plugin" || extendedMetadata?.routerType === "dynamic") {
    const deploymentInfo = await getDeploymentInfo(publishUri, storage, provider, create2Factory, clientId, secretKey);
    const implementation2 = deploymentInfo.find((contract) => contract.type === "implementation")?.transaction.predictedAddress;
    invariant(implementation2, "Error computing address for plugin router");
    return implementation2;
  }
  const implementation = await computeDeploymentInfo("implementation", provider, storage, create2Factory, {
    contractName
  }, clientId, secretKey);
  return implementation.transaction.predictedAddress;
}
async function getThirdwebContractAddress(contractName, chainId, storage) {
  let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
  let clientId = arguments.length > 4 ? arguments[4] : void 0;
  let secretKey = arguments.length > 5 ? arguments[5] : void 0;
  const provider = getChainProvider(chainId, {
    clientId,
    secretKey
  });
  const contractAddress = await predictThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);
  const isDeployed = await isContractDeployed(contractAddress, provider);
  invariant(isDeployed, "Contract not deployed yet");
  return contractAddress;
}
var VerificationStatus = {
  FAILED: "Fail - Unable to verify",
  SUCCESS: "Pass - Verified",
  PENDING: "Pending in queue",
  IN_PROGRESS: "In progress",
  ALREADY_VERIFIED: "Contract source code already verified",
  AUTOMATICALLY_VERIFIED: "Already Verified"
};
var RequestStatus = {
  OK: "1",
  NOTOK: "0"
};
async function verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, storage) {
  let contractVersion = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "latest";
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let constructorArgs = arguments.length > 8 ? arguments[8] : void 0;
  const contractAddress = await getThirdwebContractAddress(contractName, chainId, storage, contractVersion, clientId, secretKey);
  const encodedArgs = await getEncodedConstructorParamsForThirdwebContract(contractName, chainId, storage, contractVersion, clientId, secretKey, constructorArgs);
  console.info(`Verifying ${contractName} at address ${contractAddress}`);
  const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedArgs?.toString().replace("0x", ""));
  return guid;
}
async function verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, storage, encodedConstructorArgs) {
  try {
    const provider = getChainProvider(chainId, {});
    contractAddress = (await resolveImplementation(contractAddress, provider)).address;
    const compilerMetadata = await fetchContractMetadataFromAddress(contractAddress, provider, storage);
    const compilerVersion = compilerMetadata.metadata.compiler.version;
    const sources = await fetchSourceFilesFromMetadata(compilerMetadata, storage);
    const sourcesWithUrl = compilerMetadata.metadata.sources;
    const sourcesWithContents = {};
    for (const path of Object.keys(sourcesWithUrl)) {
      const sourceCode = sources.find((source) => path === source.filename);
      if (!sourceCode) {
        throw new Error(`Could not find source file for ${path}`);
      }
      sourcesWithContents[path] = {
        content: sourceCode.source
      };
    }
    const compilerInput = {
      language: "Solidity",
      sources: sourcesWithContents,
      settings: {
        optimizer: compilerMetadata.metadata.settings.optimizer,
        evmVersion: compilerMetadata.metadata.settings.evmVersion,
        remappings: compilerMetadata.metadata.settings.remappings,
        outputSelection: {
          "*": {
            "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
            "": ["ast"]
          }
        }
      }
    };
    const compilationTarget = compilerMetadata.metadata.settings.compilationTarget;
    const targets = Object.keys(compilationTarget);
    const contractPath = targets[0];
    const encodedArgs = encodedConstructorArgs ? encodedConstructorArgs : await fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, compilerMetadata.abi, provider, storage);
    const requestBody = {
      apikey: explorerAPIKey,
      module: "contract",
      action: "verifysourcecode",
      contractaddress: contractAddress,
      sourceCode: JSON.stringify(compilerInput),
      codeformat: "solidity-standard-json-input",
      contractname: `${contractPath}:${compilerMetadata.name}`,
      compilerversion: `v${compilerVersion}`,
      constructorArguements: encodedArgs
    };
    const parameters = new URLSearchParams({
      ...requestBody
    });
    const result = await fetch(explorerAPIUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: parameters.toString()
    });
    const data = await result.json();
    if (data.status === RequestStatus.OK) {
      return data.result;
    } else {
      throw new Error(`${data.result}`);
    }
  } catch (e) {
    throw new Error(e.toString());
  }
}
async function checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid) {
  const endpoint = `${explorerAPIUrl}?module=contract&action=checkverifystatus&guid=${guid}&apikey=${explorerAPIKey}"`;
  return new Promise((resolve, reject) => {
    const intervalId = setInterval(async () => {
      try {
        const result = await fetch(endpoint, {
          method: "GET"
        });
        const data = await result.json();
        if (data?.result !== VerificationStatus.PENDING && data?.result !== VerificationStatus.IN_PROGRESS) {
          clearInterval(intervalId);
          resolve(data);
        }
      } catch (e) {
        clearInterval(intervalId);
        reject(e);
      }
    }, 3e3);
  });
}
async function isVerifiedOnEtherscan(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, clientId) {
  const provider = getChainProvider(chainId, {
    clientId
  });
  invariant(await isContractDeployed(contractAddress, provider), "Contract not deployed yet.");
  const endpoint = `${explorerAPIUrl}?module=contract&action=getsourcecode&address=${contractAddress}&apikey=${explorerAPIKey}"`;
  try {
    const result = await fetch(endpoint, {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json;charset=UTF-8"
      }
    });
    const data = await result.json();
    const etherscanResult = data.result[0];
    if (etherscanResult.ABI === "Contract source code not verified") {
      return false;
    }
    return true;
  } catch (e) {
    throw new Error(`Error checking verification for contract ${contractAddress}: ${e}`);
  }
}
async function fetchConstructorParams(explorerAPIUrl, explorerAPIKey, contractAddress, abi, provider, storage) {
  const constructorParamTypes = extractConstructorParamsFromAbi(abi);
  if (constructorParamTypes.length === 0) {
    return "";
  }
  const result = await fetch(`${explorerAPIUrl}?module=contract&action=getcontractcreation&contractaddresses=${contractAddress}&apikey=${explorerAPIKey}`);
  const data = await result.json();
  if (data && data.status === RequestStatus.OK && data.result[0] !== void 0) {
    const contract = new utils_exports.Interface(abi);
    const txHash = data.result[0].txHash;
    let constructorArgs = "";
    if (contract.deploy.inputs.length === 0) {
      return "";
    }
    const tx = await provider.getTransaction(txHash);
    const txDeployBytecode = tx.data;
    try {
      const bytecode = await fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage);
      if (bytecode) {
        const bytecodeHex = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
        let create2FactoryAddress;
        try {
          create2FactoryAddress = await getCreate2FactoryAddress(provider);
        } catch (error) {
        }
        const create2SaltLength = tx.to === create2FactoryAddress ? 64 : 0;
        constructorArgs = txDeployBytecode.substring(bytecodeHex.length + create2SaltLength);
      }
    } catch (e) {
    }
    if (!constructorArgs) {
      const matches = [...txDeployBytecode.matchAll(/(64736f6c6343[\w]{6}[\w]{4})(?!.*\1)(.*)$/g)];
      if (matches.length > 0) {
        constructorArgs = matches[0][2];
      }
    }
    if (!constructorArgs) {
      const constructorParamByteLength = constructorParamTypes.length * 64;
      constructorArgs = txDeployBytecode.substring(txDeployBytecode.length - constructorParamByteLength);
    }
    try {
      utils_exports.defaultAbiCoder.decode(contract.deploy.inputs, `0x${constructorArgs}`);
    } catch (e) {
      throw new Error("Verifying this contract requires it to be published. Run `npx thirdweb publish` to publish this contract, then try again.");
    }
    return constructorArgs;
  } else {
    return "";
  }
}
async function fetchDeployBytecodeFromPublishedContractMetadata(contractAddress, provider, storage) {
  const compilerMetaUri = await resolveContractUriFromAddress(contractAddress, provider);
  if (compilerMetaUri) {
    const ContractPublisherAbi = (await import("./ContractPublisher-TGIGRAEZ.js")).default;
    const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider("polygon", {}));
    const publishedMetadataUri = await contract.getPublishedUriFromCompilerUri(compilerMetaUri);
    if (publishedMetadataUri.length === 0) {
      throw Error(`Could not resolve published metadata URI from ${compilerMetaUri}`);
    }
    const pubmeta = await Promise.all(publishedMetadataUri.filter((uri) => uri.length > 0).map((uri) => fetchExtendedReleaseMetadata(uri, storage)));
    return pubmeta.length > 0 ? await (await storage.download(pubmeta[0].bytecodeUri)).text() : void 0;
  }
  return void 0;
}
var ContractVerifier = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    this.storage = storage;
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
  }
  async verifyThirdwebContract(contractName, explorerAPIUrl, explorerAPIKey) {
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let constructorArgs = arguments.length > 4 ? arguments[4] : void 0;
    const chainId = (await this.getProvider().getNetwork()).chainId;
    const guid = await verifyThirdwebPrebuiltImplementation(contractName, chainId, explorerAPIUrl, explorerAPIKey, this.storage, contractVersion, this.options.clientId, this.options.secretKey, constructorArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
  async verifyContract(contractAddress, explorerAPIUrl, explorerAPIKey, constructorArgs) {
    const chainId = (await this.getProvider().getNetwork()).chainId;
    let encodedArgs;
    if (constructorArgs) {
      const paramTypes = Object.values(constructorArgs).map((arg) => {
        invariant(arg.type, "Param type is required");
        return arg.type;
      });
      const paramValues = Object.values(constructorArgs).map((arg) => {
        return arg.value;
      });
      encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypes, paramValues);
    }
    const guid = await verify(contractAddress, chainId, explorerAPIUrl, explorerAPIKey, this.storage, encodedArgs);
    console.info("Checking verification status...");
    const verificationStatus = await checkVerificationStatus(explorerAPIUrl, explorerAPIKey, guid);
    console.info(verificationStatus);
  }
};
var LOCAL_NODE_PKEY = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
var UserWallet = class {
  constructor(network, options, storage) {
    __publicField(this, "events", new eventemitter3_default());
    this.connection = new RPCConnectionHandler(network, options);
    this.options = options;
    this.events = new eventemitter3_default();
    this.storage = storage;
  }
  connect(network) {
    this.connection.updateSignerOrProvider(network);
    this.events.emit("signerChanged", this.connection.getSigner());
  }
  async transfer(to, amount) {
    let currencyAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NATIVE_TOKEN_ADDRESS;
    const [resolvedTo, resolvedCurrency, amountInWei] = await Promise.all([resolveAddress(to), resolveAddress(currencyAddress), normalizePriceValue(this.connection.getProvider(), amount, currencyAddress)]);
    const signer = this.requireWallet();
    if (isNativeToken(resolvedCurrency)) {
      const from = await signer.getAddress();
      const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());
      const tx = await signer.sendTransaction({
        from,
        to: resolvedTo,
        value: amountInWei,
        ...gasOverrides
      });
      return {
        receipt: await tx.wait()
      };
    } else {
      const ERC20Abi = (await import("./IERC20-GHSR35K6.js")).default;
      return {
        receipt: await this.createErc20(resolvedCurrency, ERC20Abi).sendTransaction("transfer", [resolvedTo, amountInWei])
      };
    }
  }
  async balance() {
    let currencyAddress = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NATIVE_TOKEN_ADDRESS;
    this.requireWallet();
    const resolvedCurrency = await resolveAddress(currencyAddress);
    const provider = this.connection.getProvider();
    let balance;
    if (isNativeToken(resolvedCurrency)) {
      balance = await provider.getBalance(await this.getAddress());
    } else {
      const ERC20Abi = (await import("./IERC20-GHSR35K6.js")).default;
      balance = await this.createErc20(resolvedCurrency, ERC20Abi).read("balanceOf", [await this.getAddress()]);
    }
    return await fetchCurrencyValue(provider, resolvedCurrency, balance);
  }
  async getAddress() {
    return await this.requireWallet().getAddress();
  }
  async getChainId() {
    return await this.requireWallet().getChainId();
  }
  async getNonce(blockTag) {
    const txCount = await this.connection.getProvider().getTransactionCount(await this.getAddress(), blockTag);
    return txCount;
  }
  isConnected() {
    try {
      this.requireWallet();
      return true;
    } catch (e) {
      return false;
    }
  }
  async sign(message) {
    const signer = this.requireWallet();
    return await signer.signMessage(message);
  }
  async signTypedData(domain, types, message) {
    return await signTypedDataInternal(this.requireWallet(), domain, types, message);
  }
  recoverAddress(message, signature) {
    const messageHash = utils_exports.hashMessage(message);
    const messageHashBytes = utils_exports.arrayify(messageHash);
    return utils_exports.recoverAddress(messageHashBytes, signature);
  }
  async sendRawTransaction(transactionRequest) {
    const signer = this.requireWallet();
    const gasOverrides = isBrowser() ? {} : await getDefaultGasOverrides(this.connection.getProvider());
    transactionRequest = {
      ...gasOverrides,
      ...transactionRequest
    };
    return signer.sendTransaction(transactionRequest);
  }
  async executeRawTransaction(transactionRequest) {
    const tx = await this.sendRawTransaction(transactionRequest);
    return {
      receipt: await tx.wait()
    };
  }
  async requestFunds(amount) {
    const chainId = await this.getChainId();
    if (chainId === ChainId.Localhost || chainId === ChainId.Hardhat) {
      const localWallet = new UserWallet(new Wallet(LOCAL_NODE_PKEY, getChainProvider(chainId, this.options)), this.options, this.storage);
      return localWallet.transfer(await this.getAddress(), amount);
    } else {
      throw new Error(`Requesting funds is not supported on chain: '${chainId}'.`);
    }
  }
  requireWallet() {
    const signer = this.connection.getSigner();
    invariant(signer, "This action requires a connected wallet. Please pass a valid signer to the SDK.");
    return signer;
  }
  createErc20(currencyAddress, ERC20Abi) {
    return new ContractWrapper(this.connection.getSignerOrProvider(), currencyAddress, ERC20Abi, this.options, this.storage);
  }
};
function getAllDetectedFeatureNames(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features.map((f) => f.name);
}
function getAllDetectedExtensionNames(abi) {
  return getAllDetectedFeatureNames(abi);
}
function createStorage(storage, options) {
  if (storage) {
    return storage;
  } else if (options?.gatewayUrls) {
    return new ThirdwebStorage({
      gatewayUrls: options.gatewayUrls,
      clientId: options.clientId,
      secretKey: options.secretKey
    });
  } else {
    return new ThirdwebStorage({
      clientId: options?.clientId,
      secretKey: options?.secretKey
    });
  }
}
var MultichainRegistry = class {
  constructor(network, storage) {
    __publicField(this, "addContract", buildTransactionFunction(async (contract) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryLogic,
        method: "add",
        args: [deployerAddress, contract.address, contract.chainId, contract.metadataURI || ""]
      });
    }));
    __publicField(this, "addContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const encoded = [];
      const contractEncoder = new ContractEncoder(this.registryLogic);
      contracts.forEach((contact) => {
        encoded.push(contractEncoder.encode("add", [deployerAddress, contact.address, contact.chainId, contact.metadataURI || ""]));
      });
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "removeContract", buildTransactionFunction(async (contract) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryLogic,
        method: "remove",
        args: [deployerAddress, await resolveAddress(contract.address), contract.chainId]
      });
    }));
    __publicField(this, "removeContracts", buildTransactionFunction(async (contracts) => {
      const deployerAddress = await this.registryRouter.getSignerAddress();
      const contractEncoder = new ContractEncoder(this.registryLogic);
      const encoded = await Promise.all(contracts.map(async (contract) => contractEncoder.encode("remove", [deployerAddress, await resolveAddress(contract.address), contract.chainId])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.registryRouter,
        method: "multicall",
        args: [encoded]
      });
    }));
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.storage = storage;
    this.registryLogic = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryLogic_default, options, storage);
    this.registryRouter = new ContractWrapper(network, getMultichainRegistryAddress(), TWMultichainRegistryRouter_default, options, storage);
  }
  async updateSigner(signer) {
    this.registryLogic.updateSignerOrProvider(signer);
    this.registryRouter.updateSignerOrProvider(signer);
  }
  async getContractMetadataURI(chainId, address) {
    return await this.registryLogic.read("getMetadataUri", [chainId, await resolveAddress(address)]);
  }
  async getContractMetadata(chainId, address) {
    const uri = await this.getContractMetadataURI(chainId, address);
    if (!uri) {
      throw new Error(`No metadata URI found for contract ${address} on chain ${chainId}`);
    }
    return await this.storage.downloadJSON(uri);
  }
  async getContractAddresses(walletAddress) {
    return (await this.registryLogic.read("getAll", [await resolveAddress(walletAddress)])).filter((result) => utils_exports.isAddress(result.deploymentAddress) && result.deploymentAddress.toLowerCase() !== lib_exports.AddressZero).map((result) => ({
      address: result.deploymentAddress,
      chainId: result.chainId.toNumber()
    }));
  }
};
function extractFunctionParamsFromAbi(abi, functionName) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "function" && input.name === functionName) {
      return input.inputs || [];
    }
  }
  return [];
}
async function computeCloneFactoryAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "TWCloneFactory"
  }, clientId, secretKey)).transaction.predictedAddress;
}
function convertParamValues(constructorParamTypes, constructorParamValues) {
  if (constructorParamTypes.length !== constructorParamValues.length) {
    throw Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);
  }
  return constructorParamTypes.map((p, index) => {
    if (p === "tuple" || p.endsWith("[]")) {
      if (typeof constructorParamValues[index] === "string") {
        return JSON.parse(constructorParamValues[index]);
      } else {
        return constructorParamValues[index];
      }
    }
    if (p === "bytes32") {
      invariant(utils_exports.isHexString(constructorParamValues[index]), `Could not parse bytes32 value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return utils_exports.hexZeroPad(constructorParamValues[index], 32);
    }
    if (p.startsWith("bytes")) {
      invariant(utils_exports.isHexString(constructorParamValues[index]), `Could not parse bytes value. Expected valid hex string but got "${constructorParamValues[index]}".`);
      return constructorParamValues[index];
    }
    if (p.startsWith("uint") || p.startsWith("int")) {
      return BigNumber.from(constructorParamValues[index].toString());
    }
    return constructorParamValues[index];
  });
}
async function deployCreate2Factory(signer, options) {
  invariant(signer.provider, "No provider");
  const deploymentInfo = await computeCreate2FactoryTransaction(signer.provider);
  if (deploymentInfo.transaction.length > 0) {
    if ((await signer.provider.getBalance(deploymentInfo.signer)).lt(deploymentInfo.valueToSend)) {
      await (await signer.sendTransaction({
        to: deploymentInfo.signer,
        value: deploymentInfo.valueToSend
      })).wait();
    }
    try {
      console.debug(`deploying CREATE2 factory at: ${deploymentInfo.deployment}`);
      options?.notifier?.("deploying", "create2Factory");
      await (await signer.provider.sendTransaction(deploymentInfo.transaction)).wait();
      options?.notifier?.("deployed", "create2Factory");
    } catch (err) {
      throw new Error(`Couldn't deploy CREATE2 factory: ${JSON.stringify(err)}`);
    }
  }
  return deploymentInfo.deployment;
}
var SUPPORTED_CHAIN_IDS = [ChainId.Mainnet, ChainId.Goerli, ChainId.Polygon, ChainId.Mumbai, ChainId.Fantom, ChainId.FantomTestnet, ChainId.Avalanche, ChainId.AvalancheFujiTestnet, ChainId.Optimism, ChainId.OptimismGoerli, ChainId.Arbitrum, ChainId.ArbitrumGoerli, ChainId.BinanceSmartChainMainnet, ChainId.BinanceSmartChainTestnet, ChainId.Hardhat, ChainId.Localhost];
function getDefaultTrustedForwarders(chainId) {
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const biconomyForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum]?.biconomyForwarder : AddressZero;
  const openzeppelinForwarder = chainEnum ? CONTRACT_ADDRESSES[chainEnum]?.openzeppelinForwarder : AddressZero;
  return [openzeppelinForwarder, biconomyForwarder].filter((a) => a !== AddressZero);
}
function overrideRecipientAddress(signerAddress, recipient) {
  if (recipient === lib_exports.AddressZero) {
    return signerAddress;
  }
  return recipient;
}
async function getDeployArguments(contractType, metadata, contractURI, signer) {
  const signerAddress = metadata.defaultAdmin || await signer.getAddress();
  const trustedForwarders = [];
  if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
    trustedForwarders.push(...metadata.trusted_forwarders);
  }
  switch (contractType) {
    case NFTDropInitializer.contractType:
    case NFTCollectionInitializer.contractType:
      const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];
    case SignatureDropInitializer.contractType:
      const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];
    case MultiwrapInitializer.contractType:
      const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
    case EditionDropInitializer.contractType:
    case EditionInitializer.contractType:
      const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];
    case TokenDropInitializer.contractType:
    case TokenInitializer.contractType:
      const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];
    case VoteInitializer.contractType:
      const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
      return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
    case SplitInitializer.contractType:
      const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
    case MarketplaceInitializer.contractType:
    case MarketplaceV3Initializer.contractType:
      const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];
    case PackInitializer.contractType:
      const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
      return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
    default:
      return [];
  }
}
async function getTrustedForwarders(provider, storage, contractName) {
  const chainId = (await provider.getNetwork()).chainId;
  const chainEnum = SUPPORTED_CHAIN_IDS.find((c) => c === chainId);
  const trustedForwarders = contractName && contractName === PackInitializer.name ? [] : chainEnum ? getDefaultTrustedForwarders(chainId) : [await computeForwarderAddress(provider, storage)];
  return trustedForwarders;
}
var APPROVED_IMPLEMENTATIONS = {
  [ChainId.Mainnet]: {
    "nft-drop": "0x60fF9952e0084A6DEac44203838cDC91ABeC8736",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "signature-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A"
  },
  [ChainId.Polygon]: {
    "nft-drop": "0xB96508050Ba0925256184103560EBADA912Fcc69",
    "edition-drop": "0x74af262d0671F378F97a1EDC3d0970Dbe8A1C550",
    "token-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "signature-drop": "0xBE2fDc35410E268e41Bec62DBb01AEb43245c7d5"
  },
  [ChainId.Fantom]: {
    "nft-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "edition-drop": "0x06395FCF9AC6ED827f9dD6e776809cEF1Be0d21B",
    "token-drop": "0x0148b28a38efaaC31b6aa0a6D9FEb70FE7C91FFa",
    "signature-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10"
  },
  [ChainId.Avalanche]: {
    "nft-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "edition-drop": "0x135fC9D26E5eC51260ece1DF4ED424E2f55c7766",
    "token-drop": "0xca0B071899E575BA86495D46c5066971b6f3A901",
    "signature-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3"
  },
  [ChainId.Optimism]: {
    "nft-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "edition-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "token-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "signature-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD"
  },
  [ChainId.Arbitrum]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.BinanceSmartChainMainnet]: {
    "nft-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "edition-drop": "0x2A396b2D90BAcEF19cDa973586B2633d22710fC2",
    "token-drop": "0xe135Ef65C2B2213C3fD56d0Bd6500A2cA147aC10",
    "signature-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1"
  },
  [ChainId.Goerli]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf",
    "token-drop": "0x5680933221B752EB443654a014f88B101F868d50",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.Mumbai]: {
    "nft-drop": "0xC4903c1Ff5367b9ac2c349B63DC2409421AaEE2a",
    "edition-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "token-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9",
    "signature-drop": "0x2dF9851af45dd41C8584ac55D983C604da985Bc7"
  },
  [ChainId.FantomTestnet]: {
    "nft-drop": "0x8a4cd3549e548bbEEb38C16E041FFf040a5acabD",
    "edition-drop": "0x902Dd246e66d8C3CE652375a723F2a52b43b9AAE",
    "token-drop": "0xFBd7D24d80ee005671E731a7287DEB6073264dD1",
    "signature-drop": "0x5A8eA4Adad8289746D073947BA06D69A62499aaf"
  },
  [ChainId.AvalancheFujiTestnet]: {
    "nft-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "edition-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728",
    "token-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "signature-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F"
  },
  [ChainId.OptimismGoerli]: {
    "nft-drop": "0xCcddcec1831646Beff2753249f1B9C580327E89F",
    "edition-drop": "0x6fD690EB509BdE4C50028C5D9C0dE3750C2Fad6A",
    "token-drop": "0xD11c97DD5F5546B5bBd630D7D1d7327481B0b92C",
    "signature-drop": "0x1b5947e1a2d5a29D0df20931DeAB0B87818209B9"
  },
  [ChainId.ArbitrumGoerli]: {
    "nft-drop": "0x9CfE807a5b124b962064Fa8F7FD823Cc701255b6",
    "edition-drop": "0x9cF91118C8ee2913F0588e0F10e36B3d63F68bF6",
    "token-drop": "0x1d47526C3292B0130ef0afD5F02c1DA052A017B3",
    "signature-drop": "0xE1eE43D23f247b6A9aF81fcE2766E76709482728"
  },
  [ChainId.BinanceSmartChainTestnet]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
  },
  [ChainId.Hardhat]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
  },
  [ChainId.Localhost]: {
    "nft-drop": "",
    "edition-drop": "",
    "token-drop": "",
    "signature-drop": ""
  }
};
function getApprovedImplementation(chainId, contractType) {
  if (chainId in APPROVED_IMPLEMENTATIONS) {
    const approvedImpls = APPROVED_IMPLEMENTATIONS[chainId];
    if (contractType in approvedImpls) {
      return approvedImpls[contractType];
    }
  }
  return null;
}
var ContractFactory2 = class extends ContractWrapper {
  constructor(factoryAddr, network, storage, options) {
    super(network, factoryAddr, TWFactory_default, options, storage);
    __publicField(this, "DEFAULT_VERSION_MAP", {
      [NFTDropInitializer.contractType]: 3,
      [NFTCollectionInitializer.contractType]: 1,
      [SignatureDropInitializer.contractType]: 4,
      [MultiwrapInitializer.contractType]: 1,
      [EditionDropInitializer.contractType]: 2,
      [EditionInitializer.contractType]: 1,
      [TokenDropInitializer.contractType]: 2,
      [TokenInitializer.contractType]: 1,
      [VoteInitializer.contractType]: 1,
      [SplitInitializer.contractType]: 1,
      [MarketplaceInitializer.contractType]: 2,
      [MarketplaceV3Initializer.contractType]: 3,
      [PackInitializer.contractType]: 2
    });
    __publicField(this, "deploy", buildTransactionFunction(async (contractType, contractMetadata, eventEmitter, version, options, onExecute) => {
      const contract = PREBUILT_CONTRACTS_MAP[contractType];
      const metadata = await contract.schema.deploy.parseAsync(contractMetadata);
      const contractURI = await this.storage.upload(metadata);
      const implementationAddress = await this.getImplementation(contract, version) || void 0;
      if (!implementationAddress || implementationAddress === lib_exports.AddressZero) {
        throw new Error(`No implementation found for ${contractType}`);
      }
      const ABI = await contract.getAbi(implementationAddress, this.getProvider(), this.storage);
      const signer = this.getSigner();
      invariant(signer, "A signer is required to deploy contracts");
      const args = await getDeployArguments(contractType, metadata, contractURI, signer);
      const encodedFunc = Contract.getInterface(ABI).encodeFunctionData("initialize", args);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = options?.saltForProxyDeploy ? utils_exports.id(options.saltForProxyDeploy) : utils_exports.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    __publicField(this, "deployProxyByImplementation", buildTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs, eventEmitter, saltForProxyDeploy, onExecute) => {
      const encodedFunc = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const blockNumber = await this.getProvider().getBlockNumber();
      const salt = saltForProxyDeploy ? utils_exports.id(saltForProxyDeploy) : utils_exports.formatBytes32String(blockNumber.toString());
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "deployProxyByImplementation",
        args: [implementationAddress, encodedFunc, salt],
        parse: (receipt) => {
          if (onExecute) {
            onExecute();
          }
          const events = this.parseLogs("ProxyDeployed", receipt.logs);
          if (events.length < 1) {
            throw new Error("No ProxyDeployed event found");
          }
          const contractAddress = events[0].args.proxy;
          eventEmitter.emit("contractDeployed", {
            status: "completed",
            contractAddress,
            transactionHash: receipt.transactionHash
          });
          return contractAddress;
        }
      });
    }));
    this.storage = storage;
  }
  async getDeployArguments(contractType, metadata, contractURI) {
    let trustedForwarders = [];
    if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
      trustedForwarders = metadata.trusted_forwarders;
    }
    const signerAddress = await this.getSignerAddress();
    switch (contractType) {
      case NFTDropInitializer.contractType:
      case NFTCollectionInitializer.contractType:
        const erc721metadata = await NFTDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc721metadata.name, erc721metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc721metadata.primary_sale_recipient), erc721metadata.fee_recipient, erc721metadata.seller_fee_basis_points, erc721metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc721metadata.platform_fee_recipient)];
      case SignatureDropInitializer.contractType:
        const signatureDropmetadata = await SignatureDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, signatureDropmetadata.name, signatureDropmetadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, signatureDropmetadata.primary_sale_recipient), signatureDropmetadata.fee_recipient, signatureDropmetadata.seller_fee_basis_points, signatureDropmetadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, signatureDropmetadata.platform_fee_recipient)];
      case MultiwrapInitializer.contractType:
        const multiwrapMetadata = await MultiwrapInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, multiwrapMetadata.name, multiwrapMetadata.symbol, contractURI, trustedForwarders, multiwrapMetadata.fee_recipient, multiwrapMetadata.seller_fee_basis_points];
      case EditionDropInitializer.contractType:
      case EditionInitializer.contractType:
        const erc1155metadata = await EditionDropInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc1155metadata.name, erc1155metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc1155metadata.primary_sale_recipient), erc1155metadata.fee_recipient, erc1155metadata.seller_fee_basis_points, erc1155metadata.platform_fee_basis_points, overrideRecipientAddress(signerAddress, erc1155metadata.platform_fee_recipient)];
      case TokenDropInitializer.contractType:
      case TokenInitializer.contractType:
        const erc20metadata = await TokenInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, erc20metadata.name, erc20metadata.symbol, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, erc20metadata.primary_sale_recipient), overrideRecipientAddress(signerAddress, erc20metadata.platform_fee_recipient), erc20metadata.platform_fee_basis_points];
      case VoteInitializer.contractType:
        const voteMetadata = await VoteInitializer.schema.deploy.parseAsync(metadata);
        return [voteMetadata.name, contractURI, trustedForwarders, voteMetadata.voting_token_address, voteMetadata.voting_delay_in_blocks, voteMetadata.voting_period_in_blocks, BigNumber.from(voteMetadata.proposal_token_threshold), voteMetadata.voting_quorum_fraction];
      case SplitInitializer.contractType:
        const splitsMetadata = await SplitInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, splitsMetadata.recipients.map((s) => s.address), splitsMetadata.recipients.map((s) => BigNumber.from(s.sharesBps))];
      case MarketplaceInitializer.contractType:
        const marketplaceMetadata = await MarketplaceInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceMetadata.platform_fee_recipient), marketplaceMetadata.platform_fee_basis_points];
      case MarketplaceV3Initializer.contractType:
        const marketplaceV3Metadata = await MarketplaceV3Initializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, contractURI, trustedForwarders, overrideRecipientAddress(signerAddress, marketplaceV3Metadata.platform_fee_recipient), marketplaceV3Metadata.platform_fee_basis_points];
      case PackInitializer.contractType:
        const packsMetadata = await PackInitializer.schema.deploy.parseAsync(metadata);
        return [signerAddress, packsMetadata.name, packsMetadata.symbol, contractURI, trustedForwarders, packsMetadata.fee_recipient, packsMetadata.seller_fee_basis_points];
      default:
        return [];
    }
  }
  async getImplementation(contract, version) {
    const encodedType = utils_exports.formatBytes32String(contract.name);
    const chainId = await this.getChainID();
    const approvedImplementation = getApprovedImplementation(chainId, contract.contractType);
    if (approvedImplementation && approvedImplementation.length > 0 && version === void 0) {
      return approvedImplementation;
    }
    return this.read("getImplementation", [encodedType, version !== void 0 ? version : this.DEFAULT_VERSION_MAP[contract.contractType]]);
  }
  async getLatestVersion(contractType) {
    const name = getContractName(contractType);
    if (!name) {
      throw new Error(`Invalid contract type ${contractType}`);
    }
    const encodedType = utils_exports.formatBytes32String(name);
    return this.read("currentVersion", [encodedType]);
  }
};
var ContractRegistry = class extends ContractWrapper {
  constructor(registryAddress, network, storage, TWRegistryABI, options) {
    super(network, registryAddress, TWRegistryABI, options, storage);
    __publicField(this, "addContract", buildTransactionFunction(async (contractAddress) => {
      return await this.addContracts.prepare([contractAddress]);
    }));
    __publicField(this, "addContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const contractEncoder = new ContractEncoder(this);
      const encoded = (await Promise.all(contractAddresses.map((addr) => resolveAddress(addr)))).map((address) => contractEncoder.encode("add", [deployerAddress, address]));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
    __publicField(this, "removeContract", buildTransactionFunction(async (contractAddress) => {
      return await this.removeContracts.prepare([contractAddress]);
    }));
    __publicField(this, "removeContracts", buildTransactionFunction(async (contractAddresses) => {
      const deployerAddress = await this.getSignerAddress();
      const contractEncoder = new ContractEncoder(this);
      const encoded = (await Promise.all(contractAddresses.map((addr) => resolveAddress(addr)))).map((address) => contractEncoder.encode("remove", [deployerAddress, address]));
      return Transaction.fromContractWrapper({
        contractWrapper: this,
        method: "multicall",
        args: [encoded]
      });
    }));
  }
  async getContractAddresses(walletAddress) {
    return (await this.read("getAll", [await resolveAddress(walletAddress)])).filter((adr) => utils_exports.isAddress(adr) && adr.toLowerCase() !== lib_exports.AddressZero);
  }
};
var LoyaltyCardContractInput = (() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
var LoyaltyCardContractDeploy = (() => LoyaltyCardContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
var AirdropContractInput = (() => CommonContractSchema.merge(CommonSymbolSchema))();
var AirdropContractDeploy = (() => AirdropContractInput.merge(CommonTrustedForwarderSchema))();
async function directDeployDeterministic(bytecode, abi, signer, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  invariant(signer.provider, "Provider is required");
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await deployCreate2Factory(signer);
  const constructorParams = extractConstructorParamsFromAbi(abi);
  const constructorParamTypes = constructorParams.map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const paramTypesForEncoder = constructorParams.map((p) => {
    if (p.type === "tuple[]") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  const contractDeployed = await isContractDeployed(address, signer.provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${address}`);
    initBytecodeWithSalt = getInitBytecodeWithSalt(bytecodePrefixed, encodedArgs, saltForCreate2);
    const tx = {
      to: create2Factory,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  } else {
    throw new Error(`Contract already deployed at ${address}`);
  }
  return address;
}
async function directDeployDeterministicWithUri(publishMetadataUri, signer, storage, constructorArgs, saltForCreate2) {
  let gasLimit = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 7e6;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant(extendedMetadata?.deployType === "standard", "Must be direct deploy");
  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function directDeployDeterministicPublished(contractName, publisherAddress) {
  let contractVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let constructorArgs = arguments.length > 3 ? arguments[3] : void 0;
  let signer = arguments.length > 4 ? arguments[4] : void 0;
  let storage = arguments.length > 5 ? arguments[5] : void 0;
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let saltForCreate2 = arguments.length > 8 ? arguments[8] : void 0;
  let gasLimit = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 7e6;
  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant(extendedMetadata?.deployType === "standard", "Must be direct deploy");
  return await directDeployDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, signer, constructorArgs, saltForCreate2, gasLimit);
}
async function predictAddressDeterministic(bytecode, abi, provider, constructorArgs, saltForCreate2) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const create2Factory = await getCreate2FactoryAddress(provider);
  const constructorParams = extractConstructorParamsFromAbi(abi);
  const constructorParamTypes = constructorParams.map((p) => {
    return p.type;
  });
  const paramValues = convertParamValues(constructorParamTypes, constructorArgs);
  const paramTypesForEncoder = constructorParams.map((p) => {
    if (p.type === "tuple[]") {
      return utils_exports.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const encodedArgs = utils_exports.defaultAbiCoder.encode(paramTypesForEncoder, paramValues);
  const address = computeDeploymentAddress(bytecodePrefixed, encodedArgs, create2Factory, saltForCreate2);
  return address;
}
async function predictAddressDeterministicWithUri(publishMetadataUri, provider, storage, constructorArgs, saltForCreate2) {
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant(extendedMetadata?.deployType === "standard", "Must be direct deploy");
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}
async function predictAddressDeterministicPublished(contractName, publisherAddress) {
  let contractVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
  let constructorArgs = arguments.length > 3 ? arguments[3] : void 0;
  let provider = arguments.length > 4 ? arguments[4] : void 0;
  let storage = arguments.length > 5 ? arguments[5] : void 0;
  let clientId = arguments.length > 6 ? arguments[6] : void 0;
  let secretKey = arguments.length > 7 ? arguments[7] : void 0;
  let saltForCreate2 = arguments.length > 8 ? arguments[8] : void 0;
  const publishMetadataUri = (await fetchPublishedContractFromPolygon(publisherAddress, contractName, contractVersion, storage, clientId, secretKey)).metadataUri;
  const {
    compilerMetadata,
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  invariant(extendedMetadata?.deployType === "standard", "Must be direct deploy");
  return await predictAddressDeterministic(compilerMetadata.bytecode, compilerMetadata.abi, provider, constructorArgs, saltForCreate2);
}
var ThirdwebSDK = class extends RPCConnectionHandler {
  constructor(network) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let storage = arguments.length > 2 ? arguments[2] : void 0;
    const apiKeyType = "clientId";
    let warnMessage = `No API key. Please provide a ${apiKeyType}. It is required to access thirdweb's services. You can create a key at https://thirdweb.com/create-api-key`;
    checkClientIdOrSecretKey(warnMessage, options.clientId, options.secretKey);
    options = addChainToSupportedChains(network, options);
    super(network, options);
    __publicField(this, "contractCache", /* @__PURE__ */ new Map());
    setSupportedChains(options?.supportedChains);
    const configuredStorage = createStorage(storage, options);
    this.storage = configuredStorage;
    this.storageHandler = configuredStorage;
    this.wallet = new UserWallet(network, options, configuredStorage);
    this.deployer = new ContractDeployer(network, options, configuredStorage);
    this.verifier = new ContractVerifier(network, options, configuredStorage);
    this.multiChainRegistry = new MultichainRegistry(network, this.storageHandler, this.options);
    this._publisher = new ContractPublisher(network, this.options, this.storageHandler);
  }
  static async fromWallet(wallet, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const signer = await wallet.getSigner();
    return ThirdwebSDK.fromSigner(signer, network, options, storage);
  }
  static fromSigner(signer, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    let signerWithProvider = signer;
    if (network) {
      try {
        const provider = getChainProvider(network, options);
        signerWithProvider = signer.connect(provider);
      } catch {
      }
    }
    const sdk = new ThirdwebSDK(network || signerWithProvider, network ? addChainToSupportedChains(network, options) : options, storage);
    sdk.updateSignerOrProvider(signerWithProvider);
    return sdk;
  }
  static fromPrivateKey(privateKey, network) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let storage = arguments.length > 3 ? arguments[3] : void 0;
    const provider = getChainProvider(network, options);
    const signer = new Wallet(privateKey, provider);
    return new ThirdwebSDK(signer, addChainToSupportedChains(network, options), storage);
  }
  get auth() {
    throw new Error(`The sdk.auth namespace has been moved to the @thirdweb-dev/auth package and is no longer available after @thirdweb-dev/sdk >= 3.7.0.
      Please visit https://portal.thirdweb.com/wallets/auth for instructions on how to switch to using the new auth package (@thirdweb-dev/auth@3.0.0).

      If you still want to use the old @thirdweb-dev/auth@2.0.0 package, you can downgrade the SDK to version 3.6.0.`);
  }
  async getNFTDrop(contractAddress) {
    return await this.getContract(contractAddress, "nft-drop");
  }
  async getSignatureDrop(contractAddress) {
    return await this.getContract(contractAddress, "signature-drop");
  }
  async getNFTCollection(contractAddress) {
    return await this.getContract(contractAddress, "nft-collection");
  }
  async getEditionDrop(contractAddress) {
    return await this.getContract(contractAddress, "edition-drop");
  }
  async getEdition(contractAddress) {
    return await this.getContract(contractAddress, "edition");
  }
  async getTokenDrop(contractAddress) {
    return await this.getContract(contractAddress, "token-drop");
  }
  async getToken(contractAddress) {
    return await this.getContract(contractAddress, "token");
  }
  async getVote(contractAddress) {
    return await this.getContract(contractAddress, "vote");
  }
  async getSplit(contractAddress) {
    return await this.getContract(contractAddress, "split");
  }
  async getMarketplace(contractAddress) {
    return await this.getContract(contractAddress, "marketplace");
  }
  async getMarketplaceV3(contractAddress) {
    return await this.getContract(contractAddress, "marketplace-v3");
  }
  async getPack(contractAddress) {
    return await this.getContract(contractAddress, "pack");
  }
  async getMultiwrap(contractAddress) {
    return await this.getContract(contractAddress, "multiwrap");
  }
  async getContract(address, contractTypeOrABI) {
    const resolvedAddress = await resolveAddress(address);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    if (resolvedAddress in GENERATED_ABI) {
      return await this.getContractFromAbi(resolvedAddress, GENERATED_ABI[resolvedAddress]);
    }
    let newContract;
    if (!contractTypeOrABI || contractTypeOrABI === "custom") {
      try {
        const metadata = await this.getPublisher().fetchCompilerMetadataFromAddress(resolvedAddress);
        newContract = await this.getContractFromAbi(resolvedAddress, metadata.abi);
      } catch (e) {
        const resolvedContractType = await this.resolveContractType(resolvedAddress);
        if (resolvedContractType && resolvedContractType !== "custom") {
          const contractAbi = await PREBUILT_CONTRACTS_MAP[resolvedContractType].getAbi(resolvedAddress, this.getProvider(), this.storage);
          newContract = await this.getContractFromAbi(resolvedAddress, contractAbi);
        } else {
          throw e;
        }
      }
    } else if (typeof contractTypeOrABI === "string" && contractTypeOrABI in PREBUILT_CONTRACTS_MAP) {
      newContract = await PREBUILT_CONTRACTS_MAP[contractTypeOrABI].initialize(this.getSignerOrProvider(), resolvedAddress, this.storage, this.options);
    } else {
      newContract = await this.getContractFromAbi(resolvedAddress, contractTypeOrABI);
    }
    this.contractCache.set(resolvedAddress, newContract);
    return newContract;
  }
  async getBuiltInContract(address, contractType) {
    return await this.getContract(address, contractType);
  }
  async resolveContractType(contractAddress) {
    try {
      const IThirdwebContractABI = (await import("./IThirdwebContract-RPCG5J6Y.js")).default;
      const contract = new Contract(
        await resolveAddress(contractAddress),
        IThirdwebContractABI,
        this.getProvider()
      );
      const remoteContractType = utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
      return getContractTypeForRemoteName(remoteContractType);
    } catch (err) {
      return "custom";
    }
  }
  async getContractList(walletAddress) {
    const addresses = await (await this.deployer.getRegistry())?.getContractAddresses(await resolveAddress(walletAddress)) || [];
    const chainId = (await this.getProvider().getNetwork()).chainId;
    return await Promise.all(addresses.map(async (address) => {
      return {
        address,
        chainId,
        contractType: () => this.resolveContractType(address),
        metadata: async () => (await this.getContract(address)).metadata.get(),
        extensions: async () => getAllDetectedExtensionNames((await this.getContract(address)).abi)
      };
    }));
  }
  async getMultichainContractList(walletAddress) {
    let chains = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultChains;
    const contracts = await this.multiChainRegistry.getContractAddresses(walletAddress);
    const chainMap = chains.reduce((acc, chain) => {
      acc[chain.chainId] = chain;
      return acc;
    }, {});
    const sdkMap = {};
    return contracts.map((_ref) => {
      let {
        address,
        chainId
      } = _ref;
      if (!chainMap[chainId]) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({
            name: ""
          }),
          extensions: async () => []
        };
      }
      try {
        let chainSDK = sdkMap[chainId];
        if (!chainSDK) {
          chainSDK = new ThirdwebSDK(chainId, {
            ...this.options,
            readonlySettings: void 0,
            supportedChains: chains
          }, this.storage);
          sdkMap[chainId] = chainSDK;
        }
        return {
          address,
          chainId,
          contractType: () => chainSDK.resolveContractType(address),
          metadata: async () => (await chainSDK.getContract(address)).metadata.get(),
          extensions: async () => getAllDetectedExtensionNames((await chainSDK.getContract(address)).abi)
        };
      } catch (e) {
        return {
          address,
          chainId,
          contractType: async () => "custom",
          metadata: async () => ({
            name: ""
          }),
          extensions: async () => []
        };
      }
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this.wallet.connect(this.getSignerOrProvider());
    this.deployer.updateSignerOrProvider(this.getSignerOrProvider());
    this._publisher.updateSignerOrProvider(this.getSignerOrProvider());
    this.multiChainRegistry.updateSigner(this.getSignerOrProvider());
    this.verifier.updateSignerOrProvider(this.getSignerOrProvider());
    for (const [, contract] of this.contractCache) {
      contract.onNetworkUpdated(this.getSignerOrProvider());
    }
  }
  async getContractFromAbi(address, abi) {
    const [resolvedAddress, {
      SmartContract
    }] = await Promise.all([resolveAddress(address), import("./smart-contract-96faff43.browser.esm-CBK6JGJY.js")]);
    if (this.contractCache.has(resolvedAddress)) {
      return this.contractCache.get(resolvedAddress);
    }
    const [, provider] = getSignerAndProvider(this.getSignerOrProvider(), this.options);
    const parsedABI = typeof abi === "string" ? JSON.parse(abi) : abi;
    const contract = new SmartContract(this.getSignerOrProvider(), resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(parsedABI), provider, this.options, this.storage), this.storageHandler, this.options, (await provider.getNetwork()).chainId);
    this.contractCache.set(resolvedAddress, contract);
    return contract;
  }
  async getBalance(address) {
    return fetchCurrencyValue(this.getProvider(), NATIVE_TOKEN_ADDRESS, await this.getProvider().getBalance(await resolveAddress(address)));
  }
  getPublisher() {
    return this._publisher;
  }
};
function addChainToSupportedChains(network, options) {
  if (isChainConfig(network)) {
    options = {
      ...options,
      supportedChains: [network, ...options?.supportedChains || []]
    };
  }
  return options;
}
var THIRDWEB_DEPLOYER2 = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";
var ContractDeployer = class extends RPCConnectionHandler {
  constructor(network, options, storage) {
    super(network, options);
    __publicField(this, "transactionListener", (event) => {
      if (event.status === "submitted") {
        this.events.emit("contractDeployed", {
          status: "submitted",
          transactionHash: event.transactionHash
        });
      }
    });
    __publicField(this, "deployNFTCollection", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTCollectionInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployNFTDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(NFTDropInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployLoyaltyCard", buildDeployTransactionFunction(async (metadata, options) => {
      const parsedMetadata = await LoyaltyCardContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await this.getSigner()?.getAddress();
      const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points, parsedMetadata.platform_fee_basis_points, parsedMetadata.platform_fee_recipient];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "LoyaltyCard", deployArgs, "latest", options);
    }));
    __publicField(this, "deployOpenEdition", buildDeployTransactionFunction(async (metadata, options) => {
      const parsedMetadata = await DropErc721ContractSchema.deploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await this.getSigner()?.getAddress();
      const deployArgs = [signerAddress, parsedMetadata.name, parsedMetadata.symbol, contractURI, trustedForwarders, parsedMetadata.primary_sale_recipient, parsedMetadata.fee_recipient, parsedMetadata.seller_fee_basis_points];
      return await this.deployPublishedContract.prepare(THIRDWEB_DEPLOYER2, "OpenEditionERC721", deployArgs, "latest", options);
    }));
    __publicField(this, "deploySignatureDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SignatureDropInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployMultiwrap", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MultiwrapInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployEdition", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployEditionDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(EditionDropInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployToken", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployTokenDrop", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(TokenDropInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployMarketplace", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployMarketplaceV3", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(MarketplaceV3Initializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployPack", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(PackInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deploySplit", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(SplitInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployVote", buildDeployTransactionFunction(async (metadata, options) => {
      return await this.deployBuiltInContract.prepare(VoteInitializer.contractType, metadata, "latest", options);
    }));
    __publicField(this, "deployAirdropERC20", buildDeployTransactionFunction(async (metadata, options) => {
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await this.getSigner()?.getAddress();
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC20", deployArgs, "latest", options);
    }));
    __publicField(this, "deployAirdropERC721", buildDeployTransactionFunction(async (metadata, options) => {
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await this.getSigner()?.getAddress();
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC721", deployArgs, "latest", options);
    }));
    __publicField(this, "deployAirdropERC1155", buildDeployTransactionFunction(async (metadata, options) => {
      const parsedMetadata = await AirdropContractDeploy.parseAsync(metadata);
      const contractURI = await this.storage.upload(parsedMetadata);
      const trustedForwarders = [];
      if (metadata.trusted_forwarders && metadata.trusted_forwarders.length > 0) {
        trustedForwarders.push(...metadata.trusted_forwarders);
      }
      const signerAddress = await this.getSigner()?.getAddress();
      const deployArgs = [signerAddress, contractURI, trustedForwarders];
      return await this.deployReleasedContract.prepare(THIRDWEB_DEPLOYER2, "AirdropERC1155", deployArgs, "latest", options);
    }));
    __publicField(this, "deployBuiltInContract", buildDeployTransactionFunction((() => {
      var _this = this;
      return async function(contractType, contractMetadata) {
        let version = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "latest";
        let options = arguments.length > 3 ? arguments[3] : void 0;
        const signer = _this.getSigner();
        invariant(signer, "A signer is required to deploy contracts");
        const parsedMetadata = {
          app_uri: PREBUILT_CONTRACTS_APPURI_MAP[contractType],
          ...await PREBUILT_CONTRACTS_MAP[contractType].schema.deploy.parseAsync(contractMetadata)
        };
        if (_this.hasLocalFactory()) {
          let parsedVersion = void 0;
          try {
            parsedVersion = parseInt(version);
            if (isNaN(parsedVersion)) {
              parsedVersion = void 0;
            }
          } catch (e) {
            parsedVersion = void 0;
          }
          const factory = await _this.getFactory();
          if (!factory) {
            throw new Error("Factory not found");
          }
          factory.on(EventType.Transaction, _this.transactionListener);
          return factory.deploy.prepare(contractType, parsedMetadata, _this.events, parsedVersion, options, () => {
            factory.off(EventType.Transaction, _this.transactionListener);
          });
        }
        const contractName = getContractName(contractType);
        invariant(contractName, "Contract name not found");
        const contractURI = await _this.storage.upload(parsedMetadata);
        const constructorParams = await getDeployArguments(contractType, parsedMetadata, contractURI, signer);
        const publishedContract = await _this.fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER2, contractName, version);
        return _this.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
      };
    })()));
    __publicField(this, "deployReleasedContract", buildDeployTransactionFunction((() => {
      var _this2 = this;
      return async function(publisherAddress, contractName, constructorParams) {
        let version = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
        let options = arguments.length > 4 ? arguments[4] : void 0;
        const publishedContract = await _this2.fetchPublishedContractFromPolygon(publisherAddress, contractName, version);
        return await _this2.deployContractFromUri.prepare(publishedContract.metadataUri, constructorParams, options);
      };
    })()));
    __publicField(this, "deployPublishedContract", this.deployReleasedContract);
    __publicField(this, "deployViaFactory", buildTransactionFunction(async (factoryAddress, implementationAddress, implementationAbi, initializerFunction, initializerArgs, saltForProxyDeploy) => {
      const resolvedFactoryAddress = await resolveAddress(factoryAddress);
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const signer = this.getSigner();
      invariant(signer, "signer is required");
      const proxyFactory = new ContractFactory2(resolvedFactoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      proxyFactory.on(EventType.Transaction, this.transactionListener);
      return await proxyFactory.deployProxyByImplementation.prepare(resolvedImplementationAddress, implementationAbi, initializerFunction, initializerArgs, this.events, saltForProxyDeploy, () => {
        proxyFactory.off(EventType.Transaction, this.transactionListener);
      });
    }));
    __publicField(this, "deployProxy", buildDeployTransactionFunction(async (implementationAddress, implementationAbi, initializerFunction, initializerArgs) => {
      const resolvedAddress = await resolveAddress(implementationAddress);
      const encodedInitializer = Contract.getInterface(implementationAbi).encodeFunctionData(initializerFunction, initializerArgs);
      const {
        TWProxy__factory
      } = await import("./thirdweb-dev-contracts-js-factories-TWProxy__factory.esm-IQINVPEN.js");
      return this.deployContractWithAbi.prepare(TWProxy__factory.abi, TWProxy__factory.bytecode, [resolvedAddress, encodedInitializer]);
    }));
    __publicField(this, "deployViaAutoFactory", buildDeployTransactionFunction(async (publishMetadataUri, deployMetadata, signer, initializerFunction, paramValues, options) => {
      const create2Factory = await deployCreate2Factory(signer, options);
      const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2Factory, this.options.clientId, this.options.secretKey);
      const implementationAddress = deploymentInfo.find((i) => i.type === "implementation")?.transaction.predictedAddress;
      const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
      const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
        return i.type !== "infra";
      }).map((i) => i.transaction);
      const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
        return i.type === "infra";
      }).map((i) => i.transaction);
      await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, options);
      for (const tx of transactionsforDirectDeploy) {
        try {
          await deployContractDeterministic(signer, tx, options);
        } catch (e) {
          console.debug(`Error deploying contract at ${tx.predictedAddress}`, e?.message);
          throw e;
        }
      }
      const resolvedImplementationAddress = await resolveAddress(implementationAddress);
      const cloneFactory = await computeCloneFactoryAddress(this.getProvider(), this.storage, create2Factory, this.options.clientId, this.options.secretKey);
      options?.notifier?.("deploying", "proxy");
      const proxyDeployTransaction = await this.deployViaFactory.prepare(cloneFactory, resolvedImplementationAddress, deployMetadata.compilerMetadata.abi, initializerFunction, paramValues, options?.saltForProxyDeploy);
      options?.notifier?.("deployed", "proxy");
      return proxyDeployTransaction;
    }));
    __publicField(this, "deployViaCustomFactory", buildDeployTransactionFunction(async (constructorParamValues, deployMetadata, signer, chainId) => {
      const customFactoryAddress = deployMetadata.extendedMetadata?.factoryDeploymentData?.customFactoryInput?.customFactoryAddresses[chainId];
      const resolvedCustomFactoryAddress = await resolveAddress(customFactoryAddress);
      invariant(resolvedCustomFactoryAddress, `customFactoryAddress not found for chainId '${chainId}'`);
      invariant(deployMetadata.extendedMetadata?.factoryDeploymentData?.customFactoryInput?.factoryFunction, `customFactoryFunction not set'`);
      const customFactoryMetadata = await fetchContractMetadataFromAddress(resolvedCustomFactoryAddress, this.getProvider(), this.storage, this.options);
      const factoryFunctionParamTypes = extractFunctionParamsFromAbi(customFactoryMetadata.abi, deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction).map((p) => p.type);
      const factoryFunctionparamValues = convertParamValues(factoryFunctionParamTypes, constructorParamValues);
      let deployedImplementationAddress;
      const deployTransaction = await Transaction.fromContractInfo({
        contractAddress: resolvedCustomFactoryAddress,
        contractAbi: customFactoryMetadata.abi,
        provider: this.getProvider(),
        signer,
        method: deployMetadata.extendedMetadata.factoryDeploymentData.customFactoryInput.factoryFunction,
        args: factoryFunctionparamValues,
        parse: () => {
          return deployedImplementationAddress;
        },
        storage: this.storage
      });
      deployedImplementationAddress = await deployTransaction.simulate();
      return deployTransaction;
    }));
    __publicField(this, "deployContractFromUri", buildDeployTransactionFunction(async (publishMetadataUri, constructorParamValues, options) => {
      const signer = this.getSigner();
      invariant(signer, "A signer is required");
      const {
        compilerMetadata,
        extendedMetadata
      } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
      const forceDirectDeploy = options?.forceDirectDeploy || false;
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const isNetworkEnabled = extendedMetadata?.networksForDeployment?.networksEnabled.includes(chainId) || extendedMetadata?.networksForDeployment?.allNetworks;
      if (extendedMetadata?.networksForDeployment && !isNetworkEnabled && compilerMetadata.name !== "AccountFactory") {
        throw new Error(`Deployments disabled on this network, with chainId: ${chainId}`);
      }
      if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType && extendedMetadata.deployType !== "standard") && !forceDirectDeploy) {
        if (extendedMetadata.deployType === "customFactory") {
          return await this.deployViaCustomFactory.prepare(constructorParamValues, {
            compilerMetadata,
            extendedMetadata
          }, signer, chainId);
        } else {
          invariant(extendedMetadata.factoryDeploymentData.implementationInitializerFunction, `implementationInitializerFunction not set'`);
          const initializerParamTypes = extractFunctionParamsFromAbi(compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction).map((p) => p.type);
          const paramValues2 = convertParamValues(initializerParamTypes, constructorParamValues);
          const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
          if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
            return await this.deployViaAutoFactory.prepare(publishMetadataUri, {
              compilerMetadata,
              extendedMetadata
            }, signer, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options);
          }
          const resolvedImplementationAddress = await resolveAddress(implementationAddress);
          invariant(resolvedImplementationAddress, `implementationAddress not found for chainId '${chainId}'`);
          if (extendedMetadata.isDeployableViaFactory) {
            invariant(extendedMetadata.factoryDeploymentData.factoryAddresses, "isDeployableViaFactory is true so factoryAddresses is required");
            const factoryAddress = extendedMetadata.factoryDeploymentData.factoryAddresses[chainId];
            invariant(factoryAddress, `isDeployableViaFactory is true and factoryAddress not found for chainId '${chainId}'`);
            const resolvedFactoryAddress = await resolveAddress(factoryAddress);
            return await this.deployViaFactory.prepare(resolvedFactoryAddress, resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2, options?.saltForProxyDeploy);
          } else if (extendedMetadata.isDeployableViaProxy) {
            return await this.deployProxy.prepare(resolvedImplementationAddress, compilerMetadata.abi, extendedMetadata.factoryDeploymentData.implementationInitializerFunction, paramValues2);
          }
        }
      }
      const bytecode = compilerMetadata.bytecode.startsWith("0x") ? compilerMetadata.bytecode : `0x${compilerMetadata.bytecode}`;
      if (!utils_exports.isHexString(bytecode)) {
        throw new Error(`Contract bytecode is invalid.

${bytecode}`);
      }
      const constructorParamTypes = extractConstructorParamsFromAbi(compilerMetadata.abi).map((p) => p.type);
      const paramValues = convertParamValues(constructorParamTypes, constructorParamValues);
      return this.deployContractWithAbi.prepare(compilerMetadata.abi, bytecode, paramValues);
    }));
    __publicField(this, "deployContractWithAbi", buildDeployTransactionFunction(async (abi, bytecode, constructorParams) => {
      const signer = this.getSigner();
      const provider = this.getProvider();
      invariant(signer, "Signer is required to deploy contracts");
      const factory = new ContractFactory(abi, bytecode).connect(signer);
      return new DeployTransaction({
        args: constructorParams,
        provider,
        signer,
        factory,
        storage: this.storage,
        events: this.events
      });
    }));
    this.storage = storage;
    this.events = new eventemitter3_default();
    this.getFactory();
    this.getRegistry();
  }
  async getLatestBuiltInContractVersion(contractType) {
    const factory = await this.getFactory();
    if (!factory) {
      throw new Error("Factory not found");
    }
    return await factory.getLatestVersion(contractType);
  }
  async deployPublishedContractDeterministic(contractName, constructorParams) {
    let publisherAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : THIRDWEB_DEPLOYER2;
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let saltForCreate2 = arguments.length > 4 ? arguments[4] : void 0;
    const signer = this.getSigner();
    invariant(signer, "Signer is required");
    return directDeployDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, signer, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);
  }
  async predictAddressDeterministic(contractName, constructorParams) {
    let publisherAddress = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : THIRDWEB_DEPLOYER2;
    let contractVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "latest";
    let saltForCreate2 = arguments.length > 4 ? arguments[4] : void 0;
    const provider = this.getProvider();
    invariant(provider, "Provider is required");
    return predictAddressDeterministicPublished(contractName, publisherAddress, contractVersion, constructorParams, provider, this.storage, this.options.clientId, this.options.secretKey, saltForCreate2);
  }
  async getRegistry() {
    if (this._registry) {
      return this._registry;
    }
    return this._registry = this.getProvider().getNetwork().then(async (_ref2) => {
      let {
        chainId
      } = _ref2;
      const registryAddress = getContractAddressByChainId(chainId, "twRegistry");
      if (!registryAddress) {
        return void 0;
      }
      const TWRegistryABI = (await import("./TWRegistry-KJ2K37LL.js")).default;
      return new ContractRegistry(registryAddress, this.getSignerOrProvider(), this.storage, TWRegistryABI, this.options);
    });
  }
  async getFactory() {
    if (this._factory) {
      return this._factory;
    }
    return this._factory = this.getProvider().getNetwork().then(async (_ref3) => {
      let {
        chainId
      } = _ref3;
      const factoryAddress = getContractAddressByChainId(chainId, "twFactory");
      if (!factoryAddress) {
        return void 0;
      }
      const factory = new ContractFactory2(factoryAddress, this.getSignerOrProvider(), this.storage, this.options);
      return factory;
    });
  }
  updateSignerOrProvider(network) {
    super.updateSignerOrProvider(network);
    this.updateContractSignerOrProvider();
  }
  updateContractSignerOrProvider() {
    this._factory?.then((factory) => {
      factory?.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
    this._registry?.then((registry) => {
      registry?.updateSignerOrProvider(this.getSignerOrProvider());
    }).catch(() => {
    });
  }
  async getTransactionsForDeploy(publishMetadataUri, options) {
    let transactions = [];
    const provider = this.getProvider();
    invariant(provider, "A provider is required");
    const {
      extendedMetadata
    } = await fetchAndCacheDeployMetadata(publishMetadataUri, this.storage);
    const forceDirectDeploy = options?.forceDirectDeploy || false;
    if (extendedMetadata && extendedMetadata.factoryDeploymentData && (extendedMetadata.isDeployableViaProxy || extendedMetadata.isDeployableViaFactory || extendedMetadata.deployType === "autoFactory") && !forceDirectDeploy) {
      const chainId = (await this.getProvider().getNetwork()).chainId;
      const implementationAddress = extendedMetadata.factoryDeploymentData.implementationAddresses[chainId];
      if (!implementationAddress || extendedMetadata.deployType === "autoFactory") {
        const create2FactoryAddress = await getCreate2FactoryAddress(this.getProvider());
        transactions.push({
          contractType: "create2Factory",
          addresses: [create2FactoryAddress]
        });
        const deploymentInfo = await getDeploymentInfo(publishMetadataUri, this.storage, this.getProvider(), create2FactoryAddress, this.options.clientId, this.options.secretKey);
        const transactionsToSend = deploymentInfo.filter((i) => i.transaction.data && i.transaction.data.length > 0);
        const transactionsforDirectDeploy = transactionsToSend.filter((i) => {
          return i.type !== "infra";
        }).map((i) => i.transaction);
        transactionsforDirectDeploy.forEach((tx) => {
          transactions.push({
            contractType: "preset",
            addresses: [tx.predictedAddress]
          });
        });
        const transactionsForThrowawayDeployer = transactionsToSend.filter((i) => {
          return i.type === "infra";
        }).map((i) => i.transaction);
        const transactionBatches = createTransactionBatches(transactionsForThrowawayDeployer);
        transactionBatches.forEach((batch) => {
          const addresses = batch.map((tx) => tx.predictedAddress);
          transactions.push({
            contractType: "infra",
            addresses
          });
        });
      }
      transactions = (await Promise.all(transactions.map(async (tx) => {
        const addresses = (await Promise.all(tx.addresses.map(async (address) => {
          const isDeployed = await isContractDeployed(address, provider);
          return isDeployed ? null : address;
        }))).filter(Boolean);
        return addresses.length > 0 ? tx : null;
      }))).filter(Boolean);
      transactions.push({
        contractType: "proxy",
        addresses: []
      });
    } else {
      transactions.push({
        contractType: "custom",
        addresses: []
      });
    }
    return transactions;
  }
  addDeployListener(listener) {
    this.events.on("contractDeployed", listener);
  }
  removeDeployListener(listener) {
    this.events.off("contractDeployed", listener);
  }
  removeAllDeployListeners() {
    this.events.removeAllListeners("contractDeployed");
  }
  async fetchPublishedContractFromPolygon(publisherAddress, contractName, version) {
    const address = await resolveAddress(publisherAddress);
    const publishedContract = await new ThirdwebSDK("polygon", {
      clientId: this.options.clientId,
      secretKey: this.options.secretKey
    }, this.storage).getPublisher().getVersion(address, contractName, version);
    if (!publishedContract) {
      throw new Error(`No published contract found for '${contractName}' at version '${version}' by '${address}'`);
    }
    return publishedContract;
  }
  hasLocalFactory() {
    return !!getProcessEnv("factoryAddress");
  }
};

// node_modules/@thirdweb-dev/sdk/dist/getStatus-48f06258.browser.esm.js
init_shim();
init_lib();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/exports/thirdweb.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/client/client.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/client-id.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/hashing/sha256.js
init_shim();
function sha2562(value, to) {
  const bytes2 = sha256(isHex(value, { strict: false }) ? hexToUint8Array(value) : value);
  if (to === "bytes") {
    return bytes2;
  }
  return uint8ArrayToHex(bytes2);
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/client-id.js
var cache = new LruMap(4096);
function computeClientIdFromSecretKey(secretKey) {
  if (cache.has(secretKey)) {
    return cache.get(secretKey);
  }
  const cId = sha2562(stringToBytes(secretKey)).slice(2, 34);
  cache.set(secretKey, cId);
  return cId;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/client/client.js
function createThirdwebClient(options) {
  const { clientId, secretKey, ...rest } = options;
  if (secretKey) {
    return {
      ...rest,
      clientId: computeClientIdFromSecretKey(secretKey),
      secretKey
    };
  }
  if (clientId) {
    return {
      ...rest,
      clientId: options.clientId,
      secretKey: void 0
    };
  }
  throw new Error("clientId or secretKey must be provided");
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_gasPrice.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getBalance.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByHash.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByNumber.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getLogs.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getStorageAt.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_getTransactionByHash.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_maxPriorityFeePerGas.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/rpc/actions/eth_sendRawTransaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/prepare-transaction.js
init_shim();
function prepareTransaction(options, info) {
  if (info) {
    options.__preparedMethod = info.preparedMethod;
    options.__contract = info.contract;
  }
  return options;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/types.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/prepare-contract-call.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/promise/resolve-promised-value.js
init_shim();
async function resolvePromisedValue(value) {
  return typeof value === "function" ? await value() : value;
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/prepare-contract-call.js
function prepareContractCall(options) {
  const { contract, method, params, ...rest } = options;
  const preparedMethodPromise = () => (async () => {
    if (Array.isArray(method)) {
      return method;
    }
    if (isAbiFunction(method)) {
      return prepareMethod(method);
    }
    if (typeof method === "function") {
      return prepareMethod(
        await method(contract)
      );
    }
    if (typeof method === "string" && method.startsWith("function ")) {
      const abiItem = parseAbiItem(method);
      if (abiItem.type === "function") {
        return prepareMethod(abiItem);
      }
      throw new Error(`"method" passed is not of type "function"`);
    }
    if (contract.abi && contract.abi?.length > 0) {
      const abiFunction = contract.abi?.find((item) => item.type === "function" && item.name === method);
      if (abiFunction) {
        return prepareMethod(abiFunction);
      }
    }
    throw new Error(`Could not resolve method "${method}".`);
  })();
  return prepareTransaction({
    ...rest,
    to: contract.address,
    chain: contract.chain,
    client: contract.client,
    data: async () => {
      let preparedM;
      if (Array.isArray(method)) {
        preparedM = method;
      } else {
        preparedM = await preparedMethodPromise();
      }
      if (preparedM[1].length === 0) {
        return preparedM[0];
      }
      return preparedM[0] + encodeAbiParameters(
        preparedM[1],
        await resolvePromisedValue(params ?? [])
      ).slice(2);
    }
  }, {
    preparedMethod: preparedMethodPromise,
    contract
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/resolve-method.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/contract/actions/resolve-abi.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/download.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/ipfs.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/extractIPFS.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/base58/encode.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/base58/alphabet.js
init_shim();
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/base58/encode.js
var BASE = ALPHABET.length;
var LEADER = (() => ALPHABET.charAt(0))();
var iFACTOR = (() => Math.log(256) / Math.log(BASE))();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/cbor-decode.js
init_shim();
var src;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentDecoder = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var packedValues;
var dataView;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var Decoder = class {
  constructor() {
    Object.assign(this, defaultOptions);
  }
  decodeKey(key) {
    return key;
  }
  decode(source, end = -1) {
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error(`Source must be a Uint8Array or Buffer but was a ${source && typeof source === "object" ? source.constructor.name : typeof source}`);
    }
    if (this instanceof Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
};
function checkedRead() {
  try {
    const result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        const error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position === srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position > srcEnd) {
      const error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  const majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position++];
        break;
      default:
        throw new Error(`Unknown token ${token}`);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {
        const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string !== null) {
          return string;
        }
      }
      return readFixedString(token);
    case 4: {
      const array = new Array(token);
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      return array;
    }
    case 5: {
      const object = {};
      for (let i = 0; i < token; i++) {
        object[safeKey(read())] = read();
      }
      return object;
    }
    default:
      if (Number.isNaN(token)) {
        const error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error(`Unknown CBOR token ${token}`);
  }
}
function safeKey(key) {
  if (typeof key === "string") {
    return key === "__proto__" ? "__proto_" : key;
  }
  if (typeof key !== "object") {
    return key.toString();
  }
  throw new Error(`Invalid property name type ${typeof key}`);
}
var fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  const start = position;
  const bytes2 = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start;
      return;
    }
    bytes2[i] = byte;
  }
  return fromCharCode.apply(String, bytes2);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) {
        return "";
      }
      const a3 = src[position++];
      if ((a3 & 128) > 1) {
        position -= 1;
        return;
      }
      return fromCharCode(a3);
    }
    const a2 = src[position++];
    const b2 = src[position++];
    if ((a2 & 128) > 0 || (b2 & 128) > 0) {
      position -= 2;
      return;
    }
    if (length < 3) {
      return fromCharCode(a2, b2);
    }
    const c2 = src[position++];
    if ((c2 & 128) > 0) {
      position -= 3;
      return;
    }
    return fromCharCode(a2, b2, c2);
  }
  const a = src[position++];
  const b = src[position++];
  const c = src[position++];
  const d = src[position++];
  if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
    position -= 4;
    return;
  }
  if (length < 6) {
    if (length === 4) {
      return fromCharCode(a, b, c, d);
    }
    const e2 = src[position++];
    if ((e2 & 128) > 0) {
      position -= 5;
      return;
    }
    return fromCharCode(a, b, c, d, e2);
  }
  if (length < 8) {
    const e2 = src[position++];
    const f2 = src[position++];
    if ((e2 & 128) > 0 || (f2 & 128) > 0) {
      position -= 6;
      return;
    }
    if (length < 7) {
      return fromCharCode(a, b, c, d, e2, f2);
    }
    const g2 = src[position++];
    if ((g2 & 128) > 0) {
      position -= 7;
      return;
    }
    return fromCharCode(a, b, c, d, e2, f2, g2);
  }
  const e = src[position++];
  const f = src[position++];
  const g = src[position++];
  const h = src[position++];
  if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
    position -= 8;
    return;
  }
  if (length < 10) {
    if (length === 8) {
      return fromCharCode(a, b, c, d, e, f, g, h);
    }
    const i2 = src[position++];
    if ((i2 & 128) > 0) {
      position -= 9;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i2);
  }
  if (length < 12) {
    const i2 = src[position++];
    const j2 = src[position++];
    if ((i2 & 128) > 0 || (j2 & 128) > 0) {
      position -= 10;
      return;
    }
    if (length < 11) {
      return fromCharCode(a, b, c, d, e, f, g, h, i2, j2);
    }
    const k2 = src[position++];
    if ((k2 & 128) > 0) {
      position -= 11;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i2, j2, k2);
  }
  const i = src[position++];
  const j = src[position++];
  const k = src[position++];
  const l = src[position++];
  if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
    position -= 12;
    return;
  }
  if (length < 14) {
    if (length === 12) {
      return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
    }
    const m2 = src[position++];
    if ((m2 & 128) > 0) {
      position -= 13;
      return;
    }
    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m2);
  }
  const m = src[position++];
  const n = src[position++];
  if ((m & 128) > 0 || (n & 128) > 0) {
    position -= 14;
    return;
  }
  if (length < 15) {
    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
  }
  const o = src[position++];
  if ((o & 128) > 0) {
    position -= 15;
    return;
  }
  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
}
function readBin(length) {
  return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);
}
var glbl = { Error, RegExp };
currentExtensions[27] = (data) => {
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
var packedTable = (read_) => {
  if (src[position++] !== 132) {
    const error = new Error("Packed values structure must be followed by a 4 element array");
    if (src.length < position) {
      error.incomplete = true;
    }
    throw error;
  }
  const newPackedValues = read_();
  if (!newPackedValues || !newPackedValues.length) {
    const error = new Error("Packed values structure must be followed by a 4 element array");
    error.incomplete = true;
    throw error;
  }
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = read_();
  packedValues.suffixes = read_();
  return read_();
};
packedTable.handlesRead = true;
currentExtensions[28] = (read_) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  const id = referenceMap.id++;
  const token = src[position];
  let target;
  if (token >> 5 === 4) {
    target = [];
  } else {
    target = {};
  }
  const refEntry = { target };
  referenceMap.set(id, refEntry);
  const targetProperties = read_();
  if (refEntry.used) {
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties;
  return targetProperties;
};
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = (() => Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();
}
var defaultDecoder = new Decoder();
var decode = defaultDecoder.decode;

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/prefix.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/estimate-gas.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/gas/op-gas-fee-reducer.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/extract-error.js
init_shim();
var __DEV__ = import_process.default.env.NODE_ENV !== "production";

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/send-transaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/to-serializable-transaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/gas/fee-data.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/units.js
init_shim();
function toUnits(tokens, decimals) {
  let [integerPart, fractionPart = ""] = tokens.split(".");
  const prefix = integerPart.startsWith("-") ? "-" : "";
  if (prefix) {
    integerPart = integerPart.slice(1);
  }
  fractionPart = fractionPart.padEnd(decimals, "0");
  if (decimals === 0) {
    if (fractionPart[0] && Number.parseInt(fractionPart[0]) >= 5) {
      integerPart = (BigInt(integerPart) + 1n).toString();
    }
    fractionPart = "";
  } else {
    if (fractionPart.length > decimals) {
      const roundingDigit = fractionPart[decimals];
      if (roundingDigit && Number.parseInt(roundingDigit, 10) >= 5) {
        const roundedFraction = BigInt(fractionPart.substring(0, decimals)) + 1n;
        fractionPart = roundedFraction.toString().padStart(decimals, "0");
        if (fractionPart.length > decimals) {
          integerPart = (BigInt(integerPart) + 1n).toString();
          fractionPart = fractionPart.substring(fractionPart.length - decimals);
        }
      } else {
        fractionPart = fractionPart.substring(0, decimals);
      }
    }
  }
  return BigInt(`${prefix}${integerPart}${fractionPart}`);
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/gas/get-gas-price.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/send-and-confirm-transaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/send-batch-transaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/simulate.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/sign.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/secp256k1.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/modular.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  abytes: () => abytes,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  isBytes: () => isBytes,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes,
  validateObject: () => validateObject
});
init_shim();
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  abytes(bytes2);
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes2(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number, modulo) {
  if (number === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
  }
  let a = mod(number, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/weierstrass.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/curve.js
init_shim();
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window = 0; window < windows; window++) {
        const offset = window * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports2;
var DER = {
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    abytes(data);
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes2 = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes2(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z2);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z2, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number) {
    const HALF = CURVE_ORDER >> _1n4;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify2(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN2(h * is);
    const u2 = modN2(r * is);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify: verify2,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n3 === _0n4; o /= _2n3)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n3;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n4) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n4; i--) {
      let tv52 = i - _2n3;
      tv52 = _2n3 << tv52 - _1n4;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid);
    y = Fp2.cmov(y, value, isValid);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    x = Fp2.div(x, tv4);
    return { x, y };
  };
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
init_shim();
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash2, expand, DST: _DST } = options;
  abytes(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes(_DST) : _DST;
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/_shortw_utils.js
init_shim();

// node_modules/@noble/hashes/esm/hmac.js
init_shim();
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/@thirdweb-dev/sdk/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
  ],
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
  ]
].map((i) => i.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/trim.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/prepare-event.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/utils.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/actions/get-events.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/actions/parse-logs.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/event/actions/watch-events.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getQuote.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/write/approve.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/approve.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/promise/once.js
init_shim();
function once(fn) {
  let result;
  return () => {
    if (!result) {
      result = fn();
    }
    return result;
  };
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/approve.js
var FN_SELECTOR = "0x095ea7b3";
var FN_INPUTS = [
  {
    type: "address",
    name: "spender"
  },
  {
    type: "uint256",
    name: "value"
  }
];
var FN_OUTPUTS = [
  {
    type: "bool"
  }
];
function approve(options) {
  const asyncOptions = once(async () => {
    return "asyncParams" in options ? await options.asyncParams() : options;
  });
  return prepareContractCall({
    contract: options.contract,
    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS],
    params: async () => {
      const resolvedOptions = await asyncOptions();
      return [resolvedOptions.spender, resolvedOptions.value];
    },
    value: async () => (await asyncOptions()).overrides?.value,
    accessList: async () => (await asyncOptions()).overrides?.accessList,
    gas: async () => (await asyncOptions()).overrides?.gas,
    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,
    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,
    maxPriorityFeePerGas: async () => (await asyncOptions()).overrides?.maxPriorityFeePerGas,
    nonce: async () => (await asyncOptions()).overrides?.nonce,
    extraGas: async () => (await asyncOptions()).overrides?.extraGas
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/extensions/erc20/write/approve.js
function approve2(options) {
  return approve({
    contract: options.contract,
    asyncParams: async () => {
      let amount;
      if ("amount" in options) {
        const { decimals } = await import("./decimals-XYQWEPWD.js");
        const d = await decimals(options).catch(() => 18);
        amount = toUnits(options.amount.toString(), d);
      } else {
        amount = options.amountWei;
      }
      return {
        spender: options.spender,
        value: amount
      };
    }
  });
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/utils/definitions.js
init_shim();
var getPayBuyWithCryptoStatusUrl = () => `https://${getThirdwebDomains().pay}/buy-with-crypto/status/v1`;
var getPayBuyWithCryptoQuoteEndpoint = () => `https://${getThirdwebDomains().pay}/buy-with-crypto/quote/v1`;
var getPayBuyWithCryptoHistoryEndpoint = () => `https://${getThirdwebDomains().pay}/buy-with-crypto/history/v1`;

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getQuote.js
async function getBuyWithCryptoQuote(params) {
  try {
    const queryParams = new URLSearchParams({
      fromAddress: params.fromAddress,
      fromChainId: params.fromChainId.toString(),
      fromTokenAddress: params.fromTokenAddress.toLowerCase(),
      toChainId: params.toChainId.toString(),
      toTokenAddress: params.toTokenAddress.toLowerCase()
    });
    if ("fromAmount" in params && params.fromAmount) {
      queryParams.append("fromAmount", params.fromAmount);
    }
    if ("toAmount" in params && params.toAmount) {
      queryParams.append("toAmount", params.toAmount);
    }
    if (params.maxSlippageBPS) {
      queryParams.append("maxSlippageBPS", params.maxSlippageBPS.toString());
    }
    if (params.intentId) {
      queryParams.append("intentId", params.intentId);
    }
    const queryString = queryParams.toString();
    const url = `${getPayBuyWithCryptoQuoteEndpoint()}?${queryString}`;
    const response = await getClientFetch(params.client)(url);
    if (!response.ok) {
      const errorObj = await response.json();
      if (errorObj && "error" in errorObj && typeof errorObj.error === "object" && "message" in errorObj.error) {
        throw new Error(errorObj.error.message);
      }
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    const swapRoute = {
      transactionRequest: {
        chain: getCachedChain(data.transactionRequest.chainId),
        client: params.client,
        data: data.transactionRequest.data,
        to: data.transactionRequest.to,
        value: BigInt(data.transactionRequest.value),
        gas: BigInt(data.transactionRequest.gasLimit),
        gasPrice: BigInt(data.transactionRequest.gasPrice)
      },
      approval: data.approval ? approve2({
        contract: getContract({
          client: params.client,
          address: data.approval.tokenAddress,
          chain: getCachedChain(data.approval.chainId)
        }),
        spender: data.approval?.spenderAddress,
        amountWei: BigInt(data.approval.amountWei)
      }) : void 0,
      swapDetails: {
        fromAddress: data.fromAddress,
        toAddress: data.toAddress,
        fromToken: data.fromToken,
        toToken: data.toToken,
        fromAmount: data.fromAmount,
        fromAmountWei: data.fromAmountWei,
        toAmountMinWei: data.toAmountMinWei,
        toAmountMin: data.toAmountMin,
        toAmountWei: data.toAmountWei,
        toAmount: data.toAmount,
        estimated: data.estimated,
        maxSlippageBPS: data.maxSlippageBPS
      },
      paymentTokens: data.paymentTokens,
      processingFees: data.processingFees,
      client: params.client
    };
    return swapRoute;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getStatus.js
init_shim();
async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
  try {
    if (!buyWithCryptoTransaction.transactionHash) {
      throw new Error("Transaction hash is required");
    }
    const queryString = new URLSearchParams({
      transactionHash: buyWithCryptoTransaction.transactionHash
    }).toString();
    const url = `${getPayBuyWithCryptoStatusUrl()}?${queryString}`;
    const response = await getClientFetch(buyWithCryptoTransaction.client)(url);
    if (!response.ok) {
      response.body?.cancel();
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    return data;
  } catch (error) {
    console.error("Fetch error:", error);
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getHistory.js
init_shim();
async function getBuyWithCryptoHistory(params) {
  try {
    const queryParams = new URLSearchParams();
    queryParams.append("walletAddress", params.walletAddress);
    queryParams.append("start", params.start.toString());
    queryParams.append("count", params.count.toString());
    const queryString = queryParams.toString();
    const url = `${getPayBuyWithCryptoHistoryEndpoint()}?${queryString}`;
    const response = await getClientFetch(params.client)(url);
    if (!response.ok) {
      response.body?.cancel();
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = (await response.json()).result;
    return data;
  } catch (error) {
    throw new Error(`Fetch failed: ${error}`);
  }
}

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/helpers/concat-hex.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/encoding/from-bytes.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/exports/pay.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getQuote.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getStatus.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getHistory.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/getPostOnRampQuote.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/getBuyHistory.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/pay/buyWithFiat/isSwapRequiredPostOnramp.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/exports/utils.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/extractMnimalProxyImplementationAddress.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/is-contract-deployed.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/bytecode/resolveImplementation.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/contract/deployment/utils/create-2-factory.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/is-eip155-enforced.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/keyless-transaction.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/contract/deployment/utils/create-2-factory.js
var CUSTOM_GAS_FOR_CHAIN = {
  "5001": {
    name: "Mantle Testnet",
    gasPrice: 1n
  },
  "71402": {
    name: "Godwoken Mainnet",
    gasPrice: 40000n * 10n ** 9n
  },
  "1351057110": {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 100000n
  },
  "361": {
    name: "Theta Mainnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "365": {
    name: "Theta Testnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "7700": {
    name: "Canto",
    gasPrice: 1000n * 10n ** 9n
  },
  "7701": {
    name: "Canto Testnet",
    gasPrice: 1000n * 10n ** 9n
  },
  "338": {
    name: "Cronos Testnet",
    gasPrice: 2000n * 10n ** 9n
  },
  "199": {
    name: "BitTorrent Chain",
    gasPrice: 300000n * 10n ** 9n
  },
  "88882": {
    name: "Spicy Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  },
  "88888": {
    name: "Chiliz Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  }
};
var CUSTOM_GAS_BINS = [
  1n,
  1n * 10n ** 9n,
  100n * 10n ** 9n,
  500n * 10n ** 9n,
  1000n * 10n ** 9n,
  2500n * 10n ** 9n,
  5000n * 10n ** 9n,
  7500n * 10n ** 9n,
  10000n * 10n ** 9n,
  25000n * 10n ** 9n,
  50000n * 10n ** 9n,
  75000n * 10n ** 9n,
  100000n * 10n ** 9n,
  250000n * 10n ** 9n,
  500000n * 10n ** 9n,
  750000n * 10n ** 9n,
  1000000n * 10n ** 9n
];

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/compute-deployment-address.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/get-salt-hash.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/keccak-id.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/any-evm/get-init-bytecode-with-salt.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/resolve-signature.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/signature-to-hex.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/hashing/hashMessage.js
init_shim();

// node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
init_shim();

// node_modules/@thirdweb-dev/sdk/dist/getStatus-48f06258.browser.esm.js
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}
function toUnits2(amount, decimals) {
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
function toDisplayValue(amount, decimals) {
  return utils_exports.formatUnits(amount, decimals);
}
async function computeNativeTokenAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  }, clientId, secretKey)).transaction.predictedAddress;
}
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    const tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return void 0;
}
var ProposalState = function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
  return ProposalState2;
}({});
var PropertiesInput = (() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();
var OptionalPropertiesInput = (() => z.union([z.array(PropertiesInput), PropertiesInput]).optional())();
var EditionMetadataOutputSchema = (() => z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
}))();
var EditionMetadataWithOwnerOutputSchema = (() => EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
}))();
var EditionMetadataInputSchema = (() => z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
}))();
var EditionMetadataInputOrUriSchema = (() => z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
}))();
var TokenMintInputSchema = (() => z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
}))();
async function getBuyWithCryptoHistory2(params) {
  let client;
  if (params.secretKey) {
    client = createThirdwebClient({
      secretKey: params.secretKey
    });
  }
  if (params.clientId) {
    client = createThirdwebClient({
      clientId: params.clientId
    });
  }
  if (!client) {
    throw new Error("You must provide either a `clientId` or a `secretKey` to get a quote");
  }
  return getBuyWithCryptoHistory({
    ...params,
    client
  });
}
async function getBuyWithCryptoQuote2(params) {
  let client;
  if (params.secretKey) {
    client = createThirdwebClient({
      secretKey: params.secretKey
    });
  }
  if (params.clientId) {
    client = createThirdwebClient({
      clientId: params.clientId
    });
  }
  if (!client) {
    throw new Error("You must provide either a `clientId` or a `secretKey` to get a quote");
  }
  const data = await getBuyWithCryptoQuote({
    ...params,
    client
  });
  const sendTxn = prepareTransaction(data.transactionRequest);
  const approvalTxn = data.approval ? prepareTransaction(data.approval) : void 0;
  const [sendTxnTo, sendTxnData, sendTxnGasPrice, sendTxnGasLimit, sendTxnNonce, sendTxnValue, approvalTxnTo, approvalTxnData, approvalTxnGasLimit, approvalTxnGasPrice, approvalTxnNonce, approvalTxnValue] = await Promise.all([resolvePromisedValue(sendTxn.to), resolvePromisedValue(sendTxn.data), resolvePromisedValue(sendTxn.gasPrice), resolvePromisedValue(sendTxn.gas), resolvePromisedValue(sendTxn.nonce), resolvePromisedValue(sendTxn.value), resolvePromisedValue(approvalTxn?.to), resolvePromisedValue(approvalTxn?.data), resolvePromisedValue(approvalTxn?.gas), resolvePromisedValue(approvalTxn?.gasPrice), resolvePromisedValue(approvalTxn?.nonce), resolvePromisedValue(approvalTxn?.value)]);
  const swapRoute = {
    transactionRequest: {
      to: sendTxnTo,
      data: sendTxnData,
      gasPrice: sendTxnGasPrice,
      gasLimit: sendTxnGasLimit,
      nonce: sendTxnNonce,
      value: sendTxnValue,
      chainId: sendTxn.chain.id
    },
    approval: approvalTxn ? {
      to: approvalTxnTo,
      data: approvalTxnData,
      gasLimit: approvalTxnGasLimit,
      gasPrice: approvalTxnGasPrice,
      nonce: approvalTxnNonce,
      value: approvalTxnValue,
      chainId: approvalTxn.chain.id
    } : void 0,
    swapDetails: data.swapDetails,
    paymentTokens: data.paymentTokens,
    processingFees: data.processingFees,
    client
  };
  return swapRoute;
}
async function getBuyWithCryptoStatus2(buyWithCryptoTransaction) {
  return getBuyWithCryptoStatus({
    ...buyWithCryptoTransaction,
    client: createThirdwebClient({
      clientId: buyWithCryptoTransaction.clientId
    })
  });
}

// node_modules/@thirdweb-dev/sdk/dist/watchTransactions-fe02f62c.browser.esm.js
init_shim();
init_lib();
var STORAGE_CACHE = new ThirdwebStorage();
var CONTRACT_CACHE = createLruCache(10);
function getContractCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function inContractCache(address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.has(cacheKey);
}
function getCachedContract(address, chainId) {
  if (!inContractCache(address, chainId)) {
    throw new Error(`Contract ${address} was not found in cache`);
  }
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.get(cacheKey);
}
function cacheContract(contract, address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  CONTRACT_CACHE.put(cacheKey, contract);
}
function getCachedStorage(storage) {
  return storage || STORAGE_CACHE;
}
async function getContractFromAbi(params) {
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const [resolvedAddress, {
    chainId
  }, {
    SmartContract
  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork(), import("./smart-contract-96faff43.browser.esm-CBK6JGJY.js")]);
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  const parsedAbi = typeof params.abi === "string" ? JSON.parse(params.abi) : params.abi;
  const contract = new SmartContract(signer || provider, resolvedAddress, await getCompositeABI(resolvedAddress, AbiSchema.parse(parsedAbi), provider, params.sdkOptions, getCachedStorage(params.storage)), getCachedStorage(params.storage), params.sdkOptions, chainId);
  cacheContract(contract, resolvedAddress, chainId);
  return contract;
}
async function resolveContractType(params) {
  try {
    const IThirdwebContractABI = (await import("./IThirdwebContract-RPCG5J6Y.js")).default;
    const contract = new Contract(params.address, IThirdwebContractABI, params.provider);
    const remoteContractType = utils_exports.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
    return getContractTypeForRemoteName(remoteContractType);
  } catch (err) {
    return "custom";
  }
}
async function getContract2(params) {
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const [resolvedAddress, {
    chainId
  }, {
    ContractPublisher: ContractPublisher2
  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork(), import("./contract-publisher-325971b7.browser.esm-M43XQ7VD.js").then(function(n) {
    return n.c;
  })]);
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  if (!params.contractTypeOrAbi || params.contractTypeOrAbi === "custom") {
    const contractType = await resolveContractType({
      address: resolvedAddress,
      provider
    });
    if (contractType === "custom") {
      const publisher = new ContractPublisher2(params.network, params.sdkOptions, getCachedStorage(params.storage));
      try {
        const metadata = await publisher.fetchCompilerMetadataFromAddress(resolvedAddress);
        return getContractFromAbi({
          ...params,
          address: resolvedAddress,
          abi: metadata.abi
        });
      } catch {
        throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);
      }
    } else {
      const abi = await PREBUILT_CONTRACTS_MAP[contractType].getAbi(resolvedAddress, provider, getCachedStorage(params.storage));
      return getContractFromAbi({
        ...params,
        address: resolvedAddress,
        abi
      });
    }
  } else if (typeof params.contractTypeOrAbi === "string" && params.contractTypeOrAbi in PREBUILT_CONTRACTS_MAP) {
    const contract = await PREBUILT_CONTRACTS_MAP[params.contractTypeOrAbi].initialize(signer || provider, resolvedAddress, getCachedStorage(params.storage), params.sdkOptions);
    cacheContract(contract, resolvedAddress, chainId);
    return contract;
  } else {
    return getContractFromAbi({
      ...params,
      address: resolvedAddress,
      abi: params.contractTypeOrAbi
    });
  }
}
var CHAIN_ID_CACHE = /* @__PURE__ */ new WeakMap();
async function getChainId(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  let chainIdPromise;
  if (CHAIN_ID_CACHE.has(provider)) {
    chainIdPromise = CHAIN_ID_CACHE.get(provider);
  } else {
    chainIdPromise = provider.getNetwork().then((network) => network.chainId).catch((err) => {
      CHAIN_ID_CACHE.delete(provider);
      throw err;
    });
    CHAIN_ID_CACHE.set(provider, chainIdPromise);
  }
  return await chainIdPromise;
}
async function getBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  return provider.getBlockNumber();
}
var BLOCK_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlock(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlock(blockTag).catch((err) => {
      BLOCK_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
var BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlockWithTransactions(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlockWithTransactions(blockTag).catch((err) => {
      BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
function watchBlockNumber2(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  provider.on("block", params.onBlockNumber);
  return () => {
    provider.off("block", params.onBlockNumber);
  };
}
function watchBlock(_ref) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlock({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber2({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchBlockWithTransactions(_ref2) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref2;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlockWithTransactions({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber2({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchTransactions(_ref) {
  let {
    address,
    onTransactions,
    ...sharedBlockParams
  } = _ref;
  const lcAddress = address.toLowerCase();
  function onBlock(block) {
    const transactions = block.transactions.filter((tx) => {
      if (tx.from.toLowerCase() === lcAddress) {
        return true;
      }
      return tx.to?.toLowerCase() === lcAddress;
    });
    if (transactions.length > 0) {
      onTransactions(transactions);
    }
  }
  return watchBlockWithTransactions({
    ...sharedBlockParams,
    onBlock
  });
}

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
init_lib();
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var import_utils15 = __toESM(require_utils());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
function getRpcUrl(network, clientId) {
  return `https://${network}.rpc.thirdweb.com/${clientId || ""}`;
}
globalThis.global = globalThis;

export {
  checkClientIdOrSecretKey,
  getEncodedConstructorParamsForThirdwebContract,
  predictThirdwebContractAddress,
  getThirdwebContractAddress,
  verifyThirdwebPrebuiltImplementation,
  verify,
  checkVerificationStatus,
  isVerifiedOnEtherscan,
  ContractVerifier,
  LOCAL_NODE_PKEY,
  UserWallet,
  getAllDetectedFeatureNames,
  getAllDetectedExtensionNames,
  extractFunctionParamsFromAbi,
  computeCloneFactoryAddress,
  convertParamValues,
  deployCreate2Factory,
  SUPPORTED_CHAIN_IDS,
  getDefaultTrustedForwarders,
  getDeployArguments,
  getTrustedForwarders,
  APPROVED_IMPLEMENTATIONS,
  getApprovedImplementation,
  directDeployDeterministic,
  directDeployDeterministicWithUri,
  directDeployDeterministicPublished,
  predictAddressDeterministic,
  predictAddressDeterministicWithUri,
  predictAddressDeterministicPublished,
  ThirdwebSDK,
  ContractDeployer,
  matchesPrebuiltAbi,
  toUnits2 as toUnits,
  toDisplayValue,
  computeNativeTokenAddress,
  deployContractDeterministicRaw,
  getCachedAbiForContract,
  ProposalState,
  OptionalPropertiesInput,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  EditionMetadataInputSchema,
  EditionMetadataInputOrUriSchema,
  TokenMintInputSchema,
  getBuyWithCryptoHistory2 as getBuyWithCryptoHistory,
  getBuyWithCryptoQuote2 as getBuyWithCryptoQuote,
  getBuyWithCryptoStatus2 as getBuyWithCryptoStatus,
  getContractFromAbi,
  getContract2 as getContract,
  getChainId,
  getBlockNumber,
  getBlock,
  getBlockWithTransactions,
  watchBlockNumber2 as watchBlockNumber,
  watchBlock,
  watchBlockWithTransactions,
  watchTransactions,
  getRpcUrl
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=chunk-ES4ESUXH.js.map

import {
  ACCOUNT_CORE_ABI,
  ENTRYPOINT_ADDRESS,
  MANAGED_ACCOUNT_GAS_BUFFER,
  chainIdToThirdwebRpc,
  checkContractWalletSignature,
  require_dist,
  setAnalyticsHeaders
} from "./chunk-YAPP7FQW.js";
import {
  Connector
} from "./chunk-U573SYRD.js";
import {
  isTwUrl
} from "./chunk-BMLLEUBY.js";
import {
  _defineProperty
} from "./chunk-7KVJTDF4.js";
import {
  LOCAL_NODE_PKEY,
  ThirdwebSDK
} from "./chunk-ES4ESUXH.js";
import {
  getChainProvider,
  getDynamicFeeData,
  getGasPrice,
  signTypedDataInternal
} from "./chunk-CFECTRPO.js";
import {
  c42220,
  c44787,
  c62320
} from "./chunk-I3A4RD7G.js";
import {
  Contract,
  ethers_exports,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber,
  Signer,
  lib_exports20 as lib_exports2,
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __toESM
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js
init_shim();
init_lib();
var import_contracts = __toESM(require_dist());
async function hexlifyUserOp(op) {
  const userOp = await utils_exports.resolveProperties(op);
  return Object.keys(userOp).map((key) => {
    let val = userOp[key];
    if (typeof val !== "string" || !val.startsWith("0x")) {
      val = utils_exports.hexValue(val);
    }
    return [key, val];
  }).reduce((set, _ref) => {
    let [k, v] = _ref;
    return {
      ...set,
      [k]: v
    };
  }, {});
}
async function getUserOpHashV06(userOp, entryPoint, chainId) {
  const op = await utils_exports.resolveProperties(userOp);
  const hashedUserOp = {
    sender: op.sender,
    nonce: op.nonce,
    initCodeHash: utils_exports.keccak256(op.initCode),
    callDataHash: utils_exports.keccak256(op.callData),
    callGasLimit: op.callGasLimit,
    verificationGasLimit: op.verificationGasLimit,
    preVerificationGas: op.preVerificationGas,
    maxFeePerGas: op.maxFeePerGas,
    maxPriorityFeePerGas: op.maxPriorityFeePerGas,
    paymasterAndDataHash: utils_exports.keccak256(op.paymasterAndData)
  };
  const userOpType = {
    components: [{
      type: "address",
      name: "sender"
    }, {
      type: "uint256",
      name: "nonce"
    }, {
      type: "bytes32",
      name: "initCodeHash"
    }, {
      type: "bytes32",
      name: "callDataHash"
    }, {
      type: "uint256",
      name: "callGasLimit"
    }, {
      type: "uint256",
      name: "verificationGasLimit"
    }, {
      type: "uint256",
      name: "preVerificationGas"
    }, {
      type: "uint256",
      name: "maxFeePerGas"
    }, {
      type: "uint256",
      name: "maxPriorityFeePerGas"
    }, {
      type: "bytes32",
      name: "paymasterAndDataHash"
    }],
    name: "hashedUserOp",
    type: "tuple"
  };
  const encoded = utils_exports.defaultAbiCoder.encode([userOpType], [{
    ...hashedUserOp
  }]);
  const userOpHash = utils_exports.keccak256(encoded);
  const enc = utils_exports.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, entryPoint, chainId]);
  return utils_exports.keccak256(enc);
}
var generateRandomUint192 = () => {
  const rand1 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand2 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand3 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand4 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand5 = BigInt(Math.floor(Math.random() * 4294967296));
  const rand6 = BigInt(Math.floor(Math.random() * 4294967296));
  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;
};
var randomNonce = () => {
  let hexString = generateRandomUint192().toString(16);
  if (hexString.length % 2 !== 0) {
    hexString = "0" + hexString;
  }
  hexString = "0x" + hexString;
  return BigNumber.from(utils_exports.concat([hexString, "0x0000000000000000"]));
};
var PaymasterAPI = class {
};
var DEBUG = false;
var HttpRpcClient = class {
  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {
    this.bundlerUrl = bundlerUrl;
    this.entryPointAddress = entryPointAddress;
    this.chainId = chainId;
    const headers = {};
    if (isTwUrl(this.bundlerUrl)) {
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
      if (secretKey) {
        headers["x-secret-key"] = secretKey;
      } else if (clientId) {
        headers["x-client-id"] = clientId;
        if (bundleId) {
          headers["x-bundle-id"] = bundleId;
        }
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders(headers);
    }
    this.userOpJsonRpcProvider = new lib_exports2.StaticJsonRpcProvider({
      url: this.bundlerUrl,
      headers
    }, {
      name: "Connected bundler network",
      chainId
    });
    this.initializing = this.validateChainId();
  }
  async validateChainId() {
    const chain = await this.userOpJsonRpcProvider.send("eth_chainId", []);
    const bundlerChain = parseInt(chain);
    if (bundlerChain !== this.chainId) {
      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);
    }
  }
  async sendUserOpToBundler(userOp1) {
    await this.initializing;
    const hexifiedUserOp = await hexlifyUserOp(userOp1);
    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];
    await this.printUserOperation("eth_sendUserOperation", jsonRequestData);
    return await this.userOpJsonRpcProvider.send("eth_sendUserOperation", [hexifiedUserOp, this.entryPointAddress]);
  }
  async estimateUserOpGas(userOp) {
    await this.initializing;
    const hexifiedUserOp = await hexlifyUserOp(userOp);
    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];
    await this.printUserOperation("eth_estimateUserOperationGas", jsonRequestData);
    const data = await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas", [hexifiedUserOp, this.entryPointAddress]);
    return {
      preVerificationGas: BigNumber.from(data.preVerificationGas),
      verificationGas: BigNumber.from(data.verificationGas),
      verificationGasLimit: BigNumber.from(data.verificationGasLimit),
      callGasLimit: BigNumber.from(data.callGasLimit).add(MANAGED_ACCOUNT_GAS_BUFFER)
    };
  }
  async getUserOperationGasPrice() {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("thirdweb_getUserOperationGasPrice", []);
  }
  async getUserOperationReceipt(userOpHash) {
    await this.initializing;
    return await this.userOpJsonRpcProvider.send("eth_getUserOperationReceipt", [userOpHash]);
  }
  async printUserOperation(method, _ref) {
    {
      return;
    }
  }
};
var VerifyingPaymasterAPI = class extends PaymasterAPI {
  constructor(paymasterUrl, entryPoint, clientId, secretKey) {
    super();
    this.paymasterUrl = paymasterUrl;
    this.entryPoint = entryPoint;
    this.clientId = clientId;
    this.secretKey = secretKey;
  }
  async getPaymasterAndData(userOp) {
    const headers = {
      "Content-Type": "application/json"
    };
    if (isTwUrl(this.paymasterUrl)) {
      if (this.secretKey && this.clientId) {
        throw new Error("Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.");
      }
      if (this.secretKey) {
        headers["x-secret-key"] = this.secretKey;
      } else if (this.clientId) {
        headers["x-client-id"] = this.clientId;
        const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
        if (bundleId) {
          headers["x-bundle-id"] = bundleId;
        }
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders(headers);
    }
    const response = await fetch(this.paymasterUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: 1,
        method: "pm_sponsorUserOperation",
        params: [await hexlifyUserOp(userOp), this.entryPoint]
      })
    });
    const res = await response.json();
    if (!response.ok) {
      const error = res.error || response.statusText;
      const code = res.code || "UNKNOWN";
      throw new Error(`Paymaster error: ${error}
Status: ${response.status}
Code: ${code}`);
    }
    if (DEBUG) {
      console.debug("Paymaster result:", res);
    }
    if (res.result) {
      if (typeof res.result === "string") {
        return {
          paymasterAndData: res.result
        };
      } else {
        return res.result;
      }
    } else {
      const error = res.error?.message || res.error || response.statusText || "unknown error";
      throw new Error(`Paymaster error from ${this.paymasterUrl}: ${error}`);
    }
  }
};
var getVerifyingPaymaster = (paymasterUrl, entryPoint, clientId, secretKey) => new VerifyingPaymasterAPI(paymasterUrl, entryPoint, clientId, secretKey);
var UserOperationEventListener = class {
  constructor(resolve, reject, entryPoint, sender, userOpHash, nonce, timeout) {
    this.resolve = resolve;
    this.reject = reject;
    this.entryPoint = entryPoint;
    this.sender = sender;
    this.userOpHash = userOpHash;
    this.nonce = nonce;
    this.timeout = timeout;
    _defineProperty(this, "resolved", false);
    this.boundLisener = this.listenerCallback.bind(this);
  }
  start() {
    const filter = this.entryPoint.filters.UserOperationEvent(this.userOpHash);
    setTimeout(async () => {
      const res = await this.entryPoint.queryFilter(filter, -10);
      if (res.length > 0) {
        void this.listenerCallback(res[0]);
      } else {
        this.entryPoint.once(filter, this.boundLisener);
      }
    }, 100);
  }
  stop() {
    this.entryPoint.off("UserOperationEvent", this.boundLisener);
  }
  async listenerCallback() {
    for (var _len = arguments.length, param = new Array(_len), _key = 0; _key < _len; _key++) {
      param[_key] = arguments[_key];
    }
    const event = arguments[arguments.length - 1];
    if (!event.args) {
      console.error("got event without args", event);
      return;
    }
    if (event.args.userOpHash !== this.userOpHash) {
      console.log(`== event with wrong userOpHash: sender/nonce: event.${event.args.sender}@${event.args.nonce.toString()}!= userOp.${this.sender}@${parseInt(this.nonce?.toString())}`);
      return;
    }
    const transactionReceipt = await event.getTransactionReceipt();
    if (!event.args.success) {
      await this.extractFailureReason(transactionReceipt);
    }
    this.stop();
    this.resolve(transactionReceipt);
    this.resolved = true;
  }
  async extractFailureReason(receipt) {
    receipt.status = 0;
    const revertReasonEvents = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash, this.sender), receipt.blockHash);
    if (revertReasonEvents[0]) {
      let message = revertReasonEvents[0].args.revertReason;
      if (message.startsWith("0x08c379a0")) {
        message = utils_exports.defaultAbiCoder.decode(["string"], "0x" + message.substring(10)).toString();
      }
      this.reject(new Error(`UserOp failed with reason: ${message}`));
    }
  }
};
var ERC4337EthersSigner = class extends Signer {
  constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {
    super();
    utils_exports.defineReadOnly(this, "provider", erc4337provider);
    this.config = config;
    this.originalSigner = originalSigner;
    this.erc4337provider = erc4337provider;
    this.httpRpcClient = httpRpcClient;
    this.smartAccountAPI = smartAccountAPI;
    this.approving = false;
  }
  async sendTransaction(transaction, options) {
    if (!this.approving) {
      this.approving = true;
      const tx2 = await this.smartAccountAPI.createApproveTx();
      if (tx2) {
        await (await this.sendTransaction(tx2)).wait();
      }
      this.approving = false;
    }
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    await this.verifyAllNecessaryFields(tx);
    const multidimensionalNonce = randomNonce();
    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {
      target: tx.to || "",
      data: tx.data?.toString() || "0x",
      value: tx.value,
      gasLimit: tx.gasLimit,
      nonce: multidimensionalNonce,
      maxFeePerGas: tx.maxFeePerGas,
      maxPriorityFeePerGas: tx.maxPriorityFeePerGas
    }, options);
    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);
    const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation);
    try {
      await this.httpRpcClient.sendUserOpToBundler(userOperation);
    } catch (error) {
      throw this.unwrapError(error);
    }
    return transactionResponse;
  }
  unwrapError(errorIn) {
    try {
      let errorMsg = "Unknown Error";
      if (errorIn.error) {
        errorMsg = `The bundler has failed to include UserOperation in a batch: ${errorIn.error}`;
      } else if (errorIn.body && typeof errorIn.body === "string") {
        const errorBody = JSON.parse(errorIn.body);
        const errorStatus = errorIn.status || "UNKNOWN";
        const errorCode = errorBody?.code || "UNKNOWN";
        let failedOpMessage = errorBody?.error?.message || errorBody?.error?.data || errorBody?.error || errorIn.reason;
        if (failedOpMessage?.includes("FailedOp")) {
          let paymasterInfo = "";
          const matched = failedOpMessage.match(/FailedOp\((.*)\)/);
          if (matched) {
            const split = matched[1].split(",");
            paymasterInfo = `(paymaster address: ${split[1]})`;
            failedOpMessage = split[2];
          }
          errorMsg = `The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo}`;
        } else {
          errorMsg = `RPC error: ${failedOpMessage}
Status: ${errorStatus}
Code: ${errorCode}`;
        }
      }
      const error = new Error(errorMsg);
      error.stack = errorIn.stack;
      return error;
    } catch (error) {
    }
    return errorIn;
  }
  async verifyAllNecessaryFields(transactionRequest) {
    if (!transactionRequest.to) {
      throw new Error("Missing call target");
    }
    if (!transactionRequest.data && !transactionRequest.value) {
      throw new Error("Missing call data or value");
    }
  }
  connect(provider) {
    throw new Error("changing providers is not supported");
  }
  async getAddress() {
    if (!this.address) {
      this.address = await this.erc4337provider.getSenderAccountAddress();
    }
    return this.address;
  }
  async signMessage(message) {
    const isNotDeployed = await this.smartAccountAPI.checkAccountPhantom();
    if (isNotDeployed) {
      console.log("Account contract not deployed yet. Deploying account before signing message");
      const tx = await this.sendTransaction({
        to: await this.getAddress(),
        data: "0x"
      });
      await tx.wait();
    }
    const [chainId, address] = await Promise.all([this.getChainId(), this.getAddress()]);
    const originalMsgHash = utils_exports.hashMessage(message);
    let factorySupports712;
    let signature;
    const rpcUrl = chainIdToThirdwebRpc(chainId, this.config.clientId);
    const headers = {};
    if (isTwUrl(rpcUrl)) {
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : void 0;
      if (this.config.secretKey) {
        headers["x-secret-key"] = this.config.secretKey;
      } else if (this.config.clientId) {
        headers["x-client-id"] = this.config.clientId;
        if (bundleId) {
          headers["x-bundle-id"] = bundleId;
        }
      }
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders(headers);
    }
    try {
      const provider = new lib_exports2.StaticJsonRpcProvider({
        url: rpcUrl,
        headers
      }, chainId);
      const walletContract = new Contract(address, ["function getMessageHash(bytes32 _hash) public view returns (bytes32)"], provider);
      await walletContract.getMessageHash(originalMsgHash);
      factorySupports712 = true;
    } catch {
      factorySupports712 = false;
    }
    if (factorySupports712) {
      const result = await signTypedDataInternal(this, {
        name: "Account",
        version: "1",
        chainId,
        verifyingContract: address
      }, {
        AccountMessage: [{
          name: "message",
          type: "bytes"
        }]
      }, {
        message: utils_exports.defaultAbiCoder.encode(["bytes32"], [originalMsgHash])
      });
      signature = result.signature;
    } else {
      signature = await this.originalSigner.signMessage(message);
    }
    const isValid = await checkContractWalletSignature(message, signature, address, chainId, this.config.clientId, this.config.secretKey);
    if (isValid) {
      return signature;
    } else {
      throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.");
    }
  }
  async signTransaction(transaction, options) {
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    await this.verifyAllNecessaryFields(tx);
    const multidimensionalNonce = randomNonce();
    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {
      target: tx.to || "",
      data: tx.data?.toString() || "0x",
      value: tx.value,
      gasLimit: tx.gasLimit,
      nonce: multidimensionalNonce
    }, options);
    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);
    const userOpString = JSON.stringify(await hexlifyUserOp(userOperation));
    return userOpString;
  }
};
var ERC4337EthersProvider = class extends lib_exports2.BaseProvider {
  constructor(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI) {
    super({
      name: "ERC-4337 Custom Network",
      chainId
    });
    this.chainId = chainId;
    this.config = config;
    this.originalSigner = originalSigner;
    this.originalProvider = originalProvider;
    this.httpRpcClient = httpRpcClient;
    this.entryPoint = entryPoint;
    this.smartAccountAPI = smartAccountAPI;
    this.signer = new ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);
  }
  getSigner() {
    return this.signer;
  }
  async perform(method, params) {
    if (method === "sendTransaction" || method === "getTransactionReceipt") {
      throw new Error("Should not get here. Investigate.");
    }
    if (method === "estimateGas") {
      return BigNumber.from(5e5);
    }
    return await this.originalProvider.perform(method, params);
  }
  async getTransaction(transactionHash) {
    return await super.getTransaction(transactionHash);
  }
  async getTransactionReceipt(transactionHash) {
    const userOpHash = await transactionHash;
    const sender = await this.getSenderAccountAddress();
    return await new Promise((resolve, reject) => {
      new UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();
    });
  }
  async getSenderAccountAddress() {
    return await this.smartAccountAPI.getAccountAddress();
  }
  async waitForTransaction(transactionHash, confirmations, timeout) {
    const sender = await this.getSenderAccountAddress();
    return await new Promise((resolve, reject) => {
      const listener = new UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, void 0, timeout);
      listener.start();
    });
  }
  async constructUserOpTransactionResponse(userOp1) {
    const userOp = await utils_exports.resolveProperties(userOp1);
    const userOpHash = await this.smartAccountAPI.getUserOpHash(userOp);
    return {
      hash: userOpHash,
      confirmations: 0,
      from: userOp.sender,
      nonce: 0,
      gasLimit: BigNumber.from(userOp.callGasLimit),
      value: BigNumber.from(0),
      data: utils_exports.hexValue(userOp.callData),
      chainId: this.chainId,
      wait: async (confirmations) => {
        const transactionReceipt = await this.smartAccountAPI.getUserOpReceipt(this.httpRpcClient, userOpHash);
        if (userOp.initCode.length !== 0) {
          await this.smartAccountAPI.checkAccountPhantom();
        }
        return transactionReceipt;
      }
    };
  }
  async detectNetwork() {
    return this.originalProvider.detectNetwork();
  }
};
function create4337Provider(config, accountApi, originalProvider, chainId) {
  const entryPoint = import_contracts.EntryPoint__factory.connect(config.entryPointAddress, originalProvider);
  const httpRpcClient = new HttpRpcClient(config.bundlerUrl, config.entryPointAddress, chainId, config.clientId, config.secretKey);
  return new ERC4337EthersProvider(chainId, config, config.localSigner, originalProvider, httpRpcClient, entryPoint, accountApi);
}
var DUMMY_SIGNATURE = "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c";
var BaseAccountAPI = class {
  constructor(params) {
    _defineProperty(this, "isPhantom", true);
    this.provider = params.provider;
    this.entryPointAddress = params.entryPointAddress;
    this.accountAddress = params.accountAddress;
    this.paymasterAPI = params.paymasterAPI;
    this.gasless = params.gasless;
    this.erc20PaymasterAddress = params.erc20PaymasterAddress;
    this.erc20TokenAddress = params.erc20TokenAddress;
    this.entryPointView = import_contracts.EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers_exports.constants.AddressZero);
  }
  async checkAccountPhantom() {
    if (!this.isPhantom) {
      return this.isPhantom;
    }
    const senderAddressCode = await this.provider.getCode(this.getAccountAddress());
    if (senderAddressCode.length > 2) {
      this.isPhantom = false;
    }
    return this.isPhantom;
  }
  async getInitCode() {
    if (await this.checkAccountPhantom()) {
      return await this.getAccountInitCode();
    }
    return "0x";
  }
  async getVerificationGasLimit() {
    return 1e5;
  }
  async getUserOpHash(userOp) {
    const chainId = await this.provider.getNetwork().then((net) => net.chainId);
    return getUserOpHashV06(userOp, this.entryPointAddress, chainId);
  }
  async getAccountAddress() {
    if (!this.senderAddress) {
      if (this.accountAddress) {
        this.senderAddress = this.accountAddress;
      } else {
        this.senderAddress = await this.getCounterFactualAddress();
      }
    }
    return this.senderAddress;
  }
  async estimateCreationGas(initCode) {
    if (!initCode || initCode === "0x") {
      return 0;
    }
    const deployerAddress = initCode.substring(0, 42);
    const deployerCallData = "0x" + initCode.substring(42);
    return await this.provider.estimateGas({
      to: deployerAddress,
      data: deployerCallData
    });
  }
  async createUnsignedUserOp(httpRpcClient, info, options) {
    let {
      maxFeePerGas,
      maxPriorityFeePerGas
    } = info;
    if (isTwUrl(httpRpcClient.bundlerUrl)) {
      const bundlerFeeData = await httpRpcClient.getUserOperationGasPrice();
      maxFeePerGas = BigNumber.from(bundlerFeeData.maxFeePerGas);
      maxPriorityFeePerGas = BigNumber.from(bundlerFeeData.maxPriorityFeePerGas);
    } else {
      if (!maxFeePerGas || !maxPriorityFeePerGas) {
        const feeData = await getDynamicFeeData(this.provider);
        if (!maxPriorityFeePerGas) {
          maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? void 0;
        }
        if (!maxFeePerGas) {
          maxFeePerGas = feeData.maxFeePerGas ?? void 0;
          const network = await this.provider.getNetwork();
          const chainId = network.chainId;
          if (chainId === c42220.chainId || chainId === c44787.chainId || chainId === c62320.chainId) {
            maxPriorityFeePerGas = maxFeePerGas;
          }
        }
      }
    }
    if (!maxFeePerGas || !maxPriorityFeePerGas) {
      throw new Error("maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely");
    }
    const [sender, nonce] = await Promise.all([this.getAccountAddress(), info.nonce ? Promise.resolve(info.nonce) : this.getNonce()]);
    const initCode = await this.getInitCode();
    const value = parseNumber(info.value) ?? BigNumber.from(0);
    const callData = options?.batchData ? info.data : await this.prepareExecute(info.target, value, info.data).then(async (tx) => {
      if (!info.gasLimit) {
        await this.provider.estimateGas({
          from: sender,
          to: info.target,
          data: info.data,
          value
        });
      }
      return tx.encode();
    });
    const partialOp = {
      sender,
      nonce,
      initCode,
      callData,
      maxFeePerGas,
      maxPriorityFeePerGas,
      callGasLimit: BigNumber.from(1e6),
      verificationGasLimit: BigNumber.from(1e6),
      preVerificationGas: BigNumber.from(1e6),
      paymasterAndData: "0x",
      signature: DUMMY_SIGNATURE
    };
    const gasless = options?.gasless !== void 0 ? options.gasless : this.gasless;
    const useErc20Paymaster = this.erc20PaymasterAddress && this.erc20TokenAddress && await this.isAccountApproved();
    if (useErc20Paymaster) {
      partialOp.paymasterAndData = this.erc20PaymasterAddress;
      let estimates;
      try {
        estimates = await httpRpcClient.estimateUserOpGas(partialOp);
      } catch (error) {
        throw this.unwrapBundlerError(error);
      }
      partialOp.callGasLimit = estimates.callGasLimit;
      partialOp.verificationGasLimit = estimates.verificationGasLimit;
      partialOp.preVerificationGas = estimates.preVerificationGas;
    } else if (gasless) {
      const paymasterResult = await this.paymasterAPI.getPaymasterAndData(partialOp);
      const paymasterAndData = paymasterResult.paymasterAndData;
      if (paymasterAndData && paymasterAndData !== "0x") {
        partialOp.paymasterAndData = paymasterAndData;
      }
      if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {
        partialOp.callGasLimit = BigNumber.from(paymasterResult.callGasLimit);
        partialOp.verificationGasLimit = BigNumber.from(paymasterResult.verificationGasLimit);
        partialOp.preVerificationGas = BigNumber.from(paymasterResult.preVerificationGas);
      } else {
        let estimates;
        try {
          estimates = await httpRpcClient.estimateUserOpGas(partialOp);
        } catch (error) {
          throw this.unwrapBundlerError(error);
        }
        partialOp.callGasLimit = estimates.callGasLimit;
        partialOp.verificationGasLimit = estimates.verificationGasLimit;
        partialOp.preVerificationGas = estimates.preVerificationGas;
        if (paymasterAndData && paymasterAndData !== "0x") {
          const paymasterResult2 = await this.paymasterAPI.getPaymasterAndData(partialOp);
          if (paymasterResult2.paymasterAndData && paymasterResult2.paymasterAndData !== "0x") {
            partialOp.paymasterAndData = paymasterResult2.paymasterAndData;
          }
        }
      }
    } else {
      let estimates;
      try {
        estimates = await httpRpcClient.estimateUserOpGas(partialOp);
      } catch (error) {
        throw this.unwrapBundlerError(error);
      }
      partialOp.callGasLimit = estimates.callGasLimit;
      partialOp.verificationGasLimit = estimates.verificationGasLimit;
      partialOp.preVerificationGas = estimates.preVerificationGas;
    }
    return {
      ...partialOp,
      signature: ""
    };
  }
  async signUserOp(userOp) {
    const userOpHash = await this.getUserOpHash(userOp);
    const signature = await this.signUserOpHash(userOpHash);
    return {
      ...userOp,
      signature
    };
  }
  async getUserOpReceipt(httpRpcClient, userOpHash) {
    let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12e4;
    let interval = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e3;
    const endtime = Date.now() + timeout;
    while (Date.now() < endtime) {
      const userOpReceipt = await httpRpcClient.getUserOperationReceipt(userOpHash);
      if (userOpReceipt) {
        return await this.provider.waitForTransaction(userOpReceipt.receipt.transactionHash);
      }
      await new Promise((resolve) => setTimeout(resolve, interval));
    }
    throw new Error("Timeout waiting for userOp to be mined");
  }
  unwrapBundlerError(error) {
    const message = error?.error?.message || error.error || error.message || error;
    return new Error(message);
  }
};
function parseNumber(a) {
  if (!a || a === "") {
    return null;
  }
  return BigNumber.from(a.toString());
}
var AccountAPI = class extends BaseAccountAPI {
  constructor(params, originalProvider) {
    super({
      ...params,
      provider: originalProvider
    });
    this.params = params;
    this.sdk = ThirdwebSDK.fromPrivateKey(LOCAL_NODE_PKEY, params.chain, {
      clientId: params.clientId,
      secretKey: params.secretKey,
      supportedChains: typeof params.chain === "object" ? [params.chain] : void 0
    });
  }
  async getChainId() {
    return await this.provider.getNetwork().then((n) => n.chainId);
  }
  async getAccountContract() {
    if (!this.accountContract) {
      if (this.params.accountInfo?.abi) {
        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), this.params.accountInfo.abi);
      } else {
        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), ACCOUNT_CORE_ABI);
      }
    }
    return this.accountContract;
  }
  async getAccountInitCode() {
    const factory = await this.getFactoryContract();
    const localSigner = await this.params.localSigner.getAddress();
    const tx = await this.params.factoryInfo.createAccount(factory, localSigner);
    return utils_exports.hexConcat([factory.getAddress(), tx.encode()]);
  }
  async getFactoryContract() {
    if (this.factoryContract) {
      return this.factoryContract;
    }
    if (this.params.factoryInfo?.abi) {
      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress, this.params.factoryInfo.abi);
    } else {
      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress);
    }
    return this.factoryContract;
  }
  async getCounterFactualAddress() {
    if (this.params.accountAddress) {
      return this.params.accountAddress;
    }
    const factory = await this.getFactoryContract();
    const localSigner = await this.params.localSigner.getAddress();
    return this.params.factoryInfo.getAccountAddress(factory, localSigner);
  }
  async getNonce() {
    if (await this.checkAccountPhantom()) {
      return BigNumber.from(0);
    }
    const accountContract = await this.getAccountContract();
    return this.params.accountInfo.getNonce(accountContract);
  }
  async prepareExecute(target, value, data) {
    const accountContract = await this.getAccountContract();
    return this.params.accountInfo.execute(accountContract, target, value, data);
  }
  async prepareExecuteBatch(targets, values, datas) {
    const accountContract = await this.getAccountContract();
    return accountContract.prepare("executeBatch", [targets, values, datas]);
  }
  async signUserOpHash(userOpHash) {
    return await this.params.localSigner.signMessage(utils_exports.arrayify(userOpHash));
  }
  async isAcountDeployed() {
    return !await this.checkAccountPhantom();
  }
  async isAccountApproved() {
    if (!this.params.erc20PaymasterAddress || !this.params.erc20TokenAddress) {
      return true;
    }
    const swAddress = await this.getCounterFactualAddress();
    const ERC20Abi = (await import("./IERC20-GHSR35K6.js")).default;
    const erc20Token = await this.sdk.getContract(this.params.erc20TokenAddress, ERC20Abi);
    const allowance = await erc20Token.call("allowance", [swAddress, this.params.erc20PaymasterAddress]);
    return allowance.gte(BigNumber.from(2).pow(96).sub(1));
  }
  async createApproveTx() {
    if (await this.isAccountApproved()) {
      return void 0;
    }
    const amountToApprove = BigNumber.from(2).pow(96).sub(1);
    const ethersSigner = new ethers_exports.Wallet(LOCAL_NODE_PKEY, this.provider);
    const erc20Contract = new Contract(this.params.erc20TokenAddress, ["function approve(address spender, uint256 amount) public returns (bool)"], ethersSigner);
    const tx = {
      to: this.params.erc20TokenAddress,
      from: await this.getAccountAddress(),
      value: 0,
      data: erc20Contract.interface.encodeFunctionData("approve", [this.params.erc20PaymasterAddress, amountToApprove])
    };
    return tx;
  }
};
var SmartWalletConnector = class extends Connector {
  constructor(config) {
    super();
    this.config = config;
  }
  async initialize(params) {
    const config = this.config;
    const originalProvider = getChainProvider(config.chain, {
      clientId: config.clientId,
      secretKey: config.secretKey
    });
    this.chainId = (await originalProvider.getNetwork()).chainId;
    const bundlerUrl = this.config.bundlerUrl || `https://${this.chainId}.bundler.thirdweb.com`;
    const paymasterUrl = this.config.paymasterUrl || `https://${this.chainId}.bundler.thirdweb.com`;
    const entryPointAddress = config.entryPointAddress || ENTRYPOINT_ADDRESS;
    const localSigner = await params.personalWallet.getSigner();
    const providerConfig = {
      chain: config.chain,
      localSigner,
      entryPointAddress,
      bundlerUrl,
      paymasterAPI: this.config.paymasterAPI ? this.config.paymasterAPI : getVerifyingPaymaster(paymasterUrl, entryPointAddress, this.config.clientId, this.config.secretKey),
      gasless: config.gasless,
      factoryAddress: config.factoryAddress,
      accountAddress: params.accountAddress,
      factoryInfo: {
        createAccount: config.factoryInfo?.createAccount || this.defaultFactoryInfo().createAccount,
        getAccountAddress: config.factoryInfo?.getAccountAddress || this.defaultFactoryInfo().getAccountAddress,
        abi: config.factoryInfo?.abi
      },
      accountInfo: {
        execute: config.accountInfo?.execute || this.defaultAccountInfo().execute,
        getNonce: config.accountInfo?.getNonce || this.defaultAccountInfo().getNonce,
        abi: config.accountInfo?.abi
      },
      clientId: config.clientId,
      secretKey: config.secretKey,
      erc20PaymasterAddress: config.erc20PaymasterAddress,
      erc20TokenAddress: config.erc20TokenAddress
    };
    this.personalWallet = params.personalWallet;
    const accountApi = new AccountAPI(providerConfig, originalProvider);
    this.aaProvider = create4337Provider(providerConfig, accountApi, originalProvider, this.chainId);
    this.accountApi = accountApi;
  }
  async connect(connectionArgs) {
    await this.initialize(connectionArgs);
    return await this.getAddress();
  }
  getProvider() {
    if (!this.aaProvider) {
      throw new Error("Personal wallet not connected");
    }
    return Promise.resolve(this.aaProvider);
  }
  async getSigner() {
    if (!this.aaProvider) {
      throw new Error("Personal wallet not connected");
    }
    return Promise.resolve(this.aaProvider.getSigner());
  }
  async getAddress() {
    const signer = await this.getSigner();
    return signer.getAddress();
  }
  async isConnected() {
    try {
      const address = await this.getAddress();
      return !!address;
    } catch (e) {
      return false;
    }
  }
  async disconnect() {
    this.personalWallet = void 0;
    this.aaProvider = void 0;
  }
  async switchChain(chainId) {
    const provider = await this.getProvider();
    const currentChainId = (await provider.getNetwork()).chainId;
    if (currentChainId !== chainId) {
      throw new Error("Not supported.");
    }
  }
  setupListeners() {
    return Promise.resolve();
  }
  updateChains(chains) {
  }
  async hasPermissionToExecute(transaction) {
    const accountContract = await this.getAccountContract();
    const signer = await this.getSigner();
    const signerAddress = await signer.getAddress();
    const restrictions = (await accountContract.account.getAllSigners()).filter((item) => ethers_exports.utils.getAddress(item.signer) === ethers_exports.utils.getAddress(signerAddress))[0]?.permissions;
    if (!restrictions) {
      return false;
    }
    return restrictions.approvedCallTargets.includes(transaction.getTarget());
  }
  async send(transaction, options) {
    const signer = await this.getSigner();
    return signer.sendTransaction({
      to: transaction.getTarget(),
      data: transaction.encode(),
      value: await transaction.getValue()
    }, options);
  }
  async execute(transaction, options) {
    const tx = await this.send(transaction, options);
    const receipt = await tx.wait();
    return {
      receipt
    };
  }
  async sendBatch(transactions, options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const signer = await this.getSigner();
    const {
      tx,
      batchData
    } = await this.prepareBatchTx(transactions);
    return await signer.sendTransaction({
      to: await signer.getAddress(),
      data: tx.encode(),
      value: 0
    }, {
      ...options,
      batchData
    });
  }
  async executeBatch(transactions, options) {
    const tx = await this.sendBatch(transactions, options);
    const receipt = await tx.wait();
    return {
      receipt
    };
  }
  async sendRaw(transaction, options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const signer = await this.getSigner();
    return signer.sendTransaction(transaction, options);
  }
  async executeRaw(transaction, options) {
    const tx = await this.sendRaw(transaction, options);
    const receipt = await tx.wait();
    return {
      receipt
    };
  }
  async sendBatchRaw(transactions, options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const signer = await this.getSigner();
    const batch = await this.prepareBatchRaw(transactions);
    return signer.sendTransaction({
      to: await signer.getAddress(),
      data: batch.tx.encode(),
      value: 0
    }, {
      ...options,
      batchData: batch.batchData
    });
  }
  async executeBatchRaw(transactions, options) {
    const tx = await this.sendBatchRaw(transactions, options);
    const receipt = await tx.wait();
    return {
      receipt
    };
  }
  async estimate(transaction, options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    return this.estimateTx({
      target: transaction.getTarget(),
      data: transaction.encode(),
      value: await transaction.getValue(),
      gasLimit: await transaction.getOverrides().gasLimit,
      maxFeePerGas: await transaction.getOverrides().maxFeePerGas,
      maxPriorityFeePerGas: await transaction.getOverrides().maxPriorityFeePerGas,
      nonce: await transaction.getOverrides().nonce
    }, options);
  }
  async estimateRaw(transaction, options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    return this.estimateTx({
      target: tx.to || lib_exports.AddressZero,
      data: tx.data?.toString() || "",
      value: tx.value || BigNumber.from(0),
      gasLimit: tx.gasLimit,
      maxFeePerGas: tx.maxFeePerGas,
      maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
      nonce: tx.nonce
    }, options);
  }
  async estimateBatch(transactions, options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const {
      tx,
      batchData
    } = await this.prepareBatchTx(transactions);
    return this.estimateTx({
      target: tx.getTarget(),
      data: tx.encode(),
      value: await tx.getValue(),
      gasLimit: await tx.getOverrides().gasLimit,
      maxFeePerGas: await tx.getOverrides().maxFeePerGas,
      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,
      nonce: await tx.getOverrides().nonce
    }, {
      ...options,
      batchData
    });
  }
  async estimateBatchRaw(transactions, options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const {
      tx,
      batchData
    } = await this.prepareBatchRaw(transactions);
    return this.estimateTx({
      target: tx.getTarget(),
      data: tx.encode(),
      value: await tx.getValue(),
      gasLimit: await tx.getOverrides().gasLimit,
      maxFeePerGas: await tx.getOverrides().maxFeePerGas,
      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,
      nonce: await tx.getOverrides().nonce
    }, {
      ...options,
      batchData
    });
  }
  async deploy(options) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const signer = await this.getSigner();
    const tx = await signer.sendTransaction({
      to: await signer.getAddress(),
      data: "0x"
    }, {
      ...options,
      batchData: {
        targets: [],
        data: [],
        values: []
      }
    });
    const receipt = await tx.wait();
    return {
      receipt
    };
  }
  async isDeployed() {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    return await this.accountApi.isAcountDeployed();
  }
  async deployIfNeeded(options) {
    const isDeployed = await this.isDeployed();
    if (!isDeployed) {
      await this.deploy(options);
    }
  }
  async grantPermissions(target, permissions) {
    const accountContract = await this.getAccountContract();
    return accountContract.account.grantPermissions(target, permissions);
  }
  async revokePermissions(target) {
    const accountContract = await this.getAccountContract();
    return accountContract.account.revokeAccess(target);
  }
  async addAdmin(target) {
    const accountContract = await this.getAccountContract();
    return accountContract.account.grantAdminPermissions(target);
  }
  async removeAdmin(target) {
    const accountContract = await this.getAccountContract();
    return accountContract.account.revokeAdminPermissions(target);
  }
  async getAllActiveSigners() {
    const isDeployed = await this.isDeployed();
    if (isDeployed) {
      const accountContract = await this.getAccountContract();
      return accountContract.account.getAllAdminsAndSigners();
    } else {
      const personalWallet = await this.personalWallet?.getSigner();
      if (!personalWallet) {
        throw new Error("Personal wallet not connected");
      }
      return [{
        isAdmin: true,
        signer: await personalWallet.getAddress(),
        permissions: {
          startDate: new Date(0),
          expirationDate: new Date(0),
          nativeTokenLimitPerTransaction: BigNumber.from(0),
          approvedCallTargets: []
        }
      }];
    }
  }
  async getAccountContract() {
    const sdk = ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {
      clientId: this.config.clientId,
      secretKey: this.config.secretKey
    });
    if (this.config.accountInfo?.abi) {
      return sdk.getContract(await this.getAddress(), this.config.accountInfo.abi);
    } else {
      return sdk.getContract(await this.getAddress(), ACCOUNT_CORE_ABI);
    }
  }
  async getFactoryContract() {
    const sdk = ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {
      clientId: this.config.clientId,
      secretKey: this.config.secretKey
    });
    if (this.config.factoryInfo?.abi) {
      return sdk.getContract(this.config.factoryAddress, this.config.factoryInfo.abi);
    }
    return sdk.getContract(this.config.factoryAddress);
  }
  defaultFactoryInfo() {
    return {
      createAccount: async (factory, owner) => {
        return factory.prepare("createAccount", [owner, ethers_exports.utils.toUtf8Bytes("")]);
      },
      getAccountAddress: async (factory, owner) => {
        return await factory.call("getAddress", [owner, ethers_exports.utils.toUtf8Bytes("")]);
      }
    };
  }
  defaultAccountInfo() {
    return {
      execute: async (account, target, value, data) => {
        return account.prepare("execute", [target, value, data]);
      },
      getNonce: async (account) => {
        return account.call("getNonce", []);
      }
    };
  }
  async estimateTx(tx, options) {
    if (!this.accountApi || !this.aaProvider) {
      throw new Error("Personal wallet not connected");
    }
    let deployGasLimit = BigNumber.from(0);
    const [provider, isDeployed] = await Promise.all([this.getProvider(), this.isDeployed()]);
    if (!isDeployed) {
      deployGasLimit = await this.estimateDeploymentGasLimit();
    }
    const [userOp, gasPrice] = await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient, tx, options), getGasPrice(provider)]);
    const resolved = await utils_exports.resolveProperties(userOp);
    const transactionGasLimit = BigNumber.from(resolved.callGasLimit);
    const transactionCost = transactionGasLimit.mul(gasPrice);
    const deployCost = deployGasLimit.mul(gasPrice);
    const totalCost = deployCost.add(transactionCost);
    return {
      ether: utils_exports.formatEther(totalCost),
      wei: totalCost,
      details: {
        deployGasLimit,
        transactionGasLimit,
        gasPrice,
        transactionCost,
        deployCost,
        totalCost
      }
    };
  }
  async estimateDeploymentGasLimit() {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const initCode = await this.accountApi.getInitCode();
    const [initGas, verificationGasLimit] = await Promise.all([this.accountApi.estimateCreationGas(initCode), this.accountApi.getVerificationGasLimit()]);
    return BigNumber.from(verificationGasLimit).add(initGas);
  }
  async prepareBatchRaw(transactions) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const resolvedTxs = await Promise.all(transactions.map((transaction) => ethers_exports.utils.resolveProperties(transaction)));
    const targets = resolvedTxs.map((tx) => tx.to || lib_exports.AddressZero);
    const data = resolvedTxs.map((tx) => tx.data || "0x");
    const values = resolvedTxs.map((tx) => tx.value || BigNumber.from(0));
    return {
      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),
      batchData: {
        targets,
        data,
        values
      }
    };
  }
  async prepareBatchTx(transactions) {
    if (!this.accountApi) {
      throw new Error("Personal wallet not connected");
    }
    const targets = transactions.map((tx) => tx.getTarget());
    const data = transactions.map((tx) => tx.encode());
    const values = await Promise.all(transactions.map((tx) => tx.getValue()));
    return {
      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),
      batchData: {
        targets,
        data,
        values
      }
    };
  }
};

export {
  SmartWalletConnector
};
//# sourceMappingURL=chunk-LEONFKK2.js.map

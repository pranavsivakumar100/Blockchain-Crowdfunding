import {
  DelayedReveal,
  calculateClaimCost
} from "./chunk-ULJVIQFI.js";
import {
  ClaimEligibility,
  MintRequest1155,
  Signature1155PayloadInputWithTokenId,
  Signature1155PayloadOutput,
  SnapshotFormatVersion,
  abstractContractModelToLegacy,
  abstractContractModelToNew,
  convertQuantityToBigNumber,
  fetchSnapshotEntryForAddress,
  legacyContractModelToAbstract,
  newContractModelToAbstract,
  prepareClaim,
  processClaimConditionInputs,
  require_fast_deep_equal,
  transformResultToClaimCondition,
  updateExistingClaimConditions
} from "./chunk-INCOK333.js";
import {
  assertEnabled
} from "./chunk-5TGBXTHW.js";
import {
  DEFAULT_QUERY_ALL_COUNT,
  FALLBACK_METADATA,
  fetchTokenMetadata,
  uploadOrExtractURI,
  uploadOrExtractURIs
} from "./chunk-POEPSFOQ.js";
import {
  normalizePriceValue,
  setErc20Allowance
} from "./chunk-SRYWWROE.js";
import {
  ContractEncoder,
  ContractMetadata,
  detectContractFeature,
  hasFunction,
  isNativeToken
} from "./chunk-LXY7U6R5.js";
import {
  AddressOrEnsSchema,
  AmountSchema,
  ContractWrapper,
  CustomContractSchema,
  ExtensionNotImplementedError,
  FEATURE_EDITION,
  FEATURE_EDITION_BATCH_MINTABLE,
  FEATURE_EDITION_BURNABLE,
  FEATURE_EDITION_CLAIM_CONDITIONS_V2,
  FEATURE_EDITION_CLAIM_CUSTOM,
  FEATURE_EDITION_ENUMERABLE,
  FEATURE_EDITION_LAZY_MINTABLE_V2,
  FEATURE_EDITION_MINTABLE,
  FEATURE_EDITION_REVEALABLE,
  FEATURE_EDITION_SIGNATURE_MINTABLE,
  FEATURE_EDITION_SUPPLY,
  FEATURE_EDITION_UPDATABLE_METADATA,
  NotFoundError,
  Transaction,
  buildTransactionFunction,
  getPrebuiltInfo,
  includesErrorMessage,
  invariant,
  isNode,
  resolveAddress,
  z
} from "./chunk-CFECTRPO.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField,
  __toESM
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/erc-1155-27d7fe97.browser.esm.js
init_shim();
init_lib();
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var DropErc1155ClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    __publicField(this, "set", buildTransactionFunction((() => {
      var _this = this;
      return async function(tokenId, claimConditionInputs) {
        let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return _this.setBatch.prepare([{
          tokenId,
          claimConditions: claimConditionInputs
        }], resetClaimEligibilityForAll);
      };
    })()));
    __publicField(this, "setBatch", buildTransactionFunction((() => {
      var _this2 = this;
      return async function(claimConditionsForToken) {
        let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const merkleInfo = {};
        const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async (_ref) => {
          let {
            tokenId,
            claimConditions
          } = _ref;
          let claimConditionsProcessed = claimConditions;
          if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {
            resetClaimEligibilityForAll = true;
            if (claimConditions.length === 0) {
              claimConditionsProcessed = [{
                startTime: new Date(0),
                currencyAddress: lib_exports.AddressZero,
                price: 0,
                maxClaimableSupply: 0,
                maxClaimablePerWallet: 0,
                waitInSeconds: 0,
                merkleRootHash: utils_exports.hexZeroPad([0], 32),
                snapshot: []
              }];
            } else if (claimConditions.length > 1) {
              throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
            }
          }
          if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper) || _this2.isNewMultiphaseDrop(_this2.contractWrapper)) {
            claimConditionsProcessed.forEach((cc) => {
              if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === void 0 || cc.maxClaimablePerWallet === "unlimited")) {
                throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nSet it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n\nex:\ncontract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
              }
              if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === "0" && cc.snapshot.map((s) => {
                if (typeof s === "string") {
                  return 0;
                } else {
                  return Number(s.maxClaimable?.toString() || 0);
                }
              }).reduce((acc, current) => {
                return acc + current;
              }, 0) === 0) {
                throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
              }
            });
          }
          const {
            snapshotInfos,
            sortedConditions
          } = await processClaimConditionInputs(claimConditionsProcessed, 0, _this2.contractWrapper.getProvider(), _this2.storage, _this2.getSnapshotFormatVersion());
          snapshotInfos.forEach((s) => {
            merkleInfo[s.merkleRoot] = s.snapshotUri;
          });
          return {
            tokenId,
            sortedConditions
          };
        }));
        const metadata = await _this2.metadata.get();
        const encoded = [];
        for (const key of Object.keys(metadata.merkle || {})) {
          merkleInfo[key] = metadata.merkle[key];
        }
        if (!(0, import_fast_deep_equal.default)(metadata.merkle, merkleInfo)) {
          const mergedMetadata = await _this2.metadata.parseInputMetadata({
            ...metadata,
            merkle: merkleInfo
          });
          const contractURI = await _this2.metadata._parseAndUploadMetadata(mergedMetadata);
          if (hasFunction("setContractURI", _this2.contractWrapper)) {
            const contractEncoder = new ContractEncoder(_this2.contractWrapper);
            encoded.push(contractEncoder.encode("setContractURI", [contractURI]));
          } else {
            throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
          }
        }
        processedClaimConditions.forEach((_ref2) => {
          let {
            tokenId,
            sortedConditions
          } = _ref2;
          const baseContractEncoder = new ContractEncoder(_this2.contractWrapper);
          if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {
            const legacyContractEncoder = new ContractEncoder(_this2.contractWrapper);
            encoded.push(legacyContractEncoder.encode("setClaimConditions", [tokenId, abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
          } else if (_this2.isLegacyMultiPhaseDrop(_this2.contractWrapper)) {
            encoded.push(baseContractEncoder.encode("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
          } else if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper)) {
            encoded.push(baseContractEncoder.encode("setClaimConditions", [tokenId, abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
          } else if (_this2.isNewMultiphaseDrop(_this2.contractWrapper)) {
            encoded.push(baseContractEncoder.encode("setClaimConditions", [tokenId, sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
          } else {
            throw new Error("Contract does not support claim conditions");
          }
        });
        if (hasFunction("multicall", _this2.contractWrapper)) {
          return Transaction.fromContractWrapper({
            contractWrapper: _this2.contractWrapper,
            method: "multicall",
            args: [encoded]
          });
        }
        throw new Error("Contract does not support multicall");
      };
    })()));
    __publicField(this, "update", buildTransactionFunction(async (tokenId, index, claimConditionInput) => {
      const existingConditions = await this.getAll(tokenId);
      const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
      return await this.set.prepare(tokenId, newConditionInputs);
    }));
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getActive(tokenId, options) {
    const mc = await this.get(tokenId);
    const metadata = await this.metadata.get();
    return await transformResultToClaimCondition(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false);
  }
  async get(tokenId, conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", [tokenId]);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [tokenId, id]);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", [tokenId]);
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [tokenId, id]);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  async getAll(tokenId, options) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const claimCondition = await this.contractWrapper.read("claimCondition", [tokenId]);
      const startId = claimCondition.currentStartId.toNumber();
      const count = claimCondition.count.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(await this.get(tokenId, i));
      }
      const metadata = await this.metadata.get();
      return Promise.all(conditions.map((c) => transformResultToClaimCondition(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));
    } else {
      return [await this.getActive(tokenId, options)];
    }
  }
  async canClaim(tokenId, quantity, addressToCheck) {
    if (addressToCheck) {
      addressToCheck = await resolveAddress(addressToCheck);
    }
    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;
  }
  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    const resolvedAddress = await resolveAddress(addressToCheck);
    try {
      claimCondition = await this.getActive(tokenId);
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition") || includesErrorMessage(err, "DropNoActiveCondition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
        return reasons;
      }
    }
    const merkleRootArray = utils_exports.stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(tokenId, resolvedAddress);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(tokenId, quantity, false, resolvedAddress);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.proofs, claimVerification.maxClaimable]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [tokenId, resolvedAddress, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            }]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.read("verifyClaim", [tokenId, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
            await this.contractWrapper.read("verifyClaim", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          }
        } catch (e) {
          console.warn("Merkle proof verification failed:", "reason" in e ? e.reason || e.errorName : e);
          const reason = e.reason || e.errorName;
          switch (reason) {
            case "!Qty":
            case "DropClaimExceedLimit":
              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
              break;
            case "!PriceOrCurrency":
            case "DropClaimInvalidTokenPrice":
              reasons.push(ClaimEligibility.WrongPriceOrCurrency);
              break;
            case "!MaxSupply":
            case "DropClaimExceedMaxSupply":
              reasons.push(ClaimEligibility.NotEnoughSupply);
              break;
            case "cant claim yet":
            case "DropClaimNotStarted":
              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);
              break;
            default: {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              break;
            }
          }
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      let claimedSupply = BigNumber.from(0);
      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, 0);
      try {
        claimedSupply = await this.getSupplyClaimedByWallet(tokenId, resolvedAddress);
      } catch (e) {
      }
      if (allowListEntry) {
        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, 0);
      }
      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantity))) {
        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
        return reasons;
      }
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [tokenId, activeConditionIndex, resolvedAddress]);
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [tokenId, resolvedAddress]);
    }
    const now = BigNumber.from(Date.now()).div(1e3);
    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
      if (timestampForNextClaim.eq(lib_exports.MaxUint256)) {
        reasons.push(ClaimEligibility.AlreadyClaimed);
      } else {
        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
      }
      return reasons;
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(quantity);
      const provider = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider.getBalance(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const IERC20ABI = (await import("./IERC20-GHSR35K6.js")).default;
        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, IERC20ABI, {}, this.storage);
        const balance = await erc20.read("balanceOf", [resolvedAddress]);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {
    const claimCondition = await this.get(tokenId, claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = utils_exports.stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const metadata = await this.metadata.get();
      const resolvedAddress = await resolveAddress(claimerAddress);
      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  async getSupplyClaimedByWallet(tokenId, walletAddress) {
    const resolvedAddress = await resolveAddress(walletAddress);
    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [tokenId, resolvedAddress]);
    }
    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const activeClaimConditionId = await this.contractWrapper.read("getActiveClaimConditionId", [tokenId]);
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [tokenId, activeClaimConditionId, resolvedAddress]);
    }
    throw new Error("This contract does not support the getSupplyClaimedByWallet function");
  }
  async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {
    const addressToClaim = await resolveAddress(address ? address : await this.contractWrapper.getSignerAddress());
    return prepareClaim(addressToClaim, quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {
    const resolvedAddress = await resolveAddress(destinationAddress);
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, utils_exports.toUtf8Bytes("")];
    }
    return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, utils_exports.toUtf8Bytes("")];
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    if (options?.pricePerToken) {
      throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(tokenId, quantity, options?.checkERC20Allowance || true);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC1155ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
};
var AirdropAddressInput = (() => z.object({
  address: AddressOrEnsSchema,
  quantity: AmountSchema.default(1)
}))();
var AirdropInputSchema = (() => z.union([z.array(z.string()).transform(async (strings) => await Promise.all(strings.map((address) => AirdropAddressInput.parseAsync({
  address
})))), z.array(AirdropAddressInput)]))();
var ERC1155Claimable = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_EDITION_CLAIM_CUSTOM.name);
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {
      return await this.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }));
    this.contractWrapper = contractWrapper;
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    let overrides = {};
    if (options && options.pricePerToken) {
      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
    }
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: [await resolveAddress(destinationAddress), tokenId, quantity],
      overrides
    });
  }
};
var Erc1155ClaimableWithConditions = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_CLAIM_CONDITIONS_V2.name);
    __publicField(this, "to", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {
      return await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);
    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);
  }
};
var Erc1155SignatureMintable = class {
  constructor(contractWrapper, storage, roles) {
    __publicField(this, "featureName", FEATURE_EDITION_SIGNATURE_MINTABLE.name);
    __publicField(this, "mint", buildTransactionFunction(async (signedPayload) => {
      const mintRequest = signedPayload.payload;
      const signature = signedPayload.signature;
      const [message, overrides] = await Promise.all([this.mapPayloadToContractStruct(mintRequest), this.contractWrapper.getCallOverrides()]);
      await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintWithSignature",
        args: [message, signature],
        overrides,
        parse: (receipt) => {
          const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
          if (t.length === 0) {
            throw new Error("No MintWithSignature event found");
          }
          const id = t[0].args.tokenIdMinted;
          return {
            id,
            receipt
          };
        }
      });
    }));
    __publicField(this, "mintBatch", buildTransactionFunction(async (signedPayloads) => {
      const contractStructs = await Promise.all(signedPayloads.map((s) => this.mapPayloadToContractStruct(s.payload)));
      const contractPayloads = signedPayloads.map((s, index) => {
        const message = contractStructs[index];
        const signature = s.signature;
        const price = s.payload.price;
        if (BigNumber.from(price).gt(0)) {
          throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
        }
        return {
          message,
          signature
        };
      });
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = contractPayloads.map((p) => {
        return contractEncoder.encode("mintWithSignature", [p.message, p.signature]);
      });
      if (hasFunction("multicall", this.contractWrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [encoded],
          parse: (receipt) => {
            const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
            if (events.length === 0) {
              throw new Error("No MintWithSignature event found");
            }
            return events.map((log) => ({
              id: log.args.tokenIdMinted,
              receipt
            }));
          }
        });
      } else {
        throw new Error("Multicall not supported on this contract!");
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.roles = roles;
  }
  async verify(signedPayload) {
    const mintRequest = signedPayload.payload;
    const signature = signedPayload.signature;
    const message = await this.mapPayloadToContractStruct(mintRequest);
    const verification = await this.contractWrapper.read("verify", [message, signature]);
    return verification[0];
  }
  async generate(payloadToSign) {
    const payload = {
      ...payloadToSign,
      tokenId: lib_exports.MaxUint256
    };
    return this.generateFromTokenId(payload);
  }
  async generateFromTokenId(payloadToSign) {
    const payloads = await this.generateBatchFromTokenIds([payloadToSign]);
    return payloads[0];
  }
  async generateBatch(payloadsToSign) {
    const payloads = payloadsToSign.map((payload) => ({
      ...payload,
      tokenId: lib_exports.MaxUint256
    }));
    return this.generateBatchFromTokenIds(payloads);
  }
  async generateBatchFromTokenIds(payloadsToSign) {
    const signer = this.contractWrapper.getSigner();
    invariant(signer, "No signer available");
    await this.roles?.verify(["minter"], await signer.getAddress());
    const parsedRequests = await Promise.all(payloadsToSign.map((m) => Signature1155PayloadInputWithTokenId.parseAsync(m)));
    const metadatas = parsedRequests.map((r) => r.metadata);
    const [uris, chainId, contractInfo] = await Promise.all([uploadOrExtractURIs(metadatas, this.storage), this.contractWrapper.getChainID(), getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider())]);
    const finalPayloads = await Promise.all(parsedRequests.map((m, i) => Signature1155PayloadOutput.parseAsync({
      ...m,
      uri: uris[i]
    })));
    const contractStructs = await Promise.all(finalPayloads.map((finalPayload) => this.mapPayloadToContractStruct(finalPayload)));
    const isLegacyContract = contractInfo?.type === "TokenERC1155";
    const signatures = await Promise.all(contractStructs.map((contractStruct) => this.contractWrapper.signTypedData(
      signer,
      {
        name: isLegacyContract ? "TokenERC1155" : "SignatureMintERC1155",
        version: "1",
        chainId,
        verifyingContract: this.contractWrapper.address
      },
      {
        MintRequest: MintRequest1155
      },
      contractStruct
    )));
    return signatures.map((signature, index) => ({
      payload: finalPayloads[index],
      signature: signature.toString()
    }));
  }
  async mapPayloadToContractStruct(mintRequest) {
    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
    return {
      to: mintRequest.to,
      tokenId: mintRequest.tokenId,
      uri: mintRequest.uri,
      quantity: mintRequest.quantity,
      pricePerToken: normalizedPricePerToken,
      currency: mintRequest.currencyAddress,
      validityStartTimestamp: mintRequest.mintStartTime,
      validityEndTimestamp: mintRequest.mintEndTime,
      uid: mintRequest.uid,
      royaltyRecipient: mintRequest.royaltyRecipient,
      royaltyBps: mintRequest.royaltyBps,
      primarySaleRecipient: mintRequest.primarySaleRecipient
    };
  }
};
var Erc1155Burnable = class {
  constructor(contractWrapper) {
    __publicField(this, "featureName", FEATURE_EDITION_BURNABLE.name);
    __publicField(this, "tokens", buildTransactionFunction(async (tokenId, amount) => {
      const account = await this.contractWrapper.getSignerAddress();
      return this.from.prepare(account, tokenId, amount);
    }));
    __publicField(this, "from", buildTransactionFunction(async (account, tokenId, amount) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burn",
        args: [await resolveAddress(account), tokenId, amount]
      });
    }));
    __publicField(this, "batch", buildTransactionFunction(async (tokenIds, amounts) => {
      const account = await this.contractWrapper.getSignerAddress();
      return this.batchFrom.prepare(account, tokenIds, amounts);
    }));
    __publicField(this, "batchFrom", buildTransactionFunction(async (account, tokenIds, amounts) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "burnBatch",
        args: [await resolveAddress(account), tokenIds, amounts]
      });
    }));
    this.contractWrapper = contractWrapper;
  }
};
var Erc1155Enumerable = class {
  constructor(erc1155, contractWrapper) {
    __publicField(this, "featureName", FEATURE_EDITION_ENUMERABLE.name);
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
  }
  async all(queryParams) {
    const start = BigNumber.from(queryParams?.start || 0).toNumber();
    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();
    const maxId = Math.min((await this.totalCount()).toNumber(), start + count);
    return await Promise.all([...Array(maxId - start).keys()].map((i) => this.erc1155.get((start + i).toString())));
  }
  async totalCount() {
    return await this.contractWrapper.read("nextTokenIdToMint", []);
  }
  async totalCirculatingSupply(tokenId) {
    return await this.contractWrapper.read("totalSupply", [tokenId]);
  }
  async owned(walletAddress, queryParams) {
    const [address, maxId] = await Promise.all([resolveAddress(walletAddress || await this.contractWrapper.getSignerAddress()), this.contractWrapper.read("nextTokenIdToMint", [])]);
    const balances = await this.contractWrapper.read("balanceOfBatch", [Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys())]);
    let ownedBalances = balances.map((b, i) => {
      return {
        tokenId: i,
        balance: b
      };
    }).filter((b) => b.balance.gt(0));
    if (queryParams) {
      const start = queryParams?.start || 0;
      const count = queryParams?.count || DEFAULT_QUERY_ALL_COUNT;
      ownedBalances = ownedBalances.slice(start, start + count);
    }
    const nfts = (await Promise.all(ownedBalances.map((item) => this.erc1155.get(item.tokenId.toString())))).map((editionMetadata, index) => ({
      ...editionMetadata,
      owner: address,
      quantityOwned: ownedBalances[index].balance.toString()
    }));
    return nfts;
  }
};
var Erc1155LazyMintable = class {
  constructor(erc1155, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_LAZY_MINTABLE_V2.name);
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      const startFileNumber = await this.erc1155.nextTokenIdToMint();
      const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);
      const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
      for (let i = 0; i < batch.length; i++) {
        const uri = batch[i].substring(0, batch[i].lastIndexOf("/"));
        if (baseUri !== uri) {
          throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
        }
      }
      const parse = (receipt) => {
        const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = event[0].args.endTokenId;
        const results = [];
        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {
          results.push({
            id,
            receipt,
            data: () => this.erc1155.getTokenMetadata(id)
          });
        }
        return results;
      };
      const prebuiltInfo = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());
      if (this.isLegacyEditionDropContract(this.contractWrapper, prebuiltInfo)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [batch.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`],
          parse
        });
      } else {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "lazyMint",
          args: [batch.length, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`, utils_exports.toUtf8Bytes("")],
          parse
        });
      }
    }));
    __publicField(this, "updateMetadata", buildTransactionFunction(async (tokenId, metadata, options) => {
      const batchCount = await this.contractWrapper.read("getBaseURICount", []);
      if (batchCount.eq(0)) {
        throw new Error("No base URI set. Please set a base URI before updating metadata");
      }
      const targetTokenId = BigNumber.from(tokenId);
      let startTokenId = BigNumber.from(0);
      let endTokenId = BigNumber.from(0);
      let batchIndex = 0;
      for (let i = 0; i < batchCount.toNumber(); i++) {
        batchIndex = i;
        endTokenId = await this.contractWrapper.read("getBatchIdAtIndex", [batchIndex]);
        if (endTokenId.gt(targetTokenId)) {
          break;
        }
        startTokenId = endTokenId;
      }
      const range = Array.from({
        length: endTokenId.sub(startTokenId).toNumber()
      }, (v, k) => k + startTokenId.toNumber());
      const metadatas = await Promise.all(range.map((id) => this.erc1155.getTokenMetadata(id)));
      const newMetadatas = [];
      for (let i = 0; i < metadatas.length; i++) {
        const {
          id,
          uri,
          ...rest
        } = metadatas[i];
        if (BigNumber.from(targetTokenId).eq(BigNumber.from(id))) {
          newMetadatas.push(metadata);
        } else {
          newMetadatas.push(rest);
        }
      }
      const batch = await uploadOrExtractURIs(newMetadatas, this.storage, startTokenId.toNumber(), options);
      const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "updateBatchBaseURI",
        args: [batchIndex, `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`]
      });
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.revealer = this.detectErc1155Revealable();
  }
  detectErc1155Revealable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Revealable")) {
      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());
    }
    return void 0;
  }
  isLegacyEditionDropContract(contractWrapper, info) {
    return info && info.type === "DropERC1155" && info.version < 3 || false;
  }
};
var Erc1155BatchMintable = class {
  constructor(erc1155, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_BATCH_MINTABLE.name);
    __publicField(this, "to", buildTransactionFunction(async (to, metadataWithSupply) => {
      const metadatas = metadataWithSupply.map((a) => a.metadata);
      const supplies = metadataWithSupply.map((a) => a.supply);
      const uris = await uploadOrExtractURIs(metadatas, this.storage);
      const resolvedAddress = await resolveAddress(to);
      const contractEncoder = new ContractEncoder(this.contractWrapper);
      const encoded = await Promise.all(uris.map(async (uri, index) => contractEncoder.encode("mintTo", [resolvedAddress, lib_exports.MaxUint256, uri, supplies[index]])));
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [encoded],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
          if (events.length === 0 || events.length < metadatas.length) {
            throw new Error("TokenMinted event not found, minting failed");
          }
          return events.map((e) => {
            const id = e.args.tokenIdMinted;
            return {
              id,
              receipt,
              data: () => this.erc1155.get(id)
            };
          });
        }
      });
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
  }
};
var Erc1155Mintable = class {
  constructor(erc1155, contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_EDITION_MINTABLE.name);
    __publicField(this, "to", buildTransactionFunction(async (to, metadataWithSupply) => {
      const tx = await this.getMintTransaction(to, metadataWithSupply);
      tx.setParse((receipt) => {
        const event = this.contractWrapper.parseLogs("TransferSingle", receipt?.logs);
        if (event.length === 0) {
          throw new Error("TransferSingleEvent event not found");
        }
        const id = event[0].args.id;
        return {
          id,
          receipt,
          data: () => this.erc1155.get(id.toString())
        };
      });
      return tx;
    }));
    __publicField(this, "additionalSupplyTo", buildTransactionFunction(async (to, tokenId, additionalSupply) => {
      const metadata = await this.erc1155.getTokenMetadata(tokenId);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "mintTo",
        args: [await resolveAddress(to), tokenId, metadata.uri, additionalSupply],
        parse: (receipt) => {
          return {
            id: BigNumber.from(tokenId),
            receipt,
            data: () => this.erc1155.get(tokenId)
          };
        }
      });
    }));
    this.erc1155 = erc1155;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.batch = this.detectErc1155BatchMintable();
  }
  async getMintTransaction(to, metadataWithSupply) {
    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "mintTo",
      args: [await resolveAddress(to), lib_exports.MaxUint256, uri, metadataWithSupply.supply]
    });
  }
  detectErc1155BatchMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155BatchMintable")) {
      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);
    }
  }
};
var Erc1155 = class {
  constructor(contractWrapper, storage, chainId) {
    __publicField(this, "featureName", FEATURE_EDITION.name);
    __publicField(this, "transfer", buildTransactionFunction((() => {
      var _this = this;
      return async function(to, tokenId, amount) {
        let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0];
        const from = await _this.contractWrapper.getSignerAddress();
        return Transaction.fromContractWrapper({
          contractWrapper: _this.contractWrapper,
          method: "safeTransferFrom",
          args: [from, await resolveAddress(to), tokenId, amount, data]
        });
      };
    })()));
    __publicField(this, "transferBatch", buildTransactionFunction((() => {
      var _this2 = this;
      return async function(to, tokenIds, amounts, fromAddress) {
        let data = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];
        const from = fromAddress ? await resolveAddress(fromAddress) : await _this2.contractWrapper.getSignerAddress();
        return Transaction.fromContractWrapper({
          contractWrapper: _this2.contractWrapper,
          method: "safeBatchTransferFrom",
          args: [from, await resolveAddress(to), tokenIds, amounts, data]
        });
      };
    })()));
    __publicField(this, "transferFrom", buildTransactionFunction((() => {
      var _this3 = this;
      return async function(from, to, tokenId, amount) {
        let data = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];
        return Transaction.fromContractWrapper({
          contractWrapper: _this3.contractWrapper,
          method: "safeTransferFrom",
          args: [await resolveAddress(from), await resolveAddress(to), tokenId, amount, data]
        });
      };
    })()));
    __publicField(this, "setApprovalForAll", buildTransactionFunction(async (operator, approved) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "setApprovalForAll",
        args: [operator, approved]
      });
    }));
    __publicField(this, "airdrop", buildTransactionFunction((() => {
      var _this4 = this;
      return async function(tokenId, addresses, fromAddress) {
        let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0];
        const from = fromAddress ? await resolveAddress(fromAddress) : await _this4.contractWrapper.getSignerAddress();
        const balanceOf = await _this4.balanceOf(from, tokenId);
        const input = await AirdropInputSchema.parseAsync(addresses);
        const totalToAirdrop = input.reduce((prev, curr) => {
          return BigNumber.from(prev).add(BigNumber.from(curr?.quantity || 1));
        }, BigNumber.from(0));
        if (balanceOf.lt(BigNumber.from(totalToAirdrop))) {
          throw new Error(`The caller owns ${balanceOf.toString()} NFTs, but wants to airdrop ${totalToAirdrop.toString()} NFTs.`);
        }
        const contractEncoder = new ContractEncoder(_this4.contractWrapper);
        const encoded = input.map((_ref) => {
          let {
            address: to,
            quantity
          } = _ref;
          return contractEncoder.encode("safeTransferFrom", [from, to, tokenId, quantity, data]);
        });
        return Transaction.fromContractWrapper({
          contractWrapper: _this4.contractWrapper,
          method: "multicall",
          args: [encoded]
        });
      };
    })()));
    __publicField(this, "mint", buildTransactionFunction(async (metadataWithSupply) => {
      return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    }));
    __publicField(this, "mintTo", buildTransactionFunction(async (receiver, metadataWithSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).to.prepare(receiver, metadataWithSupply);
    }));
    __publicField(this, "mintAdditionalSupply", buildTransactionFunction(async (tokenId, additionalSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);
    }));
    __publicField(this, "mintAdditionalSupplyTo", buildTransactionFunction(async (receiver, tokenId, additionalSupply) => {
      return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(receiver, tokenId, additionalSupply);
    }));
    __publicField(this, "mintBatch", buildTransactionFunction(async (metadataWithSupply) => {
      return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    }));
    __publicField(this, "mintBatchTo", buildTransactionFunction(async (receiver, metadataWithSupply) => {
      return assertEnabled(this.mintable?.batch, FEATURE_EDITION_BATCH_MINTABLE).to.prepare(receiver, metadataWithSupply);
    }));
    __publicField(this, "burn", buildTransactionFunction(async (tokenId, amount) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).tokens.prepare(tokenId, amount);
    }));
    __publicField(this, "burnFrom", buildTransactionFunction(async (account, tokenId, amount) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).from.prepare(account, tokenId, amount);
    }));
    __publicField(this, "burnBatch", buildTransactionFunction(async (tokenIds, amounts) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batch.prepare(tokenIds, amounts);
    }));
    __publicField(this, "burnBatchFrom", buildTransactionFunction(async (account, tokenIds, amounts) => {
      return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batchFrom.prepare(account, tokenIds, amounts);
    }));
    __publicField(this, "lazyMint", buildTransactionFunction(async (metadatas, options) => {
      return assertEnabled(this.lazyMintable, FEATURE_EDITION_LAZY_MINTABLE_V2).lazyMint.prepare(metadatas, options);
    }));
    __publicField(this, "updateMetadata", buildTransactionFunction(async (tokenId, metadata) => {
      if (this.lazyMintable) {
        return this.lazyMintable.updateMetadata.prepare(tokenId, metadata);
      } else if (detectContractFeature(this.contractWrapper, "ERC1155UpdatableMetadata")) {
        const uri = await this.storage.upload(metadata);
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setTokenURI",
          args: [tokenId, uri]
        });
      } else {
        throw new ExtensionNotImplementedError(FEATURE_EDITION_UPDATABLE_METADATA);
      }
    }));
    __publicField(this, "claim", buildTransactionFunction(async (tokenId, quantity, options) => {
      return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options);
    }));
    __publicField(this, "claimTo", buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {
      const claimWithConditions = this.claimWithConditions;
      const claim = this.claimCustom;
      if (claimWithConditions) {
        return claimWithConditions.to.prepare(destinationAddress, tokenId, quantity, options);
      }
      if (claim) {
        return claim.to.prepare(destinationAddress, tokenId, quantity, options);
      }
      throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.query = this.detectErc1155Enumerable();
    this.mintable = this.detectErc1155Mintable();
    this.burnable = this.detectErc1155Burnable();
    this.lazyMintable = this.detectErc1155LazyMintable();
    this.signatureMintable = this.detectErc1155SignatureMintable();
    this.claimCustom = this.detectErc1155Claimable();
    this.claimWithConditions = this.detectErc1155ClaimableWithConditions();
    this._chainId = chainId;
  }
  get chainId() {
    return this._chainId;
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async get(tokenId) {
    const [supply, metadata] = await Promise.all([this.contractWrapper.read("totalSupply", [tokenId]).catch(() => BigNumber.from(0)), this.getTokenMetadata(tokenId).catch(() => ({
      id: tokenId.toString(),
      uri: "",
      ...FALLBACK_METADATA
    }))]);
    return {
      owner: lib_exports.AddressZero,
      metadata,
      type: "ERC1155",
      supply: supply.toString()
    };
  }
  async totalSupply(tokenId) {
    if (detectContractFeature(this.contractWrapper, "ERC1155Supply")) {
      return await this.contractWrapper.read("totalSupply", [tokenId]);
    } else {
      throw new ExtensionNotImplementedError(FEATURE_EDITION_SUPPLY);
    }
  }
  async balanceOf(address, tokenId) {
    return await this.contractWrapper.read("balanceOf", [await resolveAddress(address), tokenId]);
  }
  async balance(tokenId) {
    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);
  }
  async isApproved(address, operator) {
    return await this.contractWrapper.read("isApprovedForAll", [await resolveAddress(address), await resolveAddress(operator)]);
  }
  async nextTokenIdToMint() {
    if (hasFunction("nextTokenIdToMint", this.contractWrapper)) {
      return await this.contractWrapper.read("nextTokenIdToMint", []);
    } else {
      throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint");
    }
  }
  async getAll(queryParams) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).all(queryParams);
  }
  async totalCount() {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCount();
  }
  async totalCirculatingSupply(tokenId) {
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCirculatingSupply(tokenId);
  }
  async getOwned(walletAddress, queryParams) {
    if (walletAddress) {
      walletAddress = await resolveAddress(walletAddress);
    }
    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).owned(walletAddress, queryParams);
  }
  async getMintTransaction(receiver, metadataWithSupply) {
    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).getMintTransaction(receiver, metadataWithSupply);
  }
  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
    const claimWithConditions = this.claimWithConditions;
    const claim = this.claimCustom;
    if (claimWithConditions) {
      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }
    if (claim) {
      return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    }
    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);
  }
  get claimConditions() {
    return assertEnabled(this.claimWithConditions, FEATURE_EDITION_CLAIM_CONDITIONS_V2).conditions;
  }
  get signature() {
    return assertEnabled(this.signatureMintable, FEATURE_EDITION_SIGNATURE_MINTABLE);
  }
  get revealer() {
    return assertEnabled(this.lazyMintable?.revealer, FEATURE_EDITION_REVEALABLE);
  }
  async getTokenMetadata(tokenId) {
    const tokenUri = await this.contractWrapper.read("uri", [tokenId]);
    if (!tokenUri) {
      throw new NotFoundError();
    }
    return fetchTokenMetadata(tokenId, tokenUri, this.storage);
  }
  detectErc1155Enumerable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Enumerable")) {
      return new Erc1155Enumerable(this, this.contractWrapper);
    }
  }
  detectErc1155Mintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Mintable")) {
      return new Erc1155Mintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Burnable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155Burnable")) {
      return new Erc1155Burnable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155LazyMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV1") || detectContractFeature(this.contractWrapper, "ERC1155LazyMintableV2")) {
      return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155SignatureMintable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155SignatureMintable")) {
      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);
    }
    return void 0;
  }
  detectErc1155Claimable() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimCustom")) {
      return new ERC1155Claimable(this.contractWrapper);
    }
    return void 0;
  }
  detectErc1155ClaimableWithConditions() {
    if (detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimConditionsV2") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV1") || detectContractFeature(this.contractWrapper, "ERC1155ClaimPhasesV2")) {
      return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);
    }
    return void 0;
  }
};

export {
  DropErc1155ClaimConditions,
  Erc1155SignatureMintable,
  Erc1155
};
//# sourceMappingURL=chunk-OYFG36NZ.js.map

import {
  ClaimEligibility,
  SnapshotFormatVersion,
  abstractContractModelToLegacy,
  abstractContractModelToNew,
  convertQuantityToBigNumber,
  fetchSnapshotEntryForAddress,
  legacyContractModelToAbstract,
  newContractModelToAbstract,
  prepareClaim,
  processClaimConditionInputs,
  require_fast_deep_equal,
  transformResultToClaimCondition,
  updateExistingClaimConditions
} from "./chunk-INCOK333.js";
import {
  ContractEncoder,
  detectContractFeature,
  hasFunction,
  isNativeToken
} from "./chunk-LXY7U6R5.js";
import {
  AmountSchema,
  ContractWrapper,
  Transaction,
  buildTransactionFunction,
  includesErrorMessage,
  isNode,
  resolveAddress
} from "./chunk-CFECTRPO.js";
import {
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField,
  __toESM
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-8a3ca2fb.browser.esm.js
init_shim();
init_lib();
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var DropClaimConditions = class {
  constructor(contractWrapper, metadata, storage) {
    __publicField(this, "set", buildTransactionFunction((() => {
      var _this = this;
      return async function(claimConditionInputs) {
        let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        let claimConditionsProcessed = claimConditionInputs;
        if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {
          resetClaimEligibilityForAll = true;
          if (claimConditionInputs.length === 0) {
            claimConditionsProcessed = [{
              startTime: new Date(0),
              currencyAddress: lib_exports.AddressZero,
              price: 0,
              maxClaimableSupply: 0,
              maxClaimablePerWallet: 0,
              waitInSeconds: 0,
              merkleRootHash: utils_exports.hexZeroPad([0], 32),
              snapshot: []
            }];
          } else if (claimConditionInputs.length > 1) {
            throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
          }
        }
        if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {
          claimConditionsProcessed.forEach((cc) => {
            if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === void 0 || cc.maxClaimablePerWallet === "unlimited")) {
              throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\nExample: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\ncontract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
            }
            if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === "0" && cc.snapshot.map((s) => {
              if (typeof s === "string") {
                return 0;
              } else {
                return Number(s.maxClaimable?.toString() || 0);
              }
            }).reduce((acc, current) => {
              return acc + current;
            }, 0) === 0) {
              throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
            }
          });
        }
        const {
          snapshotInfos,
          sortedConditions
        } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());
        const merkleInfo = {};
        snapshotInfos.forEach((s) => {
          merkleInfo[s.merkleRoot] = s.snapshotUri;
        });
        const metadata = await _this.metadata.get();
        const encoded = [];
        if (!(0, import_fast_deep_equal.default)(metadata.merkle, merkleInfo)) {
          const mergedMetadata = await _this.metadata.parseInputMetadata({
            ...metadata,
            merkle: merkleInfo
          });
          const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);
          if (hasFunction("setContractURI", _this.contractWrapper)) {
            const contractEncoder = new ContractEncoder(_this.contractWrapper);
            encoded.push(contractEncoder.encode("setContractURI", [contractURI]));
          } else {
            throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
          }
        }
        const cw = _this.contractWrapper;
        const baseContractEncoder = new ContractEncoder(cw);
        if (_this.isLegacySinglePhaseDrop(cw)) {
          const contractEncoderLegacy = new ContractEncoder(cw);
          encoded.push(contractEncoderLegacy.encode("setClaimConditions", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));
        } else if (_this.isLegacyMultiPhaseDrop(cw)) {
          encoded.push(baseContractEncoder.encode("setClaimConditions", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));
        } else if (_this.isNewSinglePhaseDrop(cw)) {
          encoded.push(baseContractEncoder.encode("setClaimConditions", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));
        } else if (_this.isNewMultiphaseDrop(cw)) {
          encoded.push(baseContractEncoder.encode("setClaimConditions", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));
        } else {
          throw new Error("Contract does not support claim conditions");
        }
        if (hasFunction("multicall", _this.contractWrapper)) {
          return Transaction.fromContractWrapper({
            contractWrapper: _this.contractWrapper,
            method: "multicall",
            args: [encoded]
          });
        }
        throw new Error("Contract does not support multicall");
      };
    })()));
    __publicField(this, "update", buildTransactionFunction(async (index, claimConditionInput) => {
      const existingConditions = await this.getAll();
      const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);
      return await this.set.prepare(newConditionInputs);
    }));
    this.storage = storage;
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
  }
  async getActive(options) {
    const [cc, metadata, tokenDecimals] = await Promise.all([this.get(), this.metadata.get(), this.getTokenDecimals()]);
    return await transformResultToClaimCondition(cc, tokenDecimals, this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);
  }
  async get(conditionId) {
    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", []);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", []);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [id]);
      return legacyContractModelToAbstract(contractModel);
    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      const contractModel = await this.contractWrapper.read("claimCondition", []);
      return newContractModelToAbstract(contractModel);
    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const id = conditionId !== void 0 ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", []);
      const contractModel = await this.contractWrapper.read("getClaimConditionById", [id]);
      return newContractModelToAbstract(contractModel);
    } else {
      throw new Error("Contract does not support claim conditions");
    }
  }
  async getAll(options) {
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      const [currentStartId, countBn] = await this.contractWrapper.read("claimCondition", []);
      const startId = currentStartId.toNumber();
      const count = countBn.toNumber();
      const conditions = [];
      for (let i = startId; i < startId + count; i++) {
        conditions.push(this.get(i));
      }
      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);
      return Promise.all(fetchedConditions.map((c) => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));
    } else {
      return [await this.getActive(options)];
    }
  }
  async canClaim(quantity, addressToCheck) {
    if (addressToCheck) {
      addressToCheck = await resolveAddress(addressToCheck);
    }
    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;
  }
  async getClaimIneligibilityReasons(quantity, addressToCheck) {
    const reasons = [];
    let activeConditionIndex;
    let claimCondition;
    if (addressToCheck === void 0) {
      try {
        addressToCheck = await this.contractWrapper.getSignerAddress();
      } catch (err) {
        console.warn("failed to get signer address", err);
      }
    }
    if (!addressToCheck) {
      return [ClaimEligibility.NoWallet];
    }
    const [resolvedAddress, decimals] = await Promise.all([resolveAddress(addressToCheck), this.getTokenDecimals()]);
    const quantityWithDecimals = utils_exports.parseUnits(AmountSchema.parse(quantity), decimals);
    try {
      claimCondition = await this.getActive();
    } catch (err) {
      if (includesErrorMessage(err, "!CONDITION") || includesErrorMessage(err, "no active mint condition") || includesErrorMessage(err, "DropNoActiveCondition")) {
        reasons.push(ClaimEligibility.NoClaimConditionSet);
        return reasons;
      }
      console.warn("failed to get active claim condition", err);
      reasons.push(ClaimEligibility.Unknown);
      return reasons;
    }
    if (claimCondition.availableSupply !== "unlimited") {
      const supplyWithDecimals = utils_exports.parseUnits(claimCondition.availableSupply, decimals);
      if (supplyWithDecimals.lt(quantityWithDecimals)) {
        reasons.push(ClaimEligibility.NotEnoughSupply);
        return reasons;
      }
    }
    const merkleRootArray = utils_exports.stripZeros(claimCondition.merkleRootHash);
    const hasAllowList = merkleRootArray.length > 0;
    let allowListEntry = null;
    if (hasAllowList) {
      allowListEntry = await this.getClaimerProofs(resolvedAddress);
      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
        reasons.push(ClaimEligibility.AddressNotAllowed);
        return reasons;
      }
      if (allowListEntry) {
        try {
          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);
          let validMerkleProof;
          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [resolvedAddress, quantity, {
              proof: claimVerification.proofs,
              maxQuantityInAllowlist: claimVerification.maxClaimable
            }]);
            if (!validMerkleProof) {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              return reasons;
            }
          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            await this.contractWrapper.read("verifyClaim", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
            await this.contractWrapper.read("verifyClaim", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
              proof: claimVerification.proofs,
              quantityLimitPerWallet: claimVerification.maxClaimable,
              currency: claimVerification.currencyAddressInProof,
              pricePerToken: claimVerification.priceInProof
            }]);
          }
        } catch (e) {
          console.warn("Merkle proof verification failed:", "reason" in e ? e.reason || e.errorName : e);
          const reason = e.reason || e.errorName;
          switch (reason) {
            case "!Qty":
            case "DropClaimExceedLimit":
              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
              break;
            case "!PriceOrCurrency":
            case "DropClaimInvalidTokenPrice":
              reasons.push(ClaimEligibility.WrongPriceOrCurrency);
              break;
            case "!MaxSupply":
            case "DropClaimExceedMaxSupply":
              reasons.push(ClaimEligibility.NotEnoughSupply);
              break;
            case "cant claim yet":
            case "DropClaimNotStarted":
              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);
              break;
            default: {
              reasons.push(ClaimEligibility.AddressNotAllowed);
              break;
            }
          }
          return reasons;
        }
      }
    }
    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
      let claimedSupply = BigNumber.from(0);
      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);
      try {
        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);
      } catch (e) {
      }
      if (allowListEntry) {
        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);
      }
      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {
        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);
        return reasons;
      }
      if (!hasAllowList || hasAllowList && !allowListEntry) {
        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {
          reasons.push(ClaimEligibility.AddressNotAllowed);
          return reasons;
        }
      }
    }
    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];
      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
        activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [activeConditionIndex, resolvedAddress]);
      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [resolvedAddress]);
      }
      const now = BigNumber.from(Date.now()).div(1e3);
      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
        if (timestampForNextClaim.eq(lib_exports.MaxUint256)) {
          reasons.push(ClaimEligibility.AlreadyClaimed);
        } else {
          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);
        }
        return reasons;
      }
    }
    if (claimCondition.price.gt(0) && isNode()) {
      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));
      const provider = this.contractWrapper.getProvider();
      if (isNativeToken(claimCondition.currencyAddress)) {
        const balance = await provider.getBalance(resolvedAddress);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      } else {
        const ERC20Abi = (await import("./IERC20-GHSR35K6.js")).default;
        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);
        const balance = await erc20.read("balanceOf", [resolvedAddress]);
        if (balance.lt(totalPrice)) {
          reasons.push(ClaimEligibility.NotEnoughTokens);
        }
      }
    }
    return reasons;
  }
  async getClaimerProofs(claimerAddress, claimConditionId) {
    const claimCondition = await this.get(claimConditionId);
    const merkleRoot = claimCondition.merkleRoot;
    const merkleRootArray = utils_exports.stripZeros(merkleRoot);
    if (merkleRootArray.length > 0) {
      const [metadata, resolvedAddress] = await Promise.all([this.metadata.get(), resolveAddress(claimerAddress)]);
      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
    } else {
      return null;
    }
  }
  async getSupplyClaimedByWallet(walletAddress) {
    const resolvedAddress = await resolveAddress(walletAddress);
    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [resolvedAddress]);
    }
    if (this.isNewMultiphaseDrop(this.contractWrapper)) {
      const activeClaimConditionId = await this.contractWrapper.read("getActiveClaimConditionId", []);
      return await this.contractWrapper.read("getSupplyClaimedByWallet", [activeClaimConditionId, resolvedAddress]);
    }
    throw new Error("This contract does not support the getSupplyClaimedByWallet function");
  }
  async getTokenDecimals() {
    if (detectContractFeature(this.contractWrapper, "ERC20")) {
      return this.contractWrapper.read("decimals", []);
    } else {
      return Promise.resolve(0);
    }
  }
  async prepareClaim(quantity, checkERC20Allowance) {
    let decimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let address = arguments.length > 3 ? arguments[3] : void 0;
    const [addressToClaim, activeClaimConditions] = await Promise.all([address ? address : this.contractWrapper.getSignerAddress(), this.getActive()]);
    return prepareClaim(addressToClaim, quantity, activeClaimConditions, async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
  }
  async getClaimArguments(destinationAddress, quantity, claimVerification) {
    const resolvedAddress = await resolveAddress(destinationAddress);
    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];
    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
        proof: claimVerification.proofs,
        maxQuantityInAllowlist: claimVerification.maxClaimable
      }, utils_exports.toUtf8Bytes("")];
    }
    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {
      proof: claimVerification.proofs,
      quantityLimitPerWallet: claimVerification.maxClaimable,
      pricePerToken: claimVerification.priceInProof,
      currency: claimVerification.currencyAddressInProof
    }, utils_exports.toUtf8Bytes("")];
  }
  async getClaimTransaction(destinationAddress, quantity, options) {
    if (options?.pricePerToken) {
      throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");
    }
    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === void 0 ? true : options.checkERC20Allowance, await this.getTokenDecimals());
    return Transaction.fromContractWrapper({
      contractWrapper: this.contractWrapper,
      method: "claim",
      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),
      overrides: claimVerification.overrides
    });
  }
  isNewSinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV2") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV2");
  }
  isNewMultiphaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV2") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV2");
  }
  isLegacySinglePhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimConditionsV1") || detectContractFeature(contractWrapper, "ERC20ClaimConditionsV1");
  }
  isLegacyMultiPhaseDrop(contractWrapper) {
    return detectContractFeature(contractWrapper, "ERC721ClaimPhasesV1") || detectContractFeature(contractWrapper, "ERC20ClaimPhasesV1");
  }
  getSnapshotFormatVersion() {
    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;
  }
};

export {
  DropClaimConditions
};
//# sourceMappingURL=chunk-7Y72NYVJ.js.map

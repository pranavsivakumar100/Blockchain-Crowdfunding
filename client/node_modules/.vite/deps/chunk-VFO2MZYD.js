import {
  cleanCurrencyAddress
} from "./chunk-JKXMTC5W.js";
import {
  getAllInBatches,
  handleTokenApproval,
  isTokenApprovedForTransfer
} from "./chunk-LJDKFPD5.js";
import {
  EndDateSchema,
  RawDateSchema
} from "./chunk-5TGBXTHW.js";
import {
  ContractInterceptor
} from "./chunk-JFA442KI.js";
import {
  InterfaceId_IERC1155,
  InterfaceId_IERC721,
  fetchTokenMetadataForContract
} from "./chunk-POEPSFOQ.js";
import {
  normalizePriceValue,
  setErc20Allowance
} from "./chunk-SRYWWROE.js";
import {
  ContractEncoder,
  ContractEvents,
  GasCostEstimator,
  fetchCurrencyMetadata,
  fetchCurrencyValue,
  isNativeToken
} from "./chunk-LXY7U6R5.js";
import {
  AddressOrEnsSchema,
  AmountSchema,
  AuctionHasNotEndedError,
  BigNumberishSchema,
  ContractWrapper,
  FEATURE_DIRECT_LISTINGS,
  FEATURE_ENGLISH_AUCTIONS,
  FEATURE_OFFERS,
  NATIVE_TOKENS,
  NATIVE_TOKEN_ADDRESS,
  Transaction,
  buildTransactionFunction,
  invariant,
  resolveAddress,
  z
} from "./chunk-CFECTRPO.js";
import {
  Contract,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/marketplacev3-offers-156f3d0f.browser.esm.js
init_shim();
init_lib();
var DirectListingInputParamsSchema = (() => z.object({
  assetContractAddress: AddressOrEnsSchema,
  tokenId: BigNumberishSchema,
  quantity: BigNumberishSchema.default(1),
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  pricePerToken: AmountSchema,
  startTimestamp: RawDateSchema.default(new Date()),
  endTimestamp: EndDateSchema,
  isReservedListing: z.boolean().default(false)
}))();
var Status = function(Status2) {
  Status2[Status2["UNSET"] = 0] = "UNSET";
  Status2[Status2["Created"] = 1] = "Created";
  Status2[Status2["Completed"] = 2] = "Completed";
  Status2[Status2["Cancelled"] = 3] = "Cancelled";
  Status2[Status2["Active"] = 4] = "Active";
  Status2[Status2["Expired"] = 5] = "Expired";
  return Status2;
}({});
var MarketplaceV3DirectListings = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_DIRECT_LISTINGS.name);
    __publicField(this, "createListing", buildTransactionFunction(async (listing) => {
      const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
      const block = await this.contractWrapper.getProvider().getBlock("latest");
      const blockTime = block.timestamp;
      if (parsedListing.startTimestamp.lt(blockTime)) {
        parsedListing.startTimestamp = BigNumber.from(blockTime);
      }
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createListing",
        args: [{
          assetContract: parsedListing.assetContractAddress,
          tokenId: parsedListing.tokenId,
          quantity: parsedListing.quantity,
          currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),
          pricePerToken: normalizedPricePerToken,
          startTimestamp: parsedListing.startTimestamp,
          endTimestamp: parsedListing.endTimestamp,
          reserved: parsedListing.isReservedListing
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewListing", receipt?.logs);
          return {
            id: event[0].args.listingId,
            receipt
          };
        }
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "createListingsBatch", buildTransactionFunction(async (listings) => {
      const data = (await Promise.all(listings.map((listing) => this.createListing.prepare(listing)))).map((tx2) => tx2.encode());
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("NewListing", receipt?.logs);
          return events.map((event) => {
            return {
              id: event.args.listingId,
              receipt
            };
          });
        }
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "updateListing", buildTransactionFunction(async (listingId, listing) => {
      const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "updateListing",
        args: [listingId, {
          assetContract: parsedListing.assetContractAddress,
          tokenId: parsedListing.tokenId,
          quantity: parsedListing.quantity,
          currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),
          pricePerToken: normalizedPricePerToken,
          startTimestamp: parsedListing.startTimestamp,
          endTimestamp: parsedListing.endTimestamp,
          reserved: parsedListing.isReservedListing
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("UpdatedListing", receipt?.logs);
          return {
            id: event[0].args.listingId,
            receipt
          };
        }
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "cancelListing", buildTransactionFunction(async (listingId) => {
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelListing",
        args: [listingId]
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "buyFromListing", buildTransactionFunction(async (listingId, quantityDesired, receiver) => {
      if (receiver) {
        receiver = await resolveAddress(receiver);
      }
      const listing = await this.validateListing(BigNumber.from(listingId));
      const {
        valid,
        error
      } = await this.isStillValidListing(listing, quantityDesired);
      if (!valid) {
        throw new Error(`Listing ${listingId} is no longer valid. ${error}`);
      }
      const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();
      const quantity = BigNumber.from(quantityDesired);
      const value = BigNumber.from(listing.pricePerToken).mul(quantity);
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "buyFromListing",
        args: [listingId, buyFor, quantity, listing.currencyContractAddress, value],
        overrides
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "approveBuyerForReservedListing", buildTransactionFunction(async (listingId, buyer) => {
      const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
      if (!isApproved) {
        const tx = Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [listingId, buyer, true]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
      } else {
        throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);
      }
    }));
    __publicField(this, "revokeBuyerApprovalForReservedListing", buildTransactionFunction(async (listingId, buyer) => {
      const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
      if (isApproved) {
        const tx = Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "approveBuyerForListing",
          args: [listingId, buyer, false]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
      } else {
        throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);
      }
    }));
    __publicField(this, "approveCurrencyForListing", buildTransactionFunction(async (listingId, currencyContractAddress, pricePerTokenInCurrency) => {
      const listing = await this.validateListing(BigNumber.from(listingId));
      const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
      if (resolvedCurrencyAddress === listing.currencyContractAddress) {
        invariant(pricePerTokenInCurrency === listing.pricePerToken, "Approving listing currency with a different price.");
      }
      const currencyPrice = await this.contractWrapper.read("currencyPriceForListing", [listingId, resolvedCurrencyAddress]);
      invariant(pricePerTokenInCurrency === currencyPrice, "Currency already approved with this price.");
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approveCurrencyForListing",
        args: [listingId, resolvedCurrencyAddress, pricePerTokenInCurrency]
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "revokeCurrencyApprovalForListing", buildTransactionFunction(async (listingId, currencyContractAddress) => {
      const listing = await this.validateListing(BigNumber.from(listingId));
      const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
      if (resolvedCurrencyAddress === listing.currencyContractAddress) {
        throw new Error(`Can't revoke approval for main listing currency.`);
      }
      const currencyPrice = await this.contractWrapper.read("currencyPriceForListing", [listingId, resolvedCurrencyAddress]);
      invariant(!currencyPrice.isZero(), "Currency not approved.");
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "approveCurrencyForListing",
        args: [listingId, resolvedCurrencyAddress, BigNumber.from(0)]
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.read("totalListings", []);
  }
  async getAll(filter) {
    const totalListings = await this.getTotalCount();
    const start = BigNumber.from(filter?.start || 0).toNumber();
    const end = totalListings.toNumber();
    if (end === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllListings", [startId, endId]));
    rawListings = batches.flat();
    const filteredListings = await this.applyFilter(rawListings, filter);
    return await Promise.all(filteredListings.map((listing) => this.mapListing(listing)));
  }
  async getAllValid(filter) {
    const totalListings = await this.getTotalCount();
    const start = BigNumber.from(filter?.start || 0).toNumber();
    const end = totalListings.toNumber();
    if (end === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllValidListings", [startId, endId]));
    rawListings = batches.flat();
    const filteredListings = await this.applyFilter(rawListings, filter);
    return await Promise.all(filteredListings.map((listing) => this.mapListing(listing)));
  }
  async getListing(listingId) {
    const listing = await this.contractWrapper.read("getListing", [listingId]);
    return await this.mapListing(listing);
  }
  async isBuyerApprovedForListing(listingId, buyer) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    if (!listing.isReservedListing) {
      throw new Error(`Listing ${listingId} is not a reserved listing.`);
    }
    return await this.contractWrapper.read("isBuyerApprovedForListing", [listingId, await resolveAddress(buyer)]);
  }
  async isCurrencyApprovedForListing(listingId, currency) {
    await this.validateListing(BigNumber.from(listingId));
    return await this.contractWrapper.read("isCurrencyApprovedForListing", [listingId, await resolveAddress(currency)]);
  }
  async currencyPriceForListing(listingId, currencyContractAddress) {
    const listing = await this.validateListing(BigNumber.from(listingId));
    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
    if (resolvedCurrencyAddress === listing.currencyContractAddress) {
      return listing.pricePerToken;
    }
    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);
    if (!isApprovedCurrency) {
      throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);
    }
    return await this.contractWrapper.read("currencyPriceForListing", [listingId, resolvedCurrencyAddress]);
  }
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }
  async mapListing(listing) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (listing.status) {
      case 1:
        status = BigNumber.from(listing.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      assetContractAddress: listing.assetContract,
      currencyContractAddress: listing.currency,
      pricePerToken: listing.pricePerToken.toString(),
      currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId.toString(),
      quantity: listing.quantity.toString(),
      startTimeInSeconds: BigNumber.from(listing.startTimestamp).toNumber(),
      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      endTimeInSeconds: BigNumber.from(listing.endTimestamp).toNumber(),
      creatorAddress: listing.listingCreator,
      isReservedListing: listing.reserved,
      status
    };
  }
  async isStillValidListing(listing, quantity) {
    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);
    if (!approved) {
      return {
        valid: false,
        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`
      };
    }
    const provider = this.contractWrapper.getProvider();
    const ERC165Abi = (await import("./IERC165-WCNTDNAY.js")).default;
    const erc165 = new Contract(listing.assetContractAddress, ERC165Abi, provider);
    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);
    if (isERC721) {
      const ERC721Abi = (await import("./IERC721-STCV7CUU.js")).default;
      const asset = new Contract(listing.assetContractAddress, ERC721Abi, provider);
      let owner;
      try {
        owner = await asset.ownerOf(listing.tokenId);
      } catch (e) {
      }
      const valid = owner?.toLowerCase() === listing.creatorAddress.toLowerCase();
      return {
        valid,
        error: valid ? void 0 : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`
      };
    } else if (isERC1155) {
      const ERC1155Abi = (await import("./IERC1155-KGPYLC2Q.js")).default;
      const asset = new Contract(listing.assetContractAddress, ERC1155Abi, provider);
      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);
      const valid = balance.gte(quantity || listing.quantity);
      return {
        valid,
        error: valid ? void 0 : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`
      };
    } else {
      return {
        valid: false,
        error: "Contract does not implement ERC 1155 or ERC 721."
      };
    }
  }
  async applyFilter(listings, filter) {
    let rawListings = [...listings];
    if (filter) {
      if (filter.seller) {
        const resolvedSeller = await resolveAddress(filter.seller);
        rawListings = rawListings.filter((seller) => seller.listingCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());
      }
      if (filter.tokenContract) {
        const resolvedToken = await resolveAddress(filter.tokenContract);
        rawListings = rawListings.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
      }
      if (filter.tokenId !== void 0) {
        rawListings = rawListings.filter((tokenContract) => tokenContract.tokenId.toString() === filter?.tokenId?.toString());
      }
    }
    return filter?.count && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;
  }
};
var EnglishAuctionInputParamsSchema = (() => z.object({
  assetContractAddress: AddressOrEnsSchema,
  tokenId: BigNumberishSchema,
  quantity: BigNumberishSchema.default(1),
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  minimumBidAmount: AmountSchema,
  buyoutBidAmount: AmountSchema,
  timeBufferInSeconds: BigNumberishSchema.default(900),
  bidBufferBps: BigNumberishSchema.default(500),
  startTimestamp: RawDateSchema.default(new Date()),
  endTimestamp: EndDateSchema
}))();
var MarketplaceV3EnglishAuctions = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_ENGLISH_AUCTIONS.name);
    __publicField(this, "createAuction", buildTransactionFunction(async (auction) => {
      const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);
      await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());
      const normalizedBuyoutAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);
      const normalizedMinBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);
      const block = await this.contractWrapper.getProvider().getBlock("latest");
      const blockTime = block.timestamp;
      if (parsedAuction.startTimestamp.lt(blockTime)) {
        parsedAuction.startTimestamp = BigNumber.from(blockTime);
      }
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "createAuction",
        args: [{
          assetContract: parsedAuction.assetContractAddress,
          tokenId: parsedAuction.tokenId,
          quantity: parsedAuction.quantity,
          currency: cleanCurrencyAddress(parsedAuction.currencyContractAddress),
          minimumBidAmount: normalizedMinBidAmount,
          buyoutBidAmount: normalizedBuyoutAmount,
          timeBufferInSeconds: parsedAuction.timeBufferInSeconds,
          bidBufferBps: parsedAuction.bidBufferBps,
          startTimestamp: parsedAuction.startTimestamp,
          endTimestamp: parsedAuction.endTimestamp
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewAuction", receipt.logs)[0];
          return {
            id: event.args.auctionId,
            receipt
          };
        }
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "createAuctionsBatch", buildTransactionFunction(async (listings) => {
      const data = (await Promise.all(listings.map((listing) => this.createAuction.prepare(listing)))).map((tx2) => tx2.encode());
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "multicall",
        args: [data],
        parse: (receipt) => {
          const events = this.contractWrapper.parseLogs("NewAuction", receipt?.logs);
          return events.map((event) => {
            return {
              id: event.args.auctionId,
              receipt
            };
          });
        }
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "buyoutAuction", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);
      return this.makeBid.prepare(auctionId, utils_exports.formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));
    }));
    __publicField(this, "makeBid", buildTransactionFunction(async (auctionId, bidAmount) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      const normalizedBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);
      if (normalizedBidAmount.eq(BigNumber.from(0))) {
        throw new Error("Cannot make a bid with 0 value");
      }
      if (BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {
        throw new Error("Bid amount must be less than or equal to buyoutBidAmount");
      }
      const winningBid = await this.getWinningBid(auctionId);
      if (winningBid) {
        const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);
        invariant(isWinnner, "Bid price is too low based on the current winning bid and the bid buffer");
      } else {
        const tokenPrice = normalizedBidAmount;
        const minimumBidAmount = BigNumber.from(auction.minimumBidAmount);
        invariant(tokenPrice.gte(minimumBidAmount), "Bid price is too low based on minimum bid amount");
      }
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "bidInAuction",
        overrides,
        args: [auctionId, normalizedBidAmount]
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "cancelAuction", buildTransactionFunction(async (auctionId) => {
      const winningBid = await this.getWinningBid(auctionId);
      if (winningBid) {
        throw new Error(`Bids already made.`);
      }
      const tx = Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelAuction",
        args: [auctionId]
      });
      tx.setGasLimitMultiple(1.2);
      return tx;
    }));
    __publicField(this, "closeAuctionForBidder", buildTransactionFunction(async (auctionId, closeFor) => {
      if (!closeFor) {
        closeFor = await this.contractWrapper.getSignerAddress();
      }
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        const tx = Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "collectAuctionTokens",
          args: [BigNumber.from(auctionId)]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    __publicField(this, "closeAuctionForSeller", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        const tx = Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "collectAuctionPayout",
          args: [BigNumber.from(auctionId)]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    __publicField(this, "executeSale", buildTransactionFunction(async (auctionId) => {
      const auction = await this.validateAuction(BigNumber.from(auctionId));
      try {
        const winningBid = await this.getWinningBid(auctionId);
        invariant(winningBid, "No winning bid found");
        const closeForSeller = this.encoder.encode("collectAuctionPayout", [auctionId]);
        const closeForBuyer = this.encoder.encode("collectAuctionTokens", [auctionId]);
        const tx = Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "multicall",
          args: [[closeForSeller, closeForBuyer]]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
      } catch (err) {
        if (err.message.includes("Marketplace: auction still active.")) {
          throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
        } else {
          throw err;
        }
      }
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.read("totalAuctions", []);
  }
  async getAll(filter) {
    const totalAuctions = await this.getTotalCount();
    const start = BigNumber.from(filter?.start || 0).toNumber();
    const end = totalAuctions.toNumber();
    if (end === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllAuctions", [startId, endId]));
    rawAuctions = batches.flat();
    const filteredAuctions = await this.applyFilter(rawAuctions, filter);
    return await Promise.all(filteredAuctions.map((auction) => this.mapAuction(auction)));
  }
  async getAllValid(filter) {
    const totalAuctions = await this.getTotalCount();
    const start = BigNumber.from(filter?.start || 0).toNumber();
    const end = totalAuctions.toNumber();
    if (end === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllValidAuctions", [startId, endId]));
    rawAuctions = batches.flat();
    const filteredAuctions = await this.applyFilter(rawAuctions, filter);
    return await Promise.all(filteredAuctions.map((auction) => this.mapAuction(auction)));
  }
  async getAuction(auctionId) {
    const auction = await this.contractWrapper.read("getAuction", [auctionId]);
    return await this.mapAuction(auction);
  }
  async getWinningBid(auctionId) {
    await this.validateAuction(BigNumber.from(auctionId));
    const bid = await this.contractWrapper.read("getWinningBid", [auctionId]);
    if (bid._bidder === lib_exports.AddressZero) {
      return void 0;
    }
    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());
  }
  async isWinningBid(auctionId, bidAmount) {
    return await this.contractWrapper.read("isNewWinningBid", [auctionId, bidAmount]);
  }
  async getWinner(auctionId) {
    const auction = await this.validateAuction(BigNumber.from(auctionId));
    const bid = await this.contractWrapper.read("getWinningBid", [auctionId]);
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    const endTime = BigNumber.from(auction.endTimeInSeconds);
    if (now.gt(endTime) && bid._bidder !== lib_exports.AddressZero) {
      return bid._bidder;
    }
    const contractEvent = new ContractEvents(this.contractWrapper);
    const closedAuctions = await contractEvent.getEvents("AuctionClosed");
    const closed = closedAuctions.find((a) => a.data.auctionId.eq(BigNumber.from(auctionId)));
    if (!closed) {
      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);
    }
    return closed.data.winningBidder;
  }
  async getBidBufferBps(auctionId) {
    return (await this.getAuction(auctionId)).bidBufferBps;
  }
  async getMinimumNextBid(auctionId) {
    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), this.validateAuction(BigNumber.from(auctionId))]);
    const currentBidOrReservePrice = winningBid ? BigNumber.from(winningBid.bidAmount) : BigNumber.from(auction.minimumBidAmount);
    const minimumNextBid = currentBidOrReservePrice.add(
      currentBidOrReservePrice.mul(currentBidBufferBps).div(1e4)
    );
    return fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);
  }
  async validateAuction(auctionId) {
    try {
      return await this.getAuction(auctionId);
    } catch (err) {
      console.error(`Error getting the auction with id ${auctionId}`);
      throw err;
    }
  }
  async mapAuction(auction) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (auction.status) {
      case 1:
        status = BigNumber.from(auction.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      id: auction.auctionId.toString(),
      creatorAddress: auction.auctionCreator,
      assetContractAddress: auction.assetContract,
      tokenId: auction.tokenId.toString(),
      quantity: auction.quantity.toString(),
      currencyContractAddress: auction.currency,
      minimumBidAmount: auction.minimumBidAmount.toString(),
      minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),
      buyoutBidAmount: auction.buyoutBidAmount.toString(),
      buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),
      timeBufferInSeconds: BigNumber.from(auction.timeBufferInSeconds).toNumber(),
      bidBufferBps: BigNumber.from(auction.bidBufferBps).toNumber(),
      startTimeInSeconds: BigNumber.from(auction.startTimestamp).toNumber(),
      endTimeInSeconds: BigNumber.from(auction.endTimestamp).toNumber(),
      asset: await fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),
      status
    };
  }
  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {
    const resolvedBidderAddress = await resolveAddress(bidderAddress);
    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);
    return {
      auctionId,
      bidderAddress: resolvedBidderAddress,
      currencyContractAddress: resolvedCurrencyAddress,
      bidAmount,
      bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)
    };
  }
  async applyFilter(auctions, filter) {
    let rawAuctions = [...auctions];
    if (filter) {
      if (filter.seller) {
        const resolvedSeller = await resolveAddress(filter.seller);
        rawAuctions = rawAuctions.filter((seller) => seller.auctionCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());
      }
      if (filter.tokenContract) {
        const resolvedToken = await resolveAddress(filter.tokenContract);
        rawAuctions = rawAuctions.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
      }
      if (filter.tokenId !== void 0) {
        rawAuctions = rawAuctions.filter((tokenContract) => tokenContract.tokenId.toString() === filter?.tokenId?.toString());
      }
    }
    return filter?.count && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;
  }
};
var OfferInputParamsSchema = (() => z.object({
  assetContractAddress: AddressOrEnsSchema,
  tokenId: BigNumberishSchema,
  quantity: BigNumberishSchema.default(1),
  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),
  totalPrice: AmountSchema,
  endTimestamp: EndDateSchema
}))();
var MarketplaceV3Offers = class {
  constructor(contractWrapper, storage) {
    __publicField(this, "featureName", FEATURE_OFFERS.name);
    __publicField(this, "makeOffer", buildTransactionFunction(async (offer) => {
      const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);
      const chainId = await this.contractWrapper.getChainID();
      const currency = isNativeToken(parsedOffer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;
      const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);
      const overrides = await this.contractWrapper.getCallOverrides();
      await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "makeOffer",
        args: [{
          assetContract: parsedOffer.assetContractAddress,
          tokenId: parsedOffer.tokenId,
          quantity: parsedOffer.quantity,
          currency,
          totalPrice: normalizedTotalPrice,
          expirationTimestamp: parsedOffer.endTimestamp
        }],
        parse: (receipt) => {
          const event = this.contractWrapper.parseLogs("NewOffer", receipt?.logs);
          return {
            id: event[0].args.offerId,
            receipt
          };
        }
      });
    }));
    __publicField(this, "cancelOffer", buildTransactionFunction(async (offerId) => {
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "cancelOffer",
        args: [offerId]
      });
    }));
    __publicField(this, "acceptOffer", buildTransactionFunction(async (offerId) => {
      const offer = await this.validateOffer(BigNumber.from(offerId));
      const {
        valid,
        error
      } = await this.isStillValidOffer(offer);
      if (!valid) {
        throw new Error(`Offer ${offerId} is no longer valid. ${error}`);
      }
      const overrides = await this.contractWrapper.getCallOverrides() || {};
      await handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());
      return Transaction.fromContractWrapper({
        contractWrapper: this.contractWrapper,
        method: "acceptOffer",
        args: [offerId],
        overrides
      });
    }));
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new ContractEvents(this.contractWrapper);
    this.encoder = new ContractEncoder(this.contractWrapper);
    this.interceptor = new ContractInterceptor(this.contractWrapper);
    this.estimator = new GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.address;
  }
  async getTotalCount() {
    return await this.contractWrapper.read("totalOffers", []);
  }
  async getAll(filter) {
    const totalOffers = await this.getTotalCount();
    const start = BigNumber.from(filter?.start || 0).toNumber();
    const end = totalOffers.toNumber();
    if (end === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllOffers", [startId, endId]));
    rawOffers = batches.flat();
    const filteredOffers = await this.applyFilter(rawOffers, filter);
    return await Promise.all(filteredOffers.map((offer) => this.mapOffer(offer)));
  }
  async getAllValid(filter) {
    const totalOffers = await this.getTotalCount();
    const start = BigNumber.from(filter?.start || 0).toNumber();
    const end = totalOffers.toNumber();
    if (end === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read("getAllValidOffers", [startId, endId]));
    rawOffers = batches.flat();
    const filteredOffers = await this.applyFilter(rawOffers, filter);
    return await Promise.all(filteredOffers.map((offer) => this.mapOffer(offer)));
  }
  async getOffer(offerId) {
    const offer = await this.contractWrapper.read("getOffer", [offerId]);
    return await this.mapOffer(offer);
  }
  async validateOffer(offerId) {
    try {
      return await this.getOffer(offerId);
    } catch (err) {
      console.error(`Error getting the offer with id ${offerId}`);
      throw err;
    }
  }
  async mapOffer(offer) {
    let status = Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (offer.status) {
      case 1:
        status = BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
        break;
      case 2:
        status = Status.Completed;
        break;
      case 3:
        status = Status.Cancelled;
        break;
    }
    return {
      id: offer.offerId.toString(),
      offerorAddress: offer.offeror,
      assetContractAddress: offer.assetContract,
      currencyContractAddress: offer.currency,
      tokenId: offer.tokenId.toString(),
      quantity: offer.quantity.toString(),
      totalPrice: offer.totalPrice.toString(),
      currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),
      asset: await fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),
      endTimeInSeconds: BigNumber.from(offer.expirationTimestamp).toNumber(),
      status
    };
  }
  async isStillValidOffer(offer) {
    const now = BigNumber.from(Math.floor(Date.now() / 1e3));
    if (now.gt(offer.endTimeInSeconds)) {
      return {
        valid: false,
        error: `Offer with ID ${offer.id} has expired`
      };
    }
    const chainId = await this.contractWrapper.getChainID();
    const currency = isNativeToken(offer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;
    const provider = this.contractWrapper.getProvider();
    const ERC20Abi = (await import("./IERC20-GHSR35K6.js")).default;
    const erc20 = new ContractWrapper(provider, currency, ERC20Abi, {}, this.storage);
    const offerorBalance = await erc20.read("balanceOf", [offer.offerorAddress]);
    if (offerorBalance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`
      };
    }
    const offerorAllowance = await erc20.read("allowance", [offer.offerorAddress, this.getAddress()]);
    if (offerorAllowance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`
      };
    }
    return {
      valid: true,
      error: ""
    };
  }
  async applyFilter(offers, filter) {
    let rawOffers = [...offers];
    if (filter) {
      if (filter.offeror) {
        const resolvedOfferor = await resolveAddress(filter.offeror);
        rawOffers = rawOffers.filter((offeror) => offeror.offeror.toString().toLowerCase() === resolvedOfferor?.toString().toLowerCase());
      }
      if (filter.tokenContract) {
        const resolvedToken = await resolveAddress(filter.tokenContract);
        rawOffers = rawOffers.filter((tokenContract) => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
      }
      if (filter.tokenId !== void 0) {
        rawOffers = rawOffers.filter((tokenContract) => tokenContract.tokenId.toString() === filter?.tokenId?.toString());
      }
    }
    return filter?.count && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;
  }
};

export {
  Status,
  MarketplaceV3DirectListings,
  MarketplaceV3EnglishAuctions,
  MarketplaceV3Offers
};
//# sourceMappingURL=chunk-VFO2MZYD.js.map

import {
  EventType,
  ExtensionNotImplementedError,
  FEATURE_APPURI,
  FEATURE_METADATA,
  NATIVE_TOKEN_ADDRESS,
  Transaction,
  buildTransactionFunction,
  estimateTransactionCost,
  fetchContractMetadataFromAddress,
  getNativeTokenByChainId,
  isExtensionEnabled,
  replaceGatewayUrlWithScheme
} from "./chunk-CFECTRPO.js";
import {
  Contract,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-P6GEGE7G.js";
import {
  BigNumber,
  lib_exports8 as lib_exports
} from "./chunk-77SMNJM3.js";
import {
  init_shim
} from "./chunk-6E35MBRA.js";
import {
  __publicField
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/sdk/dist/contract-appuri-c5be7b04.browser.esm.js
init_shim();
init_lib();
function detectContractFeature(contractWrapper, featureName) {
  const b = isExtensionEnabled(contractWrapper.abi, featureName, contractWrapper.extensions);
  return b;
}
function hasFunction(functionName, contractWrapper) {
  return functionName in contractWrapper.readContract.functions;
}
var ContractMetadata = class {
  constructor(contractWrapper, schema, storage) {
    __publicField(this, "featureName", FEATURE_METADATA.name);
    __publicField(this, "set", buildTransactionFunction(async (metadata) => {
      const uri = await this._parseAndUploadMetadata(metadata);
      const wrapper = this.contractWrapper;
      if (this.supportsContractMetadata(wrapper)) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setContractURI",
          args: [uri],
          parse: (receipt) => {
            return {
              receipt,
              data: this.get
            };
          }
        });
      } else {
        throw new ExtensionNotImplementedError(FEATURE_METADATA);
      }
    }));
    __publicField(this, "update", buildTransactionFunction(async (metadata) => {
      return await this.set.prepare({
        ...await this.get(),
        ...metadata
      });
    }));
    this.contractWrapper = contractWrapper;
    this.schema = schema;
    this.storage = storage;
  }
  parseOutputMetadata(metadata) {
    return this.schema.output.parseAsync(metadata);
  }
  parseInputMetadata(metadata) {
    return this.schema.input.parseAsync(metadata);
  }
  async get() {
    let data;
    if (this.supportsContractMetadata(this.contractWrapper)) {
      const uri = await this.contractWrapper.read("contractURI", []);
      if (uri && uri.includes("://")) {
        data = await this.storage.downloadJSON(uri);
      }
    }
    if (!data) {
      try {
        let contractName;
        try {
          if (hasFunction("name", this.contractWrapper)) {
            contractName = await this.contractWrapper.read("name", []);
          }
        } catch (err) {
        }
        let contractSymbol;
        try {
          if (hasFunction("symbol", this.contractWrapper)) {
            contractSymbol = await this.contractWrapper.read("symbol", []);
          }
        } catch (err) {
        }
        let publishedMetadata;
        try {
          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);
        } catch (err) {
        }
        data = {
          name: contractName || publishedMetadata?.name,
          symbol: contractSymbol,
          description: publishedMetadata?.info.title
        };
      } catch (e) {
        throw new Error("Could not fetch contract metadata");
      }
    }
    return this.parseOutputMetadata(data);
  }
  async _parseAndUploadMetadata(metadata) {
    const parsedMetadata = await this.parseInputMetadata(metadata);
    return this.storage.upload(parsedMetadata);
  }
  supportsContractMetadata(contractWrapper) {
    return detectContractFeature(contractWrapper, "ContractMetadata");
  }
};
var ContractEvents = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  addTransactionListener(listener) {
    this.contractWrapper.addListener(EventType.Transaction, listener);
  }
  removeTransactionListener(listener) {
    this.contractWrapper.off(EventType.Transaction, listener);
  }
  addEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    const address = this.contractWrapper.address;
    const filter = {
      address,
      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]
    };
    const wrappedListener = (log) => {
      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
    };
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  listenToAllEvents(listener) {
    const address = this.contractWrapper.address;
    const filter = {
      address
    };
    const wrappedListener = (log) => {
      try {
        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
      } catch (e) {
        console.error("Could not parse event:", log, e);
      }
    };
    this.contractWrapper.getProvider().on(filter, wrappedListener);
    return () => {
      this.contractWrapper.getProvider().off(filter, wrappedListener);
    };
  }
  removeEventListener(eventName, listener) {
    const event = this.contractWrapper.readContract.interface.getEvent(eventName);
    this.contractWrapper.readContract.off(event.name, listener);
  }
  removeAllListeners() {
    this.contractWrapper.readContract.removeAllListeners();
    const address = this.contractWrapper.address;
    const filter = {
      address
    };
    this.contractWrapper.getProvider().removeAllListeners(filter);
  }
  async getAllEvents() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return filters.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  async getEvents(eventName) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      fromBlock: 0,
      toBlock: "latest",
      order: "desc"
    };
    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);
    const args = options.filters ? eventInterface.inputs.map((e) => options.filters[e.name]) : [];
    const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);
    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);
    const orderedEvents = events.sort((a, b) => {
      return options.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
    });
    return this.parseEvents(orderedEvents);
  }
  parseEvents(events) {
    return events.map((e) => {
      const transaction = Object.fromEntries(Object.entries(e).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
      if (e.args) {
        const entries = Object.entries(e.args);
        const args = entries.slice(entries.length / 2, entries.length);
        const data = {};
        for (const [key, value] of args) {
          data[key] = value;
        }
        return {
          eventName: e.event || "",
          data,
          transaction
        };
      }
      return {
        eventName: e.event || "",
        data: {},
        transaction
      };
    });
  }
  toContractEvent(event, args, rawLog) {
    const transaction = Object.fromEntries(Object.entries(rawLog).filter((a) => typeof a[1] !== "function" && a[0] !== "args"));
    const results = {};
    event.inputs.forEach((param, index) => {
      if (Array.isArray(args[index])) {
        const components = param.components;
        if (components) {
          const arr = args[index];
          if (param.type === "tuple[]") {
            const objArray = [];
            for (let i = 0; i < arr.length; i++) {
              const tuple = arr[i];
              const obj = {};
              for (let j = 0; j < components.length; j++) {
                const name = components[j].name;
                obj[name] = tuple[j];
              }
              objArray.push(obj);
            }
            results[param.name] = objArray;
          } else {
            const obj = {};
            for (let i = 0; i < components.length; i++) {
              const name = components[i].name;
              obj[name] = arr[i];
            }
            results[param.name] = obj;
          }
        }
      } else {
        results[param.name] = args[index];
      }
    });
    return {
      eventName: event.name,
      data: results,
      transaction
    };
  }
};
function toEther(amount) {
  return utils_exports.formatEther(amount);
}
var GasCostEstimator = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  async gasCostOf(fn, args) {
    const gasCost = await estimateTransactionCost(this.contractWrapper.getProvider(), await this.contractWrapper.populateTransaction(fn, args));
    return toEther(gasCost);
  }
  async gasLimitOf(fn, args) {
    return this.contractWrapper.estimateGas(fn, args);
  }
  async currentGasPriceInGwei() {
    const price = await this.contractWrapper.getProvider().getGasPrice();
    return utils_exports.formatUnits(price, "gwei");
  }
};
var ContractAppURI = class {
  constructor(contractWrapper, metadata, storage) {
    __publicField(this, "featureName", FEATURE_APPURI.name);
    __publicField(this, "set", buildTransactionFunction(async (appURI) => {
      if (detectContractFeature(this.contractWrapper, "AppURI")) {
        return Transaction.fromContractWrapper({
          contractWrapper: this.contractWrapper,
          method: "setAppURI",
          args: [appURI]
        });
      }
      return await this.metadata.update.prepare({
        app_uri: appURI
      });
    }));
    this.contractWrapper = contractWrapper;
    this.metadata = metadata;
    this.storage = storage;
  }
  async get() {
    if (detectContractFeature(this.contractWrapper, "AppURI")) {
      return await this.contractWrapper.read("appURI", []);
    }
    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || "", this.storage.getGatewayUrls());
  }
};

// node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-f87e5d3a.browser.esm.js
init_shim();
init_lib();
var ContractEncoder = class {
  constructor(contractWrapper) {
    this.contractWrapper = contractWrapper;
  }
  encode(fn, args) {
    return this.contractWrapper.readContract.interface.encodeFunctionData(fn, args);
  }
  decode(fn, encodedArgs) {
    return this.contractWrapper.readContract.interface.decodeFunctionData(fn, encodedArgs);
  }
  decodeResult(fn, encodedArgs) {
    return this.contractWrapper.readContract.interface.decodeFunctionResult(fn, encodedArgs);
  }
};
function isNativeToken(tokenAddress) {
  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === lib_exports.AddressZero;
}
async function fetchCurrencyMetadata(provider, asset) {
  if (isNativeToken(asset)) {
    const network = await provider.getNetwork();
    const nativeToken = getNativeTokenByChainId(network.chainId);
    return {
      name: nativeToken.name,
      symbol: nativeToken.symbol,
      decimals: nativeToken.decimals
    };
  } else {
    const ERC20MetadataAbi = (await import("./IERC20Metadata-WZRVWLEE.js")).default;
    const erc20 = new Contract(asset, ERC20MetadataAbi, provider);
    const [name, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);
    return {
      name,
      symbol,
      decimals
    };
  }
}
async function fetchCurrencyValue(providerOrSigner, asset, price) {
  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);
  return {
    ...metadata,
    value: BigNumber.from(price),
    displayValue: utils_exports.formatUnits(price, metadata.decimals)
  };
}

export {
  detectContractFeature,
  hasFunction,
  ContractMetadata,
  ContractEvents,
  toEther,
  GasCostEstimator,
  ContractAppURI,
  ContractEncoder,
  isNativeToken,
  fetchCurrencyMetadata,
  fetchCurrencyValue
};
//# sourceMappingURL=chunk-LXY7U6R5.js.map
